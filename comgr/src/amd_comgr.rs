/* automatically generated by rust-bindgen 0.60.1 */

impl amd_comgr_status_s {
    #[doc = " The function has been executed successfully."]
    pub const AMD_COMGR_STATUS_SUCCESS: amd_comgr_status_s = amd_comgr_status_s(0);
}
impl amd_comgr_status_s {
    #[doc = " A generic error has occurred."]
    pub const AMD_COMGR_STATUS_ERROR: amd_comgr_status_s = amd_comgr_status_s(1);
}
impl amd_comgr_status_s {
    #[doc = " One of the actual arguments does not meet a precondition stated"]
    #[doc = " in the documentation of the corresponding formal argument."]
    pub const AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT: amd_comgr_status_s = amd_comgr_status_s(2);
}
impl amd_comgr_status_s {
    #[doc = " Failed to allocate the necessary resources."]
    pub const AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES: amd_comgr_status_s = amd_comgr_status_s(3);
}
#[repr(transparent)]
#[doc = " @brief Status codes."]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub struct amd_comgr_status_s(pub ::std::os::raw::c_uint);
#[doc = " @brief Status codes."]
pub use self::amd_comgr_status_s as amd_comgr_status_t;
impl amd_comgr_language_s {
    #[doc = " No high level language."]
    pub const AMD_COMGR_LANGUAGE_NONE: amd_comgr_language_s = amd_comgr_language_s(0);
}
impl amd_comgr_language_s {
    #[doc = " OpenCL 1.2."]
    pub const AMD_COMGR_LANGUAGE_OPENCL_1_2: amd_comgr_language_s = amd_comgr_language_s(1);
}
impl amd_comgr_language_s {
    #[doc = " OpenCL 2.0."]
    pub const AMD_COMGR_LANGUAGE_OPENCL_2_0: amd_comgr_language_s = amd_comgr_language_s(2);
}
impl amd_comgr_language_s {
    #[doc = " AMD Hetrogeneous C++ (HC)."]
    pub const AMD_COMGR_LANGUAGE_HC: amd_comgr_language_s = amd_comgr_language_s(3);
}
impl amd_comgr_language_s {
    #[doc = " HIP."]
    pub const AMD_COMGR_LANGUAGE_HIP: amd_comgr_language_s = amd_comgr_language_s(4);
}
impl amd_comgr_language_s {
    #[doc = " Marker for last valid language."]
    pub const AMD_COMGR_LANGUAGE_LAST: amd_comgr_language_s = amd_comgr_language_s(4);
}
#[repr(transparent)]
#[doc = " @brief The source languages supported by the compiler."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_language_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The source languages supported by the compiler."]
pub use self::amd_comgr_language_s as amd_comgr_language_t;
impl amd_comgr_data_kind_s {
    #[doc = " No data is available."]
    pub const AMD_COMGR_DATA_KIND_UNDEF: amd_comgr_data_kind_s = amd_comgr_data_kind_s(0);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a textual main source."]
    pub const AMD_COMGR_DATA_KIND_SOURCE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(1);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a textual source that is included in the main source"]
    #[doc = " or other include source."]
    pub const AMD_COMGR_DATA_KIND_INCLUDE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(2);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a precompiled-header source that is included in the main"]
    #[doc = " source or other include source."]
    pub const AMD_COMGR_DATA_KIND_PRECOMPILED_HEADER: amd_comgr_data_kind_s =
        amd_comgr_data_kind_s(3);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a diagnostic output."]
    pub const AMD_COMGR_DATA_KIND_DIAGNOSTIC: amd_comgr_data_kind_s = amd_comgr_data_kind_s(4);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a textual log output."]
    pub const AMD_COMGR_DATA_KIND_LOG: amd_comgr_data_kind_s = amd_comgr_data_kind_s(5);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is compiler LLVM IR bit code for a specific isa."]
    pub const AMD_COMGR_DATA_KIND_BC: amd_comgr_data_kind_s = amd_comgr_data_kind_s(6);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a relocatable machine code object for a specific isa."]
    pub const AMD_COMGR_DATA_KIND_RELOCATABLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(7);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is an executable machine code object for a specific"]
    #[doc = " isa. An executable is the kind of code object that can be loaded"]
    #[doc = " and executed."]
    pub const AMD_COMGR_DATA_KIND_EXECUTABLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(8);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a block of bytes."]
    pub const AMD_COMGR_DATA_KIND_BYTES: amd_comgr_data_kind_s = amd_comgr_data_kind_s(9);
}
impl amd_comgr_data_kind_s {
    #[doc = " The data is a fat binary (clang-offload-bundler output)."]
    pub const AMD_COMGR_DATA_KIND_FATBIN: amd_comgr_data_kind_s = amd_comgr_data_kind_s(16);
}
impl amd_comgr_data_kind_s {
    #[doc = " Marker for last valid data kind."]
    pub const AMD_COMGR_DATA_KIND_LAST: amd_comgr_data_kind_s = amd_comgr_data_kind_s(16);
}
#[repr(transparent)]
#[doc = " @brief The kinds of data supported."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_data_kind_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The kinds of data supported."]
pub use self::amd_comgr_data_kind_s as amd_comgr_data_kind_t;
#[doc = " @brief A handle to a data object."]
#[doc = ""]
#[doc = " Data objects are used to hold the data which is either an input or"]
#[doc = " output of a code object manager action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_data_s {
    pub handle: u64,
}
#[doc = " @brief A handle to a data object."]
#[doc = ""]
#[doc = " Data objects are used to hold the data which is either an input or"]
#[doc = " output of a code object manager action."]
pub type amd_comgr_data_t = amd_comgr_data_s;
#[doc = " @brief A handle to an action data object."]
#[doc = ""]
#[doc = " An action data object holds a set of data objects. These can be"]
#[doc = " used as inputs to an action, or produced as the result of an"]
#[doc = " action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_data_set_s {
    pub handle: u64,
}
#[doc = " @brief A handle to an action data object."]
#[doc = ""]
#[doc = " An action data object holds a set of data objects. These can be"]
#[doc = " used as inputs to an action, or produced as the result of an"]
#[doc = " action."]
pub type amd_comgr_data_set_t = amd_comgr_data_set_s;
#[doc = " @brief A handle to an action information object."]
#[doc = ""]
#[doc = " An action information object holds all the necessary information,"]
#[doc = " excluding the input data objects, required to perform an action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_action_info_s {
    pub handle: u64,
}
#[doc = " @brief A handle to an action information object."]
#[doc = ""]
#[doc = " An action information object holds all the necessary information,"]
#[doc = " excluding the input data objects, required to perform an action."]
pub type amd_comgr_action_info_t = amd_comgr_action_info_s;
impl amd_comgr_action_kind_s {
    #[doc = " Preprocess each source data object in @p input in order. For each"]
    #[doc = " successful preprocessor invocation, add a source data object to @p result."]
    #[doc = " Resolve any include source names using the names of include data objects"]
    #[doc = " in @p input. Resolve any include relative path names using the working"]
    #[doc = " directory path in @p info. Preprocess the source for the language in @p"]
    #[doc = " info."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any preprocessing fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_SOURCE_TO_PREPROCESSOR: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(0);
}
impl amd_comgr_action_kind_s {
    #[doc = " Copy all existing data objects in @p input to @p output, then add the"]
    #[doc = " device-specific and language-specific precompiled headers required for"]
    #[doc = " compilation."]
    #[doc = ""]
    #[doc = " Currently the only supported languages are @p AMD_COMGR_LANGUAGE_OPENCL_1_2"]
    #[doc = " and @p AMD_COMGR_LANGUAGE_OPENCL_2_0."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT if isa name or language"]
    #[doc = " is not set in @p info, or the language is not supported."]
    pub const AMD_COMGR_ACTION_ADD_PRECOMPILED_HEADERS: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(1);
}
impl amd_comgr_action_kind_s {
    #[doc = " Compile each source data object in @p input in order. For each"]
    #[doc = " successful compilation add a bc data object to @p result. Resolve"]
    #[doc = " any include source names using the names of include data objects"]
    #[doc = " in @p input. Resolve any include relative path names using the"]
    #[doc = " working directory path in @p info. Produce bc for isa name in @p"]
    #[doc = " info. Compile the source for the language in @p info."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any compilation"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(2);
}
impl amd_comgr_action_kind_s {
    #[doc = " Copy all existing data objects in @p input to @p output, then add the"]
    #[doc = " device-specific and language-specific bitcode libraries required for"]
    #[doc = " compilation."]
    #[doc = ""]
    #[doc = " Currently the only supported languages are @p AMD_COMGR_LANGUAGE_OPENCL_1_2,"]
    #[doc = " @p AMD_COMGR_LANGUAGE_OPENCL_2_0, and @p AMD_COMGR_LANGUAGE_HIP."]
    #[doc = ""]
    #[doc = " The options in @p info should be set to a set of language-specific flags."]
    #[doc = " For OpenCL and HIP these include:"]
    #[doc = ""]
    #[doc = "    correctly_rounded_sqrt"]
    #[doc = "    daz_opt"]
    #[doc = "    finite_only"]
    #[doc = "    unsafe_math"]
    #[doc = "    wavefrontsize64"]
    #[doc = ""]
    #[doc = " For example, to enable daz_opt and unsafe_math, the options should be set"]
    #[doc = " as:"]
    #[doc = ""]
    #[doc = "    const char *options[] = {\"daz_opt, \"unsafe_math\"};"]
    #[doc = "    size_t optionsCount = sizeof(options) / sizeof(options[0]);"]
    #[doc = "    amd_comgr_action_info_set_option_list(info, options, optionsCount);"]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT if isa name or language"]
    #[doc = " is not set in @p info, the language is not supported, an unknown"]
    #[doc = " language-specific flag is supplied, or a language-specific flag is"]
    #[doc = " repeated."]
    #[doc = ""]
    #[doc = " @deprecated since 1.7"]
    #[doc = " @warning This action, followed by @c AMD_COMGR_ACTION_LINK_BC_TO_BC, may"]
    #[doc = " result in subtle bugs due to incorrect linking of the device libraries."]
    #[doc = " The @c AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC action can"]
    #[doc = " be used as a workaround which ensures the link occurs correctly."]
    pub const AMD_COMGR_ACTION_ADD_DEVICE_LIBRARIES: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(3);
}
impl amd_comgr_action_kind_s {
    #[doc = " Link each bc data object in @p input together and add the linked"]
    #[doc = " bc data object to @p result. Any device library bc data object"]
    #[doc = " must be explicitly added to @p input if needed."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if the link fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_LINK_BC_TO_BC: amd_comgr_action_kind_s = amd_comgr_action_kind_s(4);
}
impl amd_comgr_action_kind_s {
    #[doc = " Optimize each bc data object in @p input and create an optimized bc data"]
    #[doc = " object to @p result."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if the optimization fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_OPTIMIZE_BC_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(5);
}
impl amd_comgr_action_kind_s {
    #[doc = " Perform code generation for each bc data object in @p input in"]
    #[doc = " order. For each successful code generation add a relocatable data"]
    #[doc = " object to @p result."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any code"]
    #[doc = " generation fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_CODEGEN_BC_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(6);
}
impl amd_comgr_action_kind_s {
    #[doc = " Perform code generation for each bc data object in @p input in"]
    #[doc = " order. For each successful code generation add an assembly source data"]
    #[doc = " object to @p result."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any code"]
    #[doc = " generation fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_CODEGEN_BC_TO_ASSEMBLY: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(7);
}
impl amd_comgr_action_kind_s {
    #[doc = " Link each relocatable data object in @p input together and add"]
    #[doc = " the linked relocatable data object to @p result. Any device"]
    #[doc = " library relocatable data object must be explicitly added to @p"]
    #[doc = " input if needed."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if the link fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(8);
}
impl amd_comgr_action_kind_s {
    #[doc = " Link each relocatable data object in @p input together and add"]
    #[doc = " the linked executable data object to @p result. Any device"]
    #[doc = " library relocatable data object must be explicitly added to @p"]
    #[doc = " input if needed."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if the link fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_EXECUTABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(9);
}
impl amd_comgr_action_kind_s {
    #[doc = " Assemble each source data object in @p input in order into machine code."]
    #[doc = " For each successful assembly add a relocatable data object to @p result."]
    #[doc = " Resolve any include source names using the names of include data objects in"]
    #[doc = " @p input. Resolve any include relative path names using the working"]
    #[doc = " directory path in @p info. Produce relocatable for isa name in @p info."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any assembly fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT if isa name is not set in"]
    #[doc = " @p info."]
    pub const AMD_COMGR_ACTION_ASSEMBLE_SOURCE_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(10);
}
impl amd_comgr_action_kind_s {
    #[doc = " Disassemble each relocatable data object in @p input in"]
    #[doc = " order. For each successful disassembly add a source data object to"]
    #[doc = " @p result."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any disassembly"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_RELOCATABLE_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(11);
}
impl amd_comgr_action_kind_s {
    #[doc = " Disassemble each executable data object in @p input in order. For"]
    #[doc = " each successful disassembly add a source data object to @p result."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any disassembly"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info and does not match the isa name"]
    #[doc = " of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_EXECUTABLE_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(12);
}
impl amd_comgr_action_kind_s {
    #[doc = " Disassemble each bytes data object in @p input in order. For each"]
    #[doc = " successful disassembly add a source data object to @p"]
    #[doc = " result. Only simple assembly language commands are generate that"]
    #[doc = " corresponf to raw bytes are supported, not any directives that"]
    #[doc = " control the code object layout, or symbolic branch targets or"]
    #[doc = " names."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any disassembly"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name is not set in @p info"]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_BYTES_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(13);
}
impl amd_comgr_action_kind_s {
    #[doc = " Compile each source data object in @p input in order. For each"]
    #[doc = " successful compilation add a fat binary to @p result. Resolve"]
    #[doc = " any include source names using the names of include data objects"]
    #[doc = " in @p input. Resolve any include relative path names using the"]
    #[doc = " working directory path in @p info. Produce fat binary for isa name in @p"]
    #[doc = " info. Compile the source for the language in @p info."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any compilation"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_TO_FATBIN: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(14);
}
impl amd_comgr_action_kind_s {
    #[doc = " Compile each source data object in @p input in order. For each"]
    #[doc = " successful compilation add a bc data object to @p result. Resolve"]
    #[doc = " any include source names using the names of include data objects"]
    #[doc = " in @p input. Resolve any include relative path names using the"]
    #[doc = " working directory path in @p info. Produce bc for isa name in @p"]
    #[doc = " info. Compile the source for the language in @p info. Link against"]
    #[doc = " the device-specific and language-specific bitcode device libraries"]
    #[doc = " required for compilation."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR if any compilation"]
    #[doc = " fails."]
    #[doc = ""]
    #[doc = " Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT"]
    #[doc = " if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(15);
}
impl amd_comgr_action_kind_s {
    #[doc = " Marker for last valid action kind."]
    pub const AMD_COMGR_ACTION_LAST: amd_comgr_action_kind_s = amd_comgr_action_kind_s(15);
}
#[repr(transparent)]
#[doc = " @brief The kinds of actions that can be performed."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_action_kind_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The kinds of actions that can be performed."]
pub use self::amd_comgr_action_kind_s as amd_comgr_action_kind_t;
extern crate libloading;
pub struct LibComgr {
    __library: ::libloading::Library,
    pub amd_comgr_create_data: unsafe extern "C" fn(
        kind: amd_comgr_data_kind_t,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t,
    pub amd_comgr_release_data: unsafe extern "C" fn(data: amd_comgr_data_t) -> amd_comgr_status_t,
    pub amd_comgr_set_data: unsafe extern "C" fn(
        data: amd_comgr_data_t,
        size: usize,
        bytes: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t,
    pub amd_comgr_set_data_name: unsafe extern "C" fn(
        data: amd_comgr_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t,
    pub amd_comgr_get_data: unsafe extern "C" fn(
        data: amd_comgr_data_t,
        size: *mut usize,
        bytes: *mut ::std::os::raw::c_char,
    ) -> amd_comgr_status_t,
    pub amd_comgr_get_data_name: unsafe extern "C" fn(
        data: amd_comgr_data_t,
        size: *mut usize,
        name: *mut ::std::os::raw::c_char,
    ) -> amd_comgr_status_t,
    pub amd_comgr_create_data_set:
        unsafe extern "C" fn(data_set: *mut amd_comgr_data_set_t) -> amd_comgr_status_t,
    pub amd_comgr_destroy_data_set:
        unsafe extern "C" fn(data_set: amd_comgr_data_set_t) -> amd_comgr_status_t,
    pub amd_comgr_data_set_add: unsafe extern "C" fn(
        data_set: amd_comgr_data_set_t,
        data: amd_comgr_data_t,
    ) -> amd_comgr_status_t,
    pub amd_comgr_action_data_get_data: unsafe extern "C" fn(
        data_set: amd_comgr_data_set_t,
        data_kind: amd_comgr_data_kind_t,
        index: usize,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t,
    pub amd_comgr_create_action_info:
        unsafe extern "C" fn(action_info: *mut amd_comgr_action_info_t) -> amd_comgr_status_t,
    pub amd_comgr_destroy_action_info:
        unsafe extern "C" fn(action_info: amd_comgr_action_info_t) -> amd_comgr_status_t,
    pub amd_comgr_action_info_set_isa_name: unsafe extern "C" fn(
        action_info: amd_comgr_action_info_t,
        isa_name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t,
    pub amd_comgr_action_info_set_language: unsafe extern "C" fn(
        action_info: amd_comgr_action_info_t,
        language: amd_comgr_language_t,
    ) -> amd_comgr_status_t,
    pub amd_comgr_action_info_set_option_list: unsafe extern "C" fn(
        action_info: amd_comgr_action_info_t,
        options: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> amd_comgr_status_t,
    pub amd_comgr_do_action: unsafe extern "C" fn(
        kind: amd_comgr_action_kind_t,
        info: amd_comgr_action_info_t,
        input: amd_comgr_data_set_t,
        result: amd_comgr_data_set_t,
    ) -> amd_comgr_status_t,
}
impl LibComgr {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let amd_comgr_create_data = __library.get(b"amd_comgr_create_data\0").map(|sym| *sym)?;
        let amd_comgr_release_data = __library.get(b"amd_comgr_release_data\0").map(|sym| *sym)?;
        let amd_comgr_set_data = __library.get(b"amd_comgr_set_data\0").map(|sym| *sym)?;
        let amd_comgr_set_data_name = __library
            .get(b"amd_comgr_set_data_name\0")
            .map(|sym| *sym)?;
        let amd_comgr_get_data = __library.get(b"amd_comgr_get_data\0").map(|sym| *sym)?;
        let amd_comgr_get_data_name = __library
            .get(b"amd_comgr_get_data_name\0")
            .map(|sym| *sym)?;
        let amd_comgr_create_data_set = __library
            .get(b"amd_comgr_create_data_set\0")
            .map(|sym| *sym)?;
        let amd_comgr_destroy_data_set = __library
            .get(b"amd_comgr_destroy_data_set\0")
            .map(|sym| *sym)?;
        let amd_comgr_data_set_add = __library.get(b"amd_comgr_data_set_add\0").map(|sym| *sym)?;
        let amd_comgr_action_data_get_data = __library
            .get(b"amd_comgr_action_data_get_data\0")
            .map(|sym| *sym)?;
        let amd_comgr_create_action_info = __library
            .get(b"amd_comgr_create_action_info\0")
            .map(|sym| *sym)?;
        let amd_comgr_destroy_action_info = __library
            .get(b"amd_comgr_destroy_action_info\0")
            .map(|sym| *sym)?;
        let amd_comgr_action_info_set_isa_name = __library
            .get(b"amd_comgr_action_info_set_isa_name\0")
            .map(|sym| *sym)?;
        let amd_comgr_action_info_set_language = __library
            .get(b"amd_comgr_action_info_set_language\0")
            .map(|sym| *sym)?;
        let amd_comgr_action_info_set_option_list = __library
            .get(b"amd_comgr_action_info_set_option_list\0")
            .map(|sym| *sym)?;
        let amd_comgr_do_action = __library.get(b"amd_comgr_do_action\0").map(|sym| *sym)?;
        Ok(LibComgr {
            __library,
            amd_comgr_create_data,
            amd_comgr_release_data,
            amd_comgr_set_data,
            amd_comgr_set_data_name,
            amd_comgr_get_data,
            amd_comgr_get_data_name,
            amd_comgr_create_data_set,
            amd_comgr_destroy_data_set,
            amd_comgr_data_set_add,
            amd_comgr_action_data_get_data,
            amd_comgr_create_action_info,
            amd_comgr_destroy_action_info,
            amd_comgr_action_info_set_isa_name,
            amd_comgr_action_info_set_language,
            amd_comgr_action_info_set_option_list,
            amd_comgr_do_action,
        })
    }
    #[must_use]
    #[doc = " @brief Create a data object that can hold data of a specified kind."]
    #[doc = ""]
    #[doc = " Data objects are reference counted and are destroyed when the"]
    #[doc = " reference count reaches 0. When a data object is created its"]
    #[doc = " reference count is 1, it has 0 bytes of data, it has an empty name,"]
    #[doc = " and it has no metadata."]
    #[doc = ""]
    #[doc = " @param[in] kind The kind of data the object is intended to hold."]
    #[doc = ""]
    #[doc = " @param[out] data A handle to the data object created. Its reference"]
    #[doc = " count is set to 1."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " kind is an invalid data kind, or @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF. @p data is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to create the data object as out of resources."]
    pub unsafe fn amd_comgr_create_data(
        &self,
        kind: amd_comgr_data_kind_t,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_create_data)(kind, data)
    }
    #[must_use]
    #[doc = " @brief Indicate that no longer using a data object handle."]
    #[doc = ""]
    #[doc = " The reference count of the associated data object is"]
    #[doc = " decremented. If it reaches 0 it is destroyed."]
    #[doc = ""]
    #[doc = " @param[in] data The data object to release."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " data is an invalid data object, or has kind @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_release_data(&self, data: amd_comgr_data_t) -> amd_comgr_status_t {
        (self.amd_comgr_release_data)(data)
    }
    #[must_use]
    #[doc = " @brief Set the data content of a data object to the specified"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " Any previous value of the data object is overwritten. Any metadata"]
    #[doc = " associated with the data object is also replaced which invalidates"]
    #[doc = " all metadata handles to the old metadata."]
    #[doc = ""]
    #[doc = " @param[in] data The data object to update."]
    #[doc = ""]
    #[doc = " @param[in] size The number of bytes in the data specified by @p bytes."]
    #[doc = ""]
    #[doc = " @param[in] bytes The bytes to set the data object to. The bytes are"]
    #[doc = " copied into the data object and can be freed after the call."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " data is an invalid data object, or has kind @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_set_data(
        &self,
        data: amd_comgr_data_t,
        size: usize,
        bytes: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_set_data)(data, size, bytes)
    }
    #[must_use]
    #[doc = " @brief Set the name associated with a data object."]
    #[doc = ""]
    #[doc = " When compiling, the fle name of an include directive is used to"]
    #[doc = " reference the contents of the include data object with the same"]
    #[doc = " name. The name may also be used for other data objects in log and"]
    #[doc = " diagnostic output."]
    #[doc = ""]
    #[doc = " @param[in] data The data object to update."]
    #[doc = ""]
    #[doc = " @param[in] name A null terminated string that specifies the name to"]
    #[doc = " use for the data object. If NULL then the name is set to the empty"]
    #[doc = " string."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " data is an invalid data object, or has kind @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_set_data_name(
        &self,
        data: amd_comgr_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_set_data_name)(data, name)
    }
    #[must_use]
    #[doc = " @brief Get the data contents, and/or the size of the data"]
    #[doc = " associated with a data object."]
    #[doc = ""]
    #[doc = " @param[in] data The data object to query."]
    #[doc = ""]
    #[doc = " @param[in, out] size On entry, the size of @p bytes. On return, if @p bytes"]
    #[doc = " is NULL, set to the size of the data object contents."]
    #[doc = ""]
    #[doc = " @param[out] bytes If not NULL, then the first @p size bytes of the"]
    #[doc = " data object contents is copied. If NULL, no data is copied, and"]
    #[doc = " only @p size is updated (useful in order to find the size of buffer"]
    #[doc = " required to copy the data)."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " data is an invalid data object, or has kind @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF. @p size is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_get_data(
        &self,
        data: amd_comgr_data_t,
        size: *mut usize,
        bytes: *mut ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_get_data)(data, size, bytes)
    }
    #[must_use]
    #[doc = " @brief Get the data object name and/or name length."]
    #[doc = ""]
    #[doc = " @param[in] data The data object to query."]
    #[doc = ""]
    #[doc = " @param[in, out] size On entry, the size of @p name. On return, the size of"]
    #[doc = " the data object name including the terminating null character."]
    #[doc = ""]
    #[doc = " @param[out] name If not NULL, then the first @p size characters of the"]
    #[doc = " data object name are copied. If @p name is NULL, only @p size is updated"]
    #[doc = " (useful in order to find the size of buffer required to copy the name)."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " data is an invalid data object, or has kind @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF. @p size is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_get_data_name(
        &self,
        data: amd_comgr_data_t,
        size: *mut usize,
        name: *mut ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_get_data_name)(data, size, name)
    }
    #[must_use]
    #[doc = " @brief Create a data set object."]
    #[doc = ""]
    #[doc = " @param[out] data_set A handle to the data set created. Initially it"]
    #[doc = " contains no data objects."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to create the data"]
    #[doc = " set object as out of resources."]
    pub unsafe fn amd_comgr_create_data_set(
        &self,
        data_set: *mut amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_create_data_set)(data_set)
    }
    #[must_use]
    #[doc = " @brief Destroy a data set object."]
    #[doc = ""]
    #[doc = " The reference counts of any associated data objects are decremented. Any"]
    #[doc = " handles to the data set object become invalid."]
    #[doc = ""]
    #[doc = " @param[in] data_set A handle to the data set object to destroy."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid"]
    #[doc = " data set object."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update data set"]
    #[doc = " object as out of resources."]
    pub unsafe fn amd_comgr_destroy_data_set(
        &self,
        data_set: amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_destroy_data_set)(data_set)
    }
    #[must_use]
    #[doc = " @brief Add a data object to a data set object if it is not already added."]
    #[doc = ""]
    #[doc = " The reference count of the data object is incremented."]
    #[doc = ""]
    #[doc = " @param[in] data_set A handle to the data set object to be updated."]
    #[doc = ""]
    #[doc = " @param[in] data A handle to the data object to be added. If @p data_set"]
    #[doc = " already has the specified handle present, then it is not added. The order"]
    #[doc = " that data objects are added is preserved."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid"]
    #[doc = " data set object. @p data is an invalid data object; has undef kind; has"]
    #[doc = " include kind but does not have a name."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update data set"]
    #[doc = " object as out of resources."]
    pub unsafe fn amd_comgr_data_set_add(
        &self,
        data_set: amd_comgr_data_set_t,
        data: amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_data_set_add)(data_set, data)
    }
    #[must_use]
    #[doc = " @brief Return the Nth data object of a specified data kind that is added to a"]
    #[doc = " data set object."]
    #[doc = ""]
    #[doc = " The reference count of the returned data object is incremented."]
    #[doc = ""]
    #[doc = " @param[in] data_set A handle to the data set object to be queried."]
    #[doc = ""]
    #[doc = " @param[in] data_kind The data kind of the data object to be returned."]
    #[doc = ""]
    #[doc = " @param[in] index The index of the data object of data kind @data_kind to be"]
    #[doc = " returned. The first data object is index 0. The order of data objects matches"]
    #[doc = " the order that they were added to the data set object."]
    #[doc = ""]
    #[doc = " @param[out] data The data object being requested."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid"]
    #[doc = " data set object. @p data_kind is an invalid data kind or @p"]
    #[doc = " AMD_COMGR_DATA_KIND_UNDEF. @p index is greater than the number of data"]
    #[doc = " objects of kind @p data_kind. @p data is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to query data set"]
    #[doc = " object as out of resources."]
    pub unsafe fn amd_comgr_action_data_get_data(
        &self,
        data_set: amd_comgr_data_set_t,
        data_kind: amd_comgr_data_kind_t,
        index: usize,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_action_data_get_data)(data_set, data_kind, index, data)
    }
    #[must_use]
    #[doc = " @brief Create an action info object."]
    #[doc = ""]
    #[doc = " @param[out] action_info A handle to the action info object created."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " action_info is NULL."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to create the action info object as out of resources."]
    pub unsafe fn amd_comgr_create_action_info(
        &self,
        action_info: *mut amd_comgr_action_info_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_create_action_info)(action_info)
    }
    #[must_use]
    #[doc = " @brief Destroy an action info object."]
    #[doc = ""]
    #[doc = " @param[in] action_info A handle to the action info object to destroy."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " action_info is an invalid action info object."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_destroy_action_info(
        &self,
        action_info: amd_comgr_action_info_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_destroy_action_info)(action_info)
    }
    #[must_use]
    #[doc = " @brief Set the isa name of an action info object."]
    #[doc = ""]
    #[doc = " When an action info object is created it has no isa name. Some"]
    #[doc = " actions require that the action info object has an isa name"]
    #[doc = " defined."]
    #[doc = ""]
    #[doc = " @param[in] action_info A handle to the action info object to be"]
    #[doc = " updated."]
    #[doc = ""]
    #[doc = " @param[in] isa_name A null terminated string that is the isa name. If NULL"]
    #[doc = " or the empty string then the isa name is cleared. The isa name is defined as"]
    #[doc = " the Code Object Target Identification string, described at"]
    #[doc = " https://llvm.org/docs/AMDGPUUsage.html#code-object-target-identification"]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " action_info is an invalid action info object. @p isa_name is not an"]
    #[doc = " isa name supported by this version of the code object manager"]
    #[doc = " library."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_isa_name(
        &self,
        action_info: amd_comgr_action_info_t,
        isa_name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_action_info_set_isa_name)(action_info, isa_name)
    }
    #[must_use]
    #[doc = " @brief Set the source language of an action info object."]
    #[doc = ""]
    #[doc = " When an action info object is created it has no language defined"]
    #[doc = " which is represented by @p"]
    #[doc = " AMD_COMGR_LANGUAGE_NONE. Some actions require that"]
    #[doc = " the action info object has a source language defined."]
    #[doc = ""]
    #[doc = " @param[in] action_info A handle to the action info object to be"]
    #[doc = " updated."]
    #[doc = ""]
    #[doc = " @param[in] language The language to set. If @p"]
    #[doc = " AMD_COMGR_LANGUAGE_NONE then the language is cleared."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " action_info is an invalid action info object. @p language is an"]
    #[doc = " invalid language."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_language(
        &self,
        action_info: amd_comgr_action_info_t,
        language: amd_comgr_language_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_action_info_set_language)(action_info, language)
    }
    #[must_use]
    #[doc = " @brief Set the options array of an action info object."]
    #[doc = ""]
    #[doc = " This overrides any option strings or arrays previously set by calls to this"]
    #[doc = " function or @p amd_comgr_action_info_set_options."]
    #[doc = ""]
    #[doc = " An @p action_info object which had its options set with this function can"]
    #[doc = " only have its option inspected with @p"]
    #[doc = " amd_comgr_action_info_get_option_list_count and @p"]
    #[doc = " amd_comgr_action_info_get_option_list_item."]
    #[doc = ""]
    #[doc = " @param[in] action_info A handle to the action info object to be updated."]
    #[doc = ""]
    #[doc = " @param[in] options An array of null terminated strings. May be NULL if @p"]
    #[doc = " count is zero, which will result in an empty options array."]
    #[doc = ""]
    #[doc = " @param[in] count The number of null terminated strings in @p options."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed"]
    #[doc = " successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p action_info is an"]
    #[doc = " invalid action info object, or @p options is NULL and @p count is non-zero."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update action"]
    #[doc = " info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_option_list(
        &self,
        action_info: amd_comgr_action_info_t,
        options: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_action_info_set_option_list)(action_info, options, count)
    }
    #[must_use]
    #[doc = " @brief Perform an action."]
    #[doc = ""]
    #[doc = " Each action ignores any data objects in @p input that it does not"]
    #[doc = " use. If logging is enabled in @info then @p result will have a log"]
    #[doc = " data object added. Any diagnostic data objects produced by the"]
    #[doc = " action will be added to @p result. See the description of each"]
    #[doc = " action in @p amd_comgr_action_kind_t."]
    #[doc = ""]
    #[doc = " @param[in] kind The action to perform."]
    #[doc = ""]
    #[doc = " @param[in] info The action info to use when performing the action."]
    #[doc = ""]
    #[doc = " @param[in] input The input data objects to the @p kind action."]
    #[doc = ""]
    #[doc = " @param[out] result Any data objects are removed before performing"]
    #[doc = " the action which then adds all data objects produced by the action."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_SUCCESS The function has"]
    #[doc = " been executed successfully."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR An error was"]
    #[doc = " reported when executing the action."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p"]
    #[doc = " kind is an invalid action kind. @p input_data or @p result_data are"]
    #[doc = " invalid action data object handles. See the description of each"]
    #[doc = " action in @p amd_comgr_action_kind_t for other"]
    #[doc = " conditions that result in this status."]
    #[doc = ""]
    #[doc = " @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES"]
    #[doc = " Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_do_action(
        &self,
        kind: amd_comgr_action_kind_t,
        info: amd_comgr_action_info_t,
        input: amd_comgr_data_set_t,
        result: amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self.amd_comgr_do_action)(kind, info, input, result)
    }
}
