/* automatically generated by rust-bindgen 0.72.0 */

pub const AMD_COMGR_INTERFACE_VERSION_MAJOR: u32 = 3;
pub const AMD_COMGR_INTERFACE_VERSION_MINOR: u32 = 0;
impl amd_comgr_status_s {
    #[doc = " A generic error has occurred."]
    pub const AMD_COMGR_STATUS_ERROR: amd_comgr_status_s =
        amd_comgr_status_s(unsafe { ::std::num::NonZeroU32::new_unchecked(1) });
    #[doc = " One of the actual arguments does not meet a precondition stated\n in the documentation of the corresponding formal argument. This\n includes both invalid Action types, and invalid arguments to\n valid Action types."]
    pub const AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT: amd_comgr_status_s =
        amd_comgr_status_s(unsafe { ::std::num::NonZeroU32::new_unchecked(2) });
    #[doc = " Failed to allocate the necessary resources."]
    pub const AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES: amd_comgr_status_s =
        amd_comgr_status_s(unsafe { ::std::num::NonZeroU32::new_unchecked(3) });
}
#[repr(transparent)]
#[doc = " @brief Status codes."]
#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]
pub struct amd_comgr_status_s(pub ::std::num::NonZeroU32);
type amd_comgr_status_t = Result<(), self::amd_comgr_status_s>;
impl amd_comgr_language_s {
    #[doc = " No high level language."]
    pub const AMD_COMGR_LANGUAGE_NONE: amd_comgr_language_s = amd_comgr_language_s(0);
    #[doc = " OpenCL 1.2."]
    pub const AMD_COMGR_LANGUAGE_OPENCL_1_2: amd_comgr_language_s = amd_comgr_language_s(1);
    #[doc = " OpenCL 2.0."]
    pub const AMD_COMGR_LANGUAGE_OPENCL_2_0: amd_comgr_language_s = amd_comgr_language_s(2);
    #[doc = " HIP."]
    pub const AMD_COMGR_LANGUAGE_HIP: amd_comgr_language_s = amd_comgr_language_s(3);
    #[doc = " LLVM IR, either textual (.ll) or bitcode (.bc) format."]
    pub const AMD_COMGR_LANGUAGE_LLVM_IR: amd_comgr_language_s = amd_comgr_language_s(4);
    #[doc = " Marker for last valid language."]
    pub const AMD_COMGR_LANGUAGE_LAST: amd_comgr_language_s = amd_comgr_language_s(4);
}
#[repr(transparent)]
#[doc = " @brief The source languages supported by the compiler."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_language_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The source languages supported by the compiler."]
pub use self::amd_comgr_language_s as amd_comgr_language_t;
impl amd_comgr_data_kind_s {
    #[doc = " No data is available."]
    pub const AMD_COMGR_DATA_KIND_UNDEF: amd_comgr_data_kind_s = amd_comgr_data_kind_s(0);
    #[doc = " The data is a textual main source."]
    pub const AMD_COMGR_DATA_KIND_SOURCE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(1);
    #[doc = " The data is a textual source that is included in the main source\n or other include source."]
    pub const AMD_COMGR_DATA_KIND_INCLUDE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(2);
    #[doc = " The data is a precompiled-header source that is included in the main\n source or other include source."]
    pub const AMD_COMGR_DATA_KIND_PRECOMPILED_HEADER: amd_comgr_data_kind_s =
        amd_comgr_data_kind_s(3);
    #[doc = " The data is a diagnostic output."]
    pub const AMD_COMGR_DATA_KIND_DIAGNOSTIC: amd_comgr_data_kind_s = amd_comgr_data_kind_s(4);
    #[doc = " The data is a textual log output."]
    pub const AMD_COMGR_DATA_KIND_LOG: amd_comgr_data_kind_s = amd_comgr_data_kind_s(5);
    #[doc = " The data is compiler LLVM IR bit code for a specific isa."]
    pub const AMD_COMGR_DATA_KIND_BC: amd_comgr_data_kind_s = amd_comgr_data_kind_s(6);
    #[doc = " The data is a relocatable machine code object for a specific isa."]
    pub const AMD_COMGR_DATA_KIND_RELOCATABLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(7);
    #[doc = " The data is an executable machine code object for a specific\n isa. An executable is the kind of code object that can be loaded\n and executed."]
    pub const AMD_COMGR_DATA_KIND_EXECUTABLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(8);
    #[doc = " The data is a block of bytes."]
    pub const AMD_COMGR_DATA_KIND_BYTES: amd_comgr_data_kind_s = amd_comgr_data_kind_s(9);
    #[doc = " The data is a fat binary (clang-offload-bundler output)."]
    pub const AMD_COMGR_DATA_KIND_FATBIN: amd_comgr_data_kind_s = amd_comgr_data_kind_s(16);
    #[doc = " The data is an archive."]
    pub const AMD_COMGR_DATA_KIND_AR: amd_comgr_data_kind_s = amd_comgr_data_kind_s(17);
    #[doc = " The data is a bitcode bundle."]
    pub const AMD_COMGR_DATA_KIND_BC_BUNDLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(18);
    #[doc = " The data is an archive bundle."]
    pub const AMD_COMGR_DATA_KIND_AR_BUNDLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(19);
    #[doc = " The data is an object file bundle."]
    pub const AMD_COMGR_DATA_KIND_OBJ_BUNDLE: amd_comgr_data_kind_s = amd_comgr_data_kind_s(20);
    #[doc = " The data is SPIR-V IR"]
    pub const AMD_COMGR_DATA_KIND_SPIRV: amd_comgr_data_kind_s = amd_comgr_data_kind_s(21);
    #[doc = " Marker for last valid data kind."]
    pub const AMD_COMGR_DATA_KIND_LAST: amd_comgr_data_kind_s = amd_comgr_data_kind_s(21);
}
#[repr(transparent)]
#[doc = " @brief The kinds of data supported."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_data_kind_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The kinds of data supported."]
pub use self::amd_comgr_data_kind_s as amd_comgr_data_kind_t;
#[doc = " @brief A handle to a data object.\n\n Data objects are used to hold the data which is either an input or\n output of a code object manager action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_data_s {
    pub handle: u64,
}
#[doc = " @brief A handle to a data object.\n\n Data objects are used to hold the data which is either an input or\n output of a code object manager action."]
pub type amd_comgr_data_t = amd_comgr_data_s;
#[doc = " @brief A handle to an action data object.\n\n An action data object holds a set of data objects. These can be\n used as inputs to an action, or produced as the result of an\n action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_data_set_s {
    pub handle: u64,
}
#[doc = " @brief A handle to an action data object.\n\n An action data object holds a set of data objects. These can be\n used as inputs to an action, or produced as the result of an\n action."]
pub type amd_comgr_data_set_t = amd_comgr_data_set_s;
#[doc = " @brief A handle to an action information object.\n\n An action information object holds all the necessary information,\n excluding the input data objects, required to perform an action."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_action_info_s {
    pub handle: u64,
}
#[doc = " @brief A handle to an action information object.\n\n An action information object holds all the necessary information,\n excluding the input data objects, required to perform an action."]
pub type amd_comgr_action_info_t = amd_comgr_action_info_s;
#[doc = " @brief A handle to a machine code object symbol.\n\n A symbol handle is used to obtain the properties of symbols of a machine code\n object. A symbol handle is invalidated when the data object containing the\n symbol is destroyed."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amd_comgr_symbol_s {
    pub handle: u64,
}
#[doc = " @brief A handle to a machine code object symbol.\n\n A symbol handle is used to obtain the properties of symbols of a machine code\n object. A symbol handle is invalidated when the data object containing the\n symbol is destroyed."]
pub type amd_comgr_symbol_t = amd_comgr_symbol_s;
impl amd_comgr_action_kind_s {
    #[doc = " Preprocess each source data object in @p input in order. For each\n successful preprocessor invocation, add a source data object to @p result.\n Resolve any include source names using the names of include data objects\n in @p input. Resolve any include relative path names using the working\n directory path in @p info. Preprocess the source for the language in @p\n info.\n\n Return @p AMD_COMGR_STATUS_ERROR if any preprocessing fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_SOURCE_TO_PREPROCESSOR: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(0);
    #[doc = " Copy all existing data objects in @p input to @p output, then add the\n device-specific and language-specific precompiled headers required for\n compilation.\n\n Currently the only supported languages are @p AMD_COMGR_LANGUAGE_OPENCL_1_2\n and @p AMD_COMGR_LANGUAGE_OPENCL_2_0.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT if isa name or language\n is not set in @p info, or the language is not supported."]
    pub const AMD_COMGR_ACTION_ADD_PRECOMPILED_HEADERS: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(1);
    #[doc = " Compile each source data object in @p input in order. For each\n successful compilation add a bc data object to @p result. Resolve\n any include source names using the names of include data objects\n in @p input. Resolve any include relative path names using the\n working directory path in @p info. Produce bc for isa name in @p\n info. Compile the source for the language in @p info.\n\n Return @p AMD_COMGR_STATUS_ERROR if any compilation\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(2);
    #[doc = " Link a collection of bitcodes, bundled bitcodes, and bundled bitcode\n archives in @p into a single composite (unbundled) bitcode @p.\n Any device library bc data object must be explicitly added to @p input if\n needed.\n\n Return @p AMD_COMGR_STATUS_ERROR if the link or unbundling fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if IsaName is not set in @p info and does not match the isa name\n of all bc data objects in @p input, or if the Name field is not set for\n any DataObject in the input set."]
    pub const AMD_COMGR_ACTION_LINK_BC_TO_BC: amd_comgr_action_kind_s = amd_comgr_action_kind_s(3);
    #[doc = " Perform code generation for each bc data object in @p input in\n order. For each successful code generation add a relocatable data\n object to @p result.\n\n Return @p AMD_COMGR_STATUS_ERROR if any code\n generation fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_CODEGEN_BC_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(4);
    #[doc = " Perform code generation for each bc data object in @p input in\n order. For each successful code generation add an assembly source data\n object to @p result.\n\n Return @p AMD_COMGR_STATUS_ERROR if any code\n generation fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all bc data objects in @p input."]
    pub const AMD_COMGR_ACTION_CODEGEN_BC_TO_ASSEMBLY: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(5);
    #[doc = " Link each relocatable data object in @p input together and add\n the linked relocatable data object to @p result. Any device\n library relocatable data object must be explicitly added to @p\n input if needed.\n\n Return @p AMD_COMGR_STATUS_ERROR if the link fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(6);
    #[doc = " Link each relocatable data object in @p input together and add\n the linked executable data object to @p result. Any device\n library relocatable data object must be explicitly added to @p\n input if needed.\n\n Return @p AMD_COMGR_STATUS_ERROR if the link fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_LINK_RELOCATABLE_TO_EXECUTABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(7);
    #[doc = " Assemble each source data object in @p input in order into machine code.\n For each successful assembly add a relocatable data object to @p result.\n Resolve any include source names using the names of include data objects in\n @p input. Resolve any include relative path names using the working\n directory path in @p info. Produce relocatable for isa name in @p info.\n\n Return @p AMD_COMGR_STATUS_ERROR if any assembly fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT if isa name is not set in\n @p info."]
    pub const AMD_COMGR_ACTION_ASSEMBLE_SOURCE_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(8);
    #[doc = " Disassemble each relocatable data object in @p input in\n order. For each successful disassembly add a source data object to\n @p result.\n\n Return @p AMD_COMGR_STATUS_ERROR if any disassembly\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_RELOCATABLE_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(9);
    #[doc = " Disassemble each executable data object in @p input in order. For\n each successful disassembly add a source data object to @p result.\n\n Return @p AMD_COMGR_STATUS_ERROR if any disassembly\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info and does not match the isa name\n of all relocatable data objects in @p input."]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_EXECUTABLE_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(10);
    #[doc = " Disassemble each bytes data object in @p input in order. For each\n successful disassembly add a source data object to @p\n result. Only simple assembly language commands are generate that\n corresponf to raw bytes are supported, not any directives that\n control the code object layout, or symbolic branch targets or\n names.\n\n Return @p AMD_COMGR_STATUS_ERROR if any disassembly\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name is not set in @p info"]
    pub const AMD_COMGR_ACTION_DISASSEMBLE_BYTES_TO_SOURCE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(11);
    #[doc = " Compile each source data object in @p input in order. For each\n successful compilation add a bc data object to @p result. Resolve\n any include source names using the names of include data objects\n in @p input. Resolve any include relative path names using the\n working directory path in @p info. Produce bc for isa name in @p\n info. Compile the source for the language in @p info. Link against\n the device-specific and language-specific bitcode device libraries\n required for compilation.\n\n Return @p AMD_COMGR_STATUS_ERROR if any compilation\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_WITH_DEVICE_LIBS_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(12);
    #[doc = " Compile a single source data object in @p input in order. For each\n successful compilation add a relocatable data object to @p result.\n Resolve any include source names using the names of include data objects\n in @p input. Resolve any include relative path names using the\n working directory path in @p info. Produce relocatable for hip name in @p\n info. Compile the source for the language in @p info. Link against\n the device-specific and language-specific bitcode device libraries\n required for compilation. Currently only supports HIP language.\n\n Return @p AMD_COMGR_STATUS_ERROR if any compilation\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_TO_RELOCATABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(13);
    #[doc = " Compile each source data object in @p input and create a single executabele\n in @p result. Resolve any include source names using the names of include\n data objects in @p input. Resolve any include relative path names using the\n working directory path in @p info. Produce executable for isa name in @p\n info. Compile the source for the language in @p info. Link against\n the device-specific and language-specific bitcode device libraries\n required for compilation.\n\n Return @p AMD_COMGR_STATUS_ERROR if any compilation\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_COMPILE_SOURCE_TO_EXECUTABLE: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(14);
    #[doc = " Unbundle each source data object in @p input. These objects can be\n bitcode bundles, or an archive containing bitcode bundles. For each\n successful unbundling, add a bc object or archive object to @p result,\n depending on the corresponding input.\n\n Return @p AMD_COMGR_STATUS_ERROR if any unbundling\n fails.\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if isa name or language is not set in @p info."]
    pub const AMD_COMGR_ACTION_UNBUNDLE: amd_comgr_action_kind_s = amd_comgr_action_kind_s(15);
    #[doc = " Translate each source SPIR-V object in @p input into LLVM IR Bitcode.\n For each successful translation, add a bc object to @p result   *\n\n Return @p AMD_COMGR_STATUS_ERROR if any translation fails\n\n Return @p AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT\n if any input is not SPIR-V."]
    pub const AMD_COMGR_ACTION_TRANSLATE_SPIRV_TO_BC: amd_comgr_action_kind_s =
        amd_comgr_action_kind_s(19);
    #[doc = " Marker for last valid action kind."]
    pub const AMD_COMGR_ACTION_LAST: amd_comgr_action_kind_s = amd_comgr_action_kind_s(19);
}
#[repr(transparent)]
#[doc = " @brief The kinds of actions that can be performed."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_action_kind_s(pub ::std::os::raw::c_uint);
#[doc = " @brief The kinds of actions that can be performed."]
pub use self::amd_comgr_action_kind_s as amd_comgr_action_kind_t;
impl amd_comgr_symbol_type_s {
    #[doc = " The symbol's type is unknown.\n\n The user should not infer any specific type for symbols which return\n `AMD_COMGR_SYMBOL_TYPE_UNKNOWN`, and these symbols may return different\n types in future releases."]
    pub const AMD_COMGR_SYMBOL_TYPE_UNKNOWN: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(-1);
    #[doc = " The symbol's type is not specified."]
    pub const AMD_COMGR_SYMBOL_TYPE_NOTYPE: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(0);
    #[doc = " The symbol is associated with a data object, such as a variable, an array,\n and so on."]
    pub const AMD_COMGR_SYMBOL_TYPE_OBJECT: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(1);
    #[doc = " The symbol is associated with a function or other executable code."]
    pub const AMD_COMGR_SYMBOL_TYPE_FUNC: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(2);
    #[doc = " The symbol is associated with a section. Symbol table entries of this type\n exist primarily for relocation."]
    pub const AMD_COMGR_SYMBOL_TYPE_SECTION: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(3);
    #[doc = " Conventionally, the symbol's name gives the name of the source file\n associated with the object file."]
    pub const AMD_COMGR_SYMBOL_TYPE_FILE: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(4);
    #[doc = " The symbol labels an uninitialized common block."]
    pub const AMD_COMGR_SYMBOL_TYPE_COMMON: amd_comgr_symbol_type_s = amd_comgr_symbol_type_s(5);
    #[doc = " The symbol is associated with an AMDGPU Code Object V2 kernel function."]
    pub const AMD_COMGR_SYMBOL_TYPE_AMDGPU_HSA_KERNEL: amd_comgr_symbol_type_s =
        amd_comgr_symbol_type_s(10);
}
#[repr(transparent)]
#[doc = " @brief Machine code object symbol type."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_symbol_type_s(pub ::std::os::raw::c_int);
#[doc = " @brief Machine code object symbol type."]
pub use self::amd_comgr_symbol_type_s as amd_comgr_symbol_type_t;
impl amd_comgr_symbol_info_s {
    #[doc = " The length of the symbol name in bytes. Does not include the NUL\n terminator. The type of this attribute is uint64_t."]
    pub const AMD_COMGR_SYMBOL_INFO_NAME_LENGTH: amd_comgr_symbol_info_s =
        amd_comgr_symbol_info_s(0);
    #[doc = " The name of the symbol. The type of this attribute is character array with\n the length equal to the value of the @p AMD_COMGR_SYMBOL_INFO_NAME_LENGTH\n attribute plus 1 for a NUL terminator."]
    pub const AMD_COMGR_SYMBOL_INFO_NAME: amd_comgr_symbol_info_s = amd_comgr_symbol_info_s(1);
    #[doc = " The kind of the symbol. The type of this attribute is @p\n amd_comgr_symbol_type_t."]
    pub const AMD_COMGR_SYMBOL_INFO_TYPE: amd_comgr_symbol_info_s = amd_comgr_symbol_info_s(2);
    #[doc = " Size of the variable. The value of this attribute is undefined if the\n symbol is not a variable. The type of this attribute is uint64_t."]
    pub const AMD_COMGR_SYMBOL_INFO_SIZE: amd_comgr_symbol_info_s = amd_comgr_symbol_info_s(3);
    #[doc = " Indicates whether the symbol is undefined. The type of this attribute is\n bool."]
    pub const AMD_COMGR_SYMBOL_INFO_IS_UNDEFINED: amd_comgr_symbol_info_s =
        amd_comgr_symbol_info_s(4);
    #[doc = " The value of the symbol. The type of this attribute is uint64_t."]
    pub const AMD_COMGR_SYMBOL_INFO_VALUE: amd_comgr_symbol_info_s = amd_comgr_symbol_info_s(5);
    #[doc = " Marker for last valid symbol info."]
    pub const AMD_COMGR_SYMBOL_INFO_LAST: amd_comgr_symbol_info_s = amd_comgr_symbol_info_s(5);
}
#[repr(transparent)]
#[doc = " @brief Machine code object symbol attributes."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct amd_comgr_symbol_info_s(pub ::std::os::raw::c_uint);
#[doc = " @brief Machine code object symbol attributes."]
pub use self::amd_comgr_symbol_info_s as amd_comgr_symbol_info_t;
pub struct Comgr3 {
    __library: ::libloading::Library,
    pub amd_comgr_get_version:
        Result<unsafe extern "C" fn(major: *mut usize, minor: *mut usize), ::libloading::Error>,
    pub amd_comgr_create_data: Result<
        unsafe extern "C" fn(
            kind: amd_comgr_data_kind_t,
            data: *mut amd_comgr_data_t,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_set_data: Result<
        unsafe extern "C" fn(
            data: amd_comgr_data_t,
            size: usize,
            bytes: *const ::std::os::raw::c_char,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_set_data_name: Result<
        unsafe extern "C" fn(
            data: amd_comgr_data_t,
            name: *const ::std::os::raw::c_char,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_get_data: Result<
        unsafe extern "C" fn(
            data: amd_comgr_data_t,
            size: *mut usize,
            bytes: *mut ::std::os::raw::c_char,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_create_data_set: Result<
        unsafe extern "C" fn(data_set: *mut amd_comgr_data_set_t) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_destroy_data_set: Result<
        unsafe extern "C" fn(data_set: amd_comgr_data_set_t) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_data_set_add: Result<
        unsafe extern "C" fn(
            data_set: amd_comgr_data_set_t,
            data: amd_comgr_data_t,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_action_data_get_data: Result<
        unsafe extern "C" fn(
            data_set: amd_comgr_data_set_t,
            data_kind: amd_comgr_data_kind_t,
            index: usize,
            data: *mut amd_comgr_data_t,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_create_action_info: Result<
        unsafe extern "C" fn(action_info: *mut amd_comgr_action_info_t) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_destroy_action_info: Result<
        unsafe extern "C" fn(action_info: amd_comgr_action_info_t) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_action_info_set_isa_name: Result<
        unsafe extern "C" fn(
            action_info: amd_comgr_action_info_t,
            isa_name: *const ::std::os::raw::c_char,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_action_info_set_language: Result<
        unsafe extern "C" fn(
            action_info: amd_comgr_action_info_t,
            language: amd_comgr_language_t,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_action_info_set_option_list: Result<
        unsafe extern "C" fn(
            action_info: amd_comgr_action_info_t,
            options: *mut *const ::std::os::raw::c_char,
            count: usize,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_do_action: Result<
        unsafe extern "C" fn(
            kind: amd_comgr_action_kind_t,
            info: amd_comgr_action_info_t,
            input: amd_comgr_data_set_t,
            result: amd_comgr_data_set_t,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_iterate_symbols: Result<
        unsafe extern "C" fn(
            data: amd_comgr_data_t,
            callback: ::std::option::Option<
                unsafe extern "C" fn(
                    symbol: amd_comgr_symbol_t,
                    user_data: *mut ::std::os::raw::c_void,
                ) -> amd_comgr_status_t,
            >,
            user_data: *mut ::std::os::raw::c_void,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
    pub amd_comgr_symbol_get_info: Result<
        unsafe extern "C" fn(
            symbol: amd_comgr_symbol_t,
            attribute: amd_comgr_symbol_info_t,
            value: *mut ::std::os::raw::c_void,
        ) -> amd_comgr_status_t,
        ::libloading::Error,
    >,
}
impl Comgr3 {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let amd_comgr_get_version = __library.get(b"amd_comgr_get_version\0").map(|sym| *sym);
        let amd_comgr_create_data = __library.get(b"amd_comgr_create_data\0").map(|sym| *sym);
        let amd_comgr_set_data = __library.get(b"amd_comgr_set_data\0").map(|sym| *sym);
        let amd_comgr_set_data_name = __library.get(b"amd_comgr_set_data_name\0").map(|sym| *sym);
        let amd_comgr_get_data = __library.get(b"amd_comgr_get_data\0").map(|sym| *sym);
        let amd_comgr_create_data_set = __library
            .get(b"amd_comgr_create_data_set\0")
            .map(|sym| *sym);
        let amd_comgr_destroy_data_set = __library
            .get(b"amd_comgr_destroy_data_set\0")
            .map(|sym| *sym);
        let amd_comgr_data_set_add = __library.get(b"amd_comgr_data_set_add\0").map(|sym| *sym);
        let amd_comgr_action_data_get_data = __library
            .get(b"amd_comgr_action_data_get_data\0")
            .map(|sym| *sym);
        let amd_comgr_create_action_info = __library
            .get(b"amd_comgr_create_action_info\0")
            .map(|sym| *sym);
        let amd_comgr_destroy_action_info = __library
            .get(b"amd_comgr_destroy_action_info\0")
            .map(|sym| *sym);
        let amd_comgr_action_info_set_isa_name = __library
            .get(b"amd_comgr_action_info_set_isa_name\0")
            .map(|sym| *sym);
        let amd_comgr_action_info_set_language = __library
            .get(b"amd_comgr_action_info_set_language\0")
            .map(|sym| *sym);
        let amd_comgr_action_info_set_option_list = __library
            .get(b"amd_comgr_action_info_set_option_list\0")
            .map(|sym| *sym);
        let amd_comgr_do_action = __library.get(b"amd_comgr_do_action\0").map(|sym| *sym);
        let amd_comgr_iterate_symbols = __library
            .get(b"amd_comgr_iterate_symbols\0")
            .map(|sym| *sym);
        let amd_comgr_symbol_get_info = __library
            .get(b"amd_comgr_symbol_get_info\0")
            .map(|sym| *sym);
        Ok(Comgr3 {
            __library,
            amd_comgr_get_version,
            amd_comgr_create_data,
            amd_comgr_set_data,
            amd_comgr_set_data_name,
            amd_comgr_get_data,
            amd_comgr_create_data_set,
            amd_comgr_destroy_data_set,
            amd_comgr_data_set_add,
            amd_comgr_action_data_get_data,
            amd_comgr_create_action_info,
            amd_comgr_destroy_action_info,
            amd_comgr_action_info_set_isa_name,
            amd_comgr_action_info_set_language,
            amd_comgr_action_info_set_option_list,
            amd_comgr_do_action,
            amd_comgr_iterate_symbols,
            amd_comgr_symbol_get_info,
        })
    }
    #[doc = " @brief Get the version of the code object manager interface\n supported.\n\n An interface is backwards compatible with an implementation with an\n equal major version, and a greater than or equal minor version.\n\n @param[out] major Major version number.\n\n @param[out] minor Minor version number."]
    pub unsafe fn amd_comgr_get_version(&self, major: *mut usize, minor: *mut usize) {
        (self
            .amd_comgr_get_version
            .as_ref()
            .expect("Expected function, got error."))(major, minor)
    }
    #[must_use]
    #[doc = " @brief Create a data object that can hold data of a specified kind.\n\n Data objects are reference counted and are destroyed when the\n reference count reaches 0. When a data object is created its\n reference count is 1, it has 0 bytes of data, it has an empty name,\n and it has no metadata.\n\n @param[in] kind The kind of data the object is intended to hold.\n\n @param[out] data A handle to the data object created. Its reference\n count is set to 1.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n kind is an invalid data kind, or @p\n AMD_COMGR_DATA_KIND_UNDEF. @p data is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to create the data object as out of resources."]
    pub unsafe fn amd_comgr_create_data(
        &self,
        kind: amd_comgr_data_kind_t,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_create_data
            .as_ref()
            .expect("Expected function, got error."))(kind, data)
    }
    #[must_use]
    #[doc = " @brief Set the data content of a data object to the specified\n bytes.\n\n Any previous value of the data object is overwritten. Any metadata\n associated with the data object is also replaced which invalidates\n all metadata handles to the old metadata.\n\n @param[in] data The data object to update.\n\n @param[in] size The number of bytes in the data specified by @p bytes.\n\n @param[in] bytes The bytes to set the data object to. The bytes are\n copied into the data object and can be freed after the call.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n data is an invalid data object, or has kind @p\n AMD_COMGR_DATA_KIND_UNDEF.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_set_data(
        &self,
        data: amd_comgr_data_t,
        size: usize,
        bytes: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_set_data
            .as_ref()
            .expect("Expected function, got error."))(data, size, bytes)
    }
    #[must_use]
    #[doc = " @brief Set the name associated with a data object.\n\n When compiling, the full name of an include directive is used to\n reference the contents of the include data object with the same\n name. The name may also be used for other data objects in log and\n diagnostic output.\n\n @param[in] data The data object to update.\n\n @param[in] name A null terminated string that specifies the name to\n use for the data object. If NULL then the name is set to the empty\n string.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n data is an invalid data object, or has kind @p\n AMD_COMGR_DATA_KIND_UNDEF.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_set_data_name(
        &self,
        data: amd_comgr_data_t,
        name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_set_data_name
            .as_ref()
            .expect("Expected function, got error."))(data, name)
    }
    #[must_use]
    #[doc = " @brief Get the data contents, and/or the size of the data\n associated with a data object.\n\n @param[in] data The data object to query.\n\n @param[in, out] size On entry, the size of @p bytes. On return, if @p bytes\n is NULL, set to the size of the data object contents.\n\n @param[out] bytes If not NULL, then the first @p size bytes of the\n data object contents is copied. If NULL, no data is copied, and\n only @p size is updated (useful in order to find the size of buffer\n required to copy the data).\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n data is an invalid data object, or has kind @p\n AMD_COMGR_DATA_KIND_UNDEF. @p size is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_get_data(
        &self,
        data: amd_comgr_data_t,
        size: *mut usize,
        bytes: *mut ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_get_data
            .as_ref()
            .expect("Expected function, got error."))(data, size, bytes)
    }
    #[must_use]
    #[doc = " @brief Create a data set object.\n\n @param[out] data_set A handle to the data set created. Initially it\n contains no data objects.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed\n successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to create the data\n set object as out of resources."]
    pub unsafe fn amd_comgr_create_data_set(
        &self,
        data_set: *mut amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_create_data_set
            .as_ref()
            .expect("Expected function, got error."))(data_set)
    }
    #[must_use]
    #[doc = " @brief Destroy a data set object.\n\n The reference counts of any associated data objects are decremented. Any\n handles to the data set object become invalid.\n\n @param[in] data_set A handle to the data set object to destroy.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed\n successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid\n data set object.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update data set\n object as out of resources."]
    pub unsafe fn amd_comgr_destroy_data_set(
        &self,
        data_set: amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_destroy_data_set
            .as_ref()
            .expect("Expected function, got error."))(data_set)
    }
    #[must_use]
    #[doc = " @brief Add a data object to a data set object if it is not already added.\n\n The reference count of the data object is incremented.\n\n @param[in] data_set A handle to the data set object to be updated.\n\n @param[in] data A handle to the data object to be added. If @p data_set\n already has the specified handle present, then it is not added. The order\n that data objects are added is preserved.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed\n successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid\n data set object. @p data is an invalid data object; has undef kind; has\n include kind but does not have a name.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update data set\n object as out of resources."]
    pub unsafe fn amd_comgr_data_set_add(
        &self,
        data_set: amd_comgr_data_set_t,
        data: amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_data_set_add
            .as_ref()
            .expect("Expected function, got error."))(data_set, data)
    }
    #[must_use]
    #[doc = " @brief Return the Nth data object of a specified data kind that is added to a\n data set object.\n\n The reference count of the returned data object is incremented.\n\n @param[in] data_set A handle to the data set object to be queried.\n\n @param[in] data_kind The data kind of the data object to be returned.\n\n @param[in] index The index of the data object of data kind @data_kind to be\n returned. The first data object is index 0. The order of data objects matches\n the order that they were added to the data set object.\n\n @param[out] data The data object being requested.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed\n successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data_set is an invalid\n data set object. @p data_kind is an invalid data kind or @p\n AMD_COMGR_DATA_KIND_UNDEF. @p index is greater than the number of data\n objects of kind @p data_kind. @p data is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to query data set\n object as out of resources."]
    pub unsafe fn amd_comgr_action_data_get_data(
        &self,
        data_set: amd_comgr_data_set_t,
        data_kind: amd_comgr_data_kind_t,
        index: usize,
        data: *mut amd_comgr_data_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_action_data_get_data
            .as_ref()
            .expect("Expected function, got error."))(data_set, data_kind, index, data)
    }
    #[must_use]
    #[doc = " @brief Create an action info object.\n\n @param[out] action_info A handle to the action info object created.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n action_info is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to create the action info object as out of resources."]
    pub unsafe fn amd_comgr_create_action_info(
        &self,
        action_info: *mut amd_comgr_action_info_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_create_action_info
            .as_ref()
            .expect("Expected function, got error."))(action_info)
    }
    #[must_use]
    #[doc = " @brief Destroy an action info object.\n\n @param[in] action_info A handle to the action info object to destroy.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n action_info is an invalid action info object.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_destroy_action_info(
        &self,
        action_info: amd_comgr_action_info_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_destroy_action_info
            .as_ref()
            .expect("Expected function, got error."))(action_info)
    }
    #[must_use]
    #[doc = " @brief Set the isa name of an action info object.\n\n When an action info object is created it has no isa name. Some\n actions require that the action info object has an isa name\n defined.\n\n @param[in] action_info A handle to the action info object to be\n updated.\n\n @param[in] isa_name A null terminated string that is the isa name. If NULL\n or the empty string then the isa name is cleared. The isa name is defined as\n the Code Object Target Identification string, described at\n https://llvm.org/docs/AMDGPUUsage.html#code-object-target-identification\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n action_info is an invalid action info object. @p isa_name is not an\n isa name supported by this version of the code object manager\n library.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_isa_name(
        &self,
        action_info: amd_comgr_action_info_t,
        isa_name: *const ::std::os::raw::c_char,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_action_info_set_isa_name
            .as_ref()
            .expect("Expected function, got error."))(action_info, isa_name)
    }
    #[must_use]
    #[doc = " @brief Set the source language of an action info object.\n\n When an action info object is created it has no language defined\n which is represented by @p\n AMD_COMGR_LANGUAGE_NONE. Some actions require that\n the action info object has a source language defined.\n\n @param[in] action_info A handle to the action info object to be\n updated.\n\n @param[in] language The language to set. If @p\n AMD_COMGR_LANGUAGE_NONE then the language is cleared.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n action_info is an invalid action info object. @p language is an\n invalid language.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update action info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_language(
        &self,
        action_info: amd_comgr_action_info_t,
        language: amd_comgr_language_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_action_info_set_language
            .as_ref()
            .expect("Expected function, got error."))(action_info, language)
    }
    #[must_use]
    #[doc = " @brief Set the options array of an action info object.\n\n This overrides any option strings or arrays previously set by calls to this\n function.\n\n An @p action_info object which had its options set with this function can\n only have its option inspected with @p\n amd_comgr_action_info_get_option_list_count and @p\n amd_comgr_action_info_get_option_list_item.\n\n @param[in] action_info A handle to the action info object to be updated.\n\n @param[in] options An array of null terminated strings. May be NULL if @p\n count is zero, which will result in an empty options array.\n\n @param[in] count The number of null terminated strings in @p options.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has been executed\n successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p action_info is an\n invalid action info object, or @p options is NULL and @p count is non-zero.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES Unable to update action\n info object as out of resources."]
    pub unsafe fn amd_comgr_action_info_set_option_list(
        &self,
        action_info: amd_comgr_action_info_t,
        options: *mut *const ::std::os::raw::c_char,
        count: usize,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_action_info_set_option_list
            .as_ref()
            .expect("Expected function, got error."))(action_info, options, count)
    }
    #[must_use]
    #[doc = " @brief Perform an action.\n\n Each action ignores any data objects in @p input that it does not\n use. If logging is enabled in @info then @p result will have a log\n data object added. Any diagnostic data objects produced by the\n action will be added to @p result. See the description of each\n action in @p amd_comgr_action_kind_t.\n\n @param[in] kind The action to perform.\n\n @param[in] info The action info to use when performing the action.\n\n @param[in] input The input data objects to the @p kind action.\n\n @param[out] result Any data objects are removed before performing\n the action which then adds all data objects produced by the action.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR An error was\n reported when executing the action.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p\n kind is an invalid action kind. @p input_data or @p result_data are\n invalid action data object handles. See the description of each\n action in @p amd_comgr_action_kind_t for other\n conditions that result in this status.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to update the data object as out of resources."]
    pub unsafe fn amd_comgr_do_action(
        &self,
        kind: amd_comgr_action_kind_t,
        info: amd_comgr_action_info_t,
        input: amd_comgr_data_set_t,
        result: amd_comgr_data_set_t,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_do_action
            .as_ref()
            .expect("Expected function, got error."))(kind, info, input, result)
    }
    #[must_use]
    #[doc = " @brief Iterate over the symbols of a machine code object.\n\n For a AMD_COMGR_DATA_KIND_RELOCATABLE the symbols in the ELF symtab section\n are iterated. For a AMD_COMGR_DATA_KIND_EXECUTABLE the symbols in the ELF\n dynsymtab are iterated.\n\n @param[in] data The data object to query.\n\n @param[in] callback The function to call for each symbol in the machine code\n data object. The symbol handle is passed in @p symbol and @p user_data is\n passed as @p user_data. If the function returns with a status other than @p\n AMD_COMGR_STATUS_SUCCESS then iteration is stopped.\n\n @param[in] user_data The value to pass to each invocation of @p\n callback. Allows context to be passed into the call back function.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR An error was\n reported by @p callback.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p data is an invalid data\n object, or not of kind @p AMD_COMGR_DATA_KIND_RELOCATABLE or\n AMD_COMGR_DATA_KIND_EXECUTABLE. @p callback is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to iterate the data object as out of resources."]
    pub unsafe fn amd_comgr_iterate_symbols(
        &self,
        data: amd_comgr_data_t,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                symbol: amd_comgr_symbol_t,
                user_data: *mut ::std::os::raw::c_void,
            ) -> amd_comgr_status_t,
        >,
        user_data: *mut ::std::os::raw::c_void,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_iterate_symbols
            .as_ref()
            .expect("Expected function, got error."))(data, callback, user_data)
    }
    #[must_use]
    #[doc = " @brief Query information about a machine code object symbol.\n\n @param[in] symbol The symbol to query.\n\n @param[in] attribute Attribute to query.\n\n @param[out] value Pointer to an application-allocated buffer where to store\n the value of the attribute. If the buffer passed by the application is not\n large enough to hold the value of attribute, the behavior is undefined. The\n type of value returned is specified by @p amd_comgr_symbol_info_t.\n\n @retval ::AMD_COMGR_STATUS_SUCCESS The function has\n been executed successfully.\n\n @retval ::AMD_COMGR_STATUS_ERROR The @p symbol does not have the requested @p\n attribute.\n\n @retval ::AMD_COMGR_STATUS_ERROR_INVALID_ARGUMENT @p symbol is an invalid\n symbol. @p attribute is an invalid value. @p value is NULL.\n\n @retval ::AMD_COMGR_STATUS_ERROR_OUT_OF_RESOURCES\n Unable to query symbol as out of resources."]
    pub unsafe fn amd_comgr_symbol_get_info(
        &self,
        symbol: amd_comgr_symbol_t,
        attribute: amd_comgr_symbol_info_t,
        value: *mut ::std::os::raw::c_void,
    ) -> amd_comgr_status_t {
        (self
            .amd_comgr_symbol_get_info
            .as_ref()
            .expect("Expected function, got error."))(symbol, attribute, value)
    }
}
