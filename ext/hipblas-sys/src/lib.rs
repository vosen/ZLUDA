// Generated automatically by zluda_bindgen
// DO NOT EDIT MANUALLY
#![allow(warnings)]
pub const hipblasVersionMajor: u32 = 2;
pub const hipblaseVersionMinor: u32 = 4;
pub const hipblasVersionMinor: u32 = 4;
pub const hipblasVersionPatch: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
pub type hipFloatComplex = float2;
pub type hipDoubleComplex = double2;
pub type hipComplex = hipFloatComplex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
impl hipDataType {
    pub const HIP_R_32F: hipDataType = hipDataType(0);
}
impl hipDataType {
    pub const HIP_R_64F: hipDataType = hipDataType(1);
}
impl hipDataType {
    pub const HIP_R_16F: hipDataType = hipDataType(2);
}
impl hipDataType {
    pub const HIP_R_8I: hipDataType = hipDataType(3);
}
impl hipDataType {
    pub const HIP_C_32F: hipDataType = hipDataType(4);
}
impl hipDataType {
    pub const HIP_C_64F: hipDataType = hipDataType(5);
}
impl hipDataType {
    pub const HIP_C_16F: hipDataType = hipDataType(6);
}
impl hipDataType {
    pub const HIP_C_8I: hipDataType = hipDataType(7);
}
impl hipDataType {
    pub const HIP_R_8U: hipDataType = hipDataType(8);
}
impl hipDataType {
    pub const HIP_C_8U: hipDataType = hipDataType(9);
}
impl hipDataType {
    pub const HIP_R_32I: hipDataType = hipDataType(10);
}
impl hipDataType {
    pub const HIP_C_32I: hipDataType = hipDataType(11);
}
impl hipDataType {
    pub const HIP_R_32U: hipDataType = hipDataType(12);
}
impl hipDataType {
    pub const HIP_C_32U: hipDataType = hipDataType(13);
}
impl hipDataType {
    pub const HIP_R_16BF: hipDataType = hipDataType(14);
}
impl hipDataType {
    pub const HIP_C_16BF: hipDataType = hipDataType(15);
}
impl hipDataType {
    pub const HIP_R_4I: hipDataType = hipDataType(16);
}
impl hipDataType {
    pub const HIP_C_4I: hipDataType = hipDataType(17);
}
impl hipDataType {
    pub const HIP_R_4U: hipDataType = hipDataType(18);
}
impl hipDataType {
    pub const HIP_C_4U: hipDataType = hipDataType(19);
}
impl hipDataType {
    pub const HIP_R_16I: hipDataType = hipDataType(20);
}
impl hipDataType {
    pub const HIP_C_16I: hipDataType = hipDataType(21);
}
impl hipDataType {
    pub const HIP_R_16U: hipDataType = hipDataType(22);
}
impl hipDataType {
    pub const HIP_C_16U: hipDataType = hipDataType(23);
}
impl hipDataType {
    pub const HIP_R_64I: hipDataType = hipDataType(24);
}
impl hipDataType {
    pub const HIP_C_64I: hipDataType = hipDataType(25);
}
impl hipDataType {
    pub const HIP_R_64U: hipDataType = hipDataType(26);
}
impl hipDataType {
    pub const HIP_C_64U: hipDataType = hipDataType(27);
}
impl hipDataType {
    pub const HIP_R_8F_E4M3: hipDataType = hipDataType(28);
}
impl hipDataType {
    pub const HIP_R_8F_E5M2: hipDataType = hipDataType(29);
}
impl hipDataType {
    pub const HIP_R_8F_E4M3_FNUZ: hipDataType = hipDataType(1000);
}
impl hipDataType {
    pub const HIP_R_8F_E5M2_FNUZ: hipDataType = hipDataType(1001);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipDataType(pub ::core::ffi::c_uint);
impl hipblasOperation_t {
    ///<  Operate with the matrix.
    pub const HIPBLAS_OP_N: hipblasOperation_t = hipblasOperation_t(111);
}
impl hipblasOperation_t {
    ///<  Operate with the transpose of the matrix.
    pub const HIPBLAS_OP_T: hipblasOperation_t = hipblasOperation_t(112);
}
impl hipblasOperation_t {
    ///< Operate with the conjugate transpose of the matrix.
    pub const HIPBLAS_OP_C: hipblasOperation_t = hipblasOperation_t(113);
}
#[repr(transparent)]
/// \brief Used to specify whether the matrix is to be transposed or not.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasOperation_t(pub ::core::ffi::c_uint);
impl hipblasComputeType_t {
    ///< compute will be at least 16-bit precision
    pub const HIPBLAS_COMPUTE_16F: hipblasComputeType_t = hipblasComputeType_t(0);
}
impl hipblasComputeType_t {
    ///< compute will be exactly 16-bit precision
    pub const HIPBLAS_COMPUTE_16F_PEDANTIC: hipblasComputeType_t = hipblasComputeType_t(
        1,
    );
}
impl hipblasComputeType_t {
    ///< compute will be at least 32-bit precision
    pub const HIPBLAS_COMPUTE_32F: hipblasComputeType_t = hipblasComputeType_t(2);
}
impl hipblasComputeType_t {
    ///< compute will be exactly 32-bit precision
    pub const HIPBLAS_COMPUTE_32F_PEDANTIC: hipblasComputeType_t = hipblasComputeType_t(
        3,
    );
}
impl hipblasComputeType_t {
    ///< 32-bit input can use 16-bit compute
    pub const HIPBLAS_COMPUTE_32F_FAST_16F: hipblasComputeType_t = hipblasComputeType_t(
        4,
    );
}
impl hipblasComputeType_t {
    ///< 32-bit input can is bf16 compute
    pub const HIPBLAS_COMPUTE_32F_FAST_16BF: hipblasComputeType_t = hipblasComputeType_t(
        5,
    );
}
impl hipblasComputeType_t {
    pub const HIPBLAS_COMPUTE_32F_FAST_TF32: hipblasComputeType_t = hipblasComputeType_t(
        6,
    );
}
impl hipblasComputeType_t {
    ///< compute will be at least 64-bit precision
    pub const HIPBLAS_COMPUTE_64F: hipblasComputeType_t = hipblasComputeType_t(7);
}
impl hipblasComputeType_t {
    ///< compute will be exactly 64-bit precision
    pub const HIPBLAS_COMPUTE_64F_PEDANTIC: hipblasComputeType_t = hipblasComputeType_t(
        8,
    );
}
impl hipblasComputeType_t {
    ///< compute will be at least 32-bit integer precision
    pub const HIPBLAS_COMPUTE_32I: hipblasComputeType_t = hipblasComputeType_t(9);
}
impl hipblasComputeType_t {
    ///< compute will be exactly 32-bit integer precision
    pub const HIPBLAS_COMPUTE_32I_PEDANTIC: hipblasComputeType_t = hipblasComputeType_t(
        10,
    );
}
#[repr(transparent)]
/** \brief The compute type to be used. Currently only used with GemmEx with the HIPBLAS_V2 interface.
         Note that support for compute types is largely dependent on backend.*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasComputeType_t(pub ::core::ffi::c_uint);
/// \brief hipblasHanlde_t is a void pointer, to store the library context (either rocBLAS or cuBLAS)
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasHandle_t(pub *mut ::core::ffi::c_void);
pub type hipblasHalf = u16;
/// \brief  To specify the datatype to be signed char
pub type hipblasInt8 = i8;
/// \brief  Stride between matrices or vectors in strided_batched functions.
pub type hipblasStride = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasBfloat16 {
    pub data: u16,
}
/// \brief Struct to represent a complex number with single precision real and imaginary parts.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct hipblasComplex {
    pub x: f32,
    pub y: f32,
}
/// \brief Struct to represent a complex number with double precision real and imaginary parts.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct hipblasDoubleComplex {
    pub x: f64,
    pub y: f64,
}
impl hipblasPointerMode_t {
    ///< Scalar values affected by this variable will be located on the host.
    pub const HIPBLAS_POINTER_MODE_HOST: hipblasPointerMode_t = hipblasPointerMode_t(0);
}
impl hipblasPointerMode_t {
    ///<  Scalar values affected by this variable will be located on the device.
    pub const HIPBLAS_POINTER_MODE_DEVICE: hipblasPointerMode_t = hipblasPointerMode_t(
        1,
    );
}
#[repr(transparent)]
/// \brief Indicates if scalar pointers are on host or device. This is used for scalars alpha and beta and for scalar function return values.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasPointerMode_t(pub ::core::ffi::c_uint);
impl hipblasFillMode_t {
    ///<  Upper triangle
    pub const HIPBLAS_FILL_MODE_UPPER: hipblasFillMode_t = hipblasFillMode_t(121);
}
impl hipblasFillMode_t {
    ///<  Lower triangle
    pub const HIPBLAS_FILL_MODE_LOWER: hipblasFillMode_t = hipblasFillMode_t(122);
}
impl hipblasFillMode_t {
    pub const HIPBLAS_FILL_MODE_FULL: hipblasFillMode_t = hipblasFillMode_t(123);
}
#[repr(transparent)]
/// \brief Used by the Hermitian, symmetric and triangular matrix routines to specify whether the upper or lower triangle is being referenced.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasFillMode_t(pub ::core::ffi::c_uint);
impl hipblasDiagType_t {
    ///<  Non-unit triangular.
    pub const HIPBLAS_DIAG_NON_UNIT: hipblasDiagType_t = hipblasDiagType_t(131);
}
impl hipblasDiagType_t {
    ///<  Unit triangular.
    pub const HIPBLAS_DIAG_UNIT: hipblasDiagType_t = hipblasDiagType_t(132);
}
#[repr(transparent)]
/// \brief It is used by the triangular matrix routines to specify whether the matrix is unit triangular.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasDiagType_t(pub ::core::ffi::c_uint);
impl hipblasSideMode_t {
    pub const HIPBLAS_SIDE_LEFT: hipblasSideMode_t = hipblasSideMode_t(141);
}
impl hipblasSideMode_t {
    pub const HIPBLAS_SIDE_RIGHT: hipblasSideMode_t = hipblasSideMode_t(142);
}
impl hipblasSideMode_t {
    pub const HIPBLAS_SIDE_BOTH: hipblasSideMode_t = hipblasSideMode_t(143);
}
#[repr(transparent)]
/// \brief Indicates the side matrix A is located relative to matrix B during multiplication.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasSideMode_t(pub ::core::ffi::c_uint);
impl hipblasMath_t {
    pub const HIPBLAS_DEFAULT_MATH: hipblasMath_t = hipblasMath_t(0);
}
impl hipblasMath_t {
    pub const HIPBLAS_XF32_XDL_MATH: hipblasMath_t = hipblasMath_t(1);
}
impl hipblasMath_t {
    pub const HIPBLAS_PEDANTIC_MATH: hipblasMath_t = hipblasMath_t(2);
}
impl hipblasMath_t {
    pub const HIPBLAS_TF32_TENSOR_OP_MATH: hipblasMath_t = hipblasMath_t(3);
}
impl hipblasMath_t {
    pub const HIPBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION: hipblasMath_t = hipblasMath_t(
        4,
    );
}
impl hipblasMath_t {
    pub const HIPBLAS_TENSOR_OP_MATH: hipblasMath_t = hipblasMath_t(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasMath_t(pub ::core::ffi::c_uint);
impl hipblasDatatype_t {
    ///< 16 bit floating point, real
    pub const HIPBLAS_R_16F: hipblasDatatype_t = hipblasDatatype_t(150);
}
impl hipblasDatatype_t {
    ///< 32 bit floating point, real
    pub const HIPBLAS_R_32F: hipblasDatatype_t = hipblasDatatype_t(151);
}
impl hipblasDatatype_t {
    ///< 64 bit floating point, real
    pub const HIPBLAS_R_64F: hipblasDatatype_t = hipblasDatatype_t(152);
}
impl hipblasDatatype_t {
    ///< 16 bit floating point, complex
    pub const HIPBLAS_C_16F: hipblasDatatype_t = hipblasDatatype_t(153);
}
impl hipblasDatatype_t {
    ///< 32 bit floating point, complex
    pub const HIPBLAS_C_32F: hipblasDatatype_t = hipblasDatatype_t(154);
}
impl hipblasDatatype_t {
    ///< 64 bit floating point, complex
    pub const HIPBLAS_C_64F: hipblasDatatype_t = hipblasDatatype_t(155);
}
impl hipblasDatatype_t {
    ///<  8 bit signed integer, real
    pub const HIPBLAS_R_8I: hipblasDatatype_t = hipblasDatatype_t(160);
}
impl hipblasDatatype_t {
    ///<  8 bit unsigned integer, real
    pub const HIPBLAS_R_8U: hipblasDatatype_t = hipblasDatatype_t(161);
}
impl hipblasDatatype_t {
    ///< 32 bit signed integer, real
    pub const HIPBLAS_R_32I: hipblasDatatype_t = hipblasDatatype_t(162);
}
impl hipblasDatatype_t {
    ///< 32 bit unsigned integer, real
    pub const HIPBLAS_R_32U: hipblasDatatype_t = hipblasDatatype_t(163);
}
impl hipblasDatatype_t {
    ///<  8 bit signed integer, complex
    pub const HIPBLAS_C_8I: hipblasDatatype_t = hipblasDatatype_t(164);
}
impl hipblasDatatype_t {
    ///<  8 bit unsigned integer, complex
    pub const HIPBLAS_C_8U: hipblasDatatype_t = hipblasDatatype_t(165);
}
impl hipblasDatatype_t {
    ///< 32 bit signed integer, complex
    pub const HIPBLAS_C_32I: hipblasDatatype_t = hipblasDatatype_t(166);
}
impl hipblasDatatype_t {
    ///< 32 bit unsigned integer, complex
    pub const HIPBLAS_C_32U: hipblasDatatype_t = hipblasDatatype_t(167);
}
impl hipblasDatatype_t {
    ///< 16 bit bfloat, real
    pub const HIPBLAS_R_16B: hipblasDatatype_t = hipblasDatatype_t(168);
}
impl hipblasDatatype_t {
    ///< 16 bit bfloat, complex
    pub const HIPBLAS_C_16B: hipblasDatatype_t = hipblasDatatype_t(169);
}
impl hipblasDatatype_t {
    ///< Invalid datatype value, do not use
    pub const HIPBLAS_DATATYPE_INVALID: hipblasDatatype_t = hipblasDatatype_t(255);
}
#[repr(transparent)]
/** \brief Indicates the precision of data used. hipblasDatatype_t is deprecated as of hipBLAS 2.0.0 and will
be removed in a future release as generally replaced by hipDataType.*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasDatatype_t(pub ::core::ffi::c_uint);
impl hipblasGemmAlgo_t {
    ///<  enumerator rocblas_gemm_algo_standard
    pub const HIPBLAS_GEMM_DEFAULT: hipblasGemmAlgo_t = hipblasGemmAlgo_t(160);
}
#[repr(transparent)]
/// \brief Indicates if layer is active with bitmask.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasGemmAlgo_t(pub ::core::ffi::c_uint);
impl hipblasAtomicsMode_t {
    ///<  Algorithms will refrain from atomics where applicable.
    pub const HIPBLAS_ATOMICS_NOT_ALLOWED: hipblasAtomicsMode_t = hipblasAtomicsMode_t(
        0,
    );
}
impl hipblasAtomicsMode_t {
    ///< Algorithms will take advantage of atomics where applicable.
    pub const HIPBLAS_ATOMICS_ALLOWED: hipblasAtomicsMode_t = hipblasAtomicsMode_t(1);
}
#[repr(transparent)]
/** \brief Indicates if atomics operations are allowed. Not allowing atomic operations may generally improve determinism and repeatability of results at a cost of performance.
         By default, the rocBLAS backend will allow atomic operations while the cuBLAS backend will disallow atomic operations. See backend documentation
         for more detail.*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasAtomicsMode_t(pub ::core::ffi::c_uint);
impl hipblasGemmFlags_t {
    ///< Default empty flags
    pub const HIPBLAS_GEMM_FLAGS_NONE: hipblasGemmFlags_t = hipblasGemmFlags_t(0);
}
impl hipblasGemmFlags_t {
    pub const HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY: hipblasGemmFlags_t = hipblasGemmFlags_t(
        2,
    );
}
impl hipblasGemmFlags_t {
    ///< enumerator rocblas_gemm_flags_fp16_alt_impl
    pub const HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL: hipblasGemmFlags_t = hipblasGemmFlags_t(
        4,
    );
}
impl hipblasGemmFlags_t {
    pub const HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX: hipblasGemmFlags_t = hipblasGemmFlags_t(
        8,
    );
}
impl hipblasGemmFlags_t {
    pub const HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ: hipblasGemmFlags_t = hipblasGemmFlags_t(
        16,
    );
}
#[repr(transparent)]
/** \brief Control flags passed into gemm ex with flags algorithms. Only relevant with rocBLAS backend. See rocBLAS documentation
         for more information.*/
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct hipblasGemmFlags_t(pub ::core::ffi::c_uint);
extern "C" {
    /// \brief Create hipblas handle.
    pub fn hipblasCreate(handle: *mut hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Destroys the library context created using hipblasCreate()
    pub fn hipblasDestroy(handle: hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Set stream for handle
    pub fn hipblasSetStream(
        handle: hipblasHandle_t,
        streamId: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Get stream[0] for handle
    pub fn hipblasGetStream(
        handle: hipblasHandle_t,
        streamId: *mut hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Set hipblas pointer mode
    pub fn hipblasSetPointerMode(
        handle: hipblasHandle_t,
        mode: hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Get hipblas pointer mode
    pub fn hipblasGetPointerMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Set hipblas math mode
    pub fn hipblasSetMathMode(
        handle: hipblasHandle_t,
        mode: hipblasMath_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Get hipblas math mode
    pub fn hipblasGetMathMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasMath_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief copy vector from host to device
@param[in]
n           [int]
number of elements in the vector
@param[in]
elemSize    [int]
Size of both vectors in bytes
@param[in]
x           pointer to vector on the host
@param[in]
incx        [int]
specifies the increment for the elements of the vector
@param[out]
y           pointer to vector on the device
@param[in]
incy        [int]
specifies the increment for the elements of the vector*/
    pub fn hipblasSetVector(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief copy vector from device to host
@param[in]
n           [int]
number of elements in the vector
@param[in]
elemSize    [int]
Size of both vectors in bytes
@param[in]
x           pointer to vector on the device
@param[in]
incx        [int]
specifies the increment for the elements of the vector
@param[out]
y           pointer to vector on the host
@param[in]
incy        [int]
specifies the increment for the elements of the vector*/
    pub fn hipblasGetVector(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief copy matrix from host to device
@param[in]
rows        [int]
number of rows in matrices
@param[in]
cols        [int]
number of columns in matrices
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
AP          pointer to matrix on the host
@param[in]
lda         [int]
specifies the leading dimension of A, lda >= rows
@param[out]
BP           pointer to matrix on the GPU
@param[in]
ldb         [int]
specifies the leading dimension of B, ldb >= rows*/
    pub fn hipblasSetMatrix(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief copy matrix from device to host
@param[in]
rows        [int]
number of rows in matrices
@param[in]
cols        [int]
number of columns in matrices
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
AP          pointer to matrix on the GPU
@param[in]
lda         [int]
specifies the leading dimension of A, lda >= rows
@param[out]
BP          pointer to matrix on the host
@param[in]
ldb         [int]
specifies the leading dimension of B, ldb >= rows*/
    pub fn hipblasGetMatrix(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief asynchronously copy vector from host to device
\details
hipblasSetVectorAsync copies a vector from pinned host memory to device memory asynchronously.
Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.
@param[in]
n           [int]
number of elements in the vector
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
x           pointer to vector on the host
@param[in]
incx        [int]
specifies the increment for the elements of the vector
@param[out]
y           pointer to vector on the device
@param[in]
incy        [int]
specifies the increment for the elements of the vector
@param[in]
stream      specifies the stream into which this transfer request is queued*/
    pub fn hipblasSetVectorAsync(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief asynchronously copy vector from device to host
\details
hipblasGetVectorAsync copies a vector from pinned host memory to device memory asynchronously.
Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.
@param[in]
n           [int]
number of elements in the vector
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
x           pointer to vector on the device
@param[in]
incx        [int]
specifies the increment for the elements of the vector
@param[out]
y           pointer to vector on the host
@param[in]
incy        [int]
specifies the increment for the elements of the vector
@param[in]
stream      specifies the stream into which this transfer request is queued*/
    pub fn hipblasGetVectorAsync(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief asynchronously copy matrix from host to device
\details
hipblasSetMatrixAsync copies a matrix from pinned host memory to device memory asynchronously.
Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.
@param[in]
rows        [int]
number of rows in matrices
@param[in]
cols        [int]
number of columns in matrices
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
AP           pointer to matrix on the host
@param[in]
lda         [int]
specifies the leading dimension of A, lda >= rows
@param[out]
BP           pointer to matrix on the GPU
@param[in]
ldb         [int]
specifies the leading dimension of B, ldb >= rows
@param[in]
stream      specifies the stream into which this transfer request is queued*/
    pub fn hipblasSetMatrixAsync(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief asynchronously copy matrix from device to host
\details
hipblasGetMatrixAsync copies a matrix from device memory to pinned host memory asynchronously.
Memory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.
@param[in]
rows        [int]
number of rows in matrices
@param[in]
cols        [int]
number of columns in matrices
@param[in]
elemSize   [int]
number of bytes per element in the matrix
@param[in]
AP          pointer to matrix on the GPU
@param[in]
lda         [int]
specifies the leading dimension of A, lda >= rows
@param[out]
BP           pointer to matrix on the host
@param[in]
ldb         [int]
specifies the leading dimension of B, ldb >= rows
@param[in]
stream      specifies the stream into which this transfer request is queued*/
    pub fn hipblasGetMatrixAsync(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Set hipblasSetAtomicsMode
    pub fn hipblasSetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /// \brief Get hipblasSetAtomicsMode
    pub fn hipblasGetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: *mut hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
amax finds the first index of the element of maximum magnitude of a vector x.

- Supported precisions in rocBLAS : s,d,c,z.
- Supported precisions in cuBLAS  : s,d,c,z.

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the amax index.
return is 0.0 if n, incx<=0.
*/
    pub fn hipblasIsamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamax_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
amaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z.
- Supported precisions in cuBLAS  : No support.

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
batchCount [int]
number of instances in the batch, must be > 0.
@param[out]
result
device or host array of pointers of batchCount size for results.
return is 0 if n, incx<=0.
*/
    pub fn hipblasIsamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
amaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
stridex   [hipblasStride]
specifies the pointer increment between one x_i and the next x_(i + 1).
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device or host pointer for storing contiguous batchCount results.
return is 0 if n <= 0, incx<=0.
*/
    pub fn hipblasIsamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamaxStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
amin finds the first index of the element of minimum magnitude of a vector x.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the amin index.
return is 0.0 if n, incx<=0.
*/
    pub fn hipblasIsamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsamin_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
aminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
batchCount [int]
number of instances in the batch, must be > 0.
@param[out]
result
device or host pointers to array of batchCount size for results.
return is 0 if n, incx<=0.
*/
    pub fn hipblasIsaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
aminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
stridex   [hipblasStride]
specifies the pointer increment between one x_i and the next x_(i + 1)
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device or host pointer to array for storing contiguous batchCount results.
return is 0 if n <= 0, incx<=0.
*/
    pub fn hipblasIsaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIsaminStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
asum computes the sum of the magnitudes of elements of a real vector x,
or the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x. incx must be > 0.
@param[inout]
result
device pointer or host pointer to store the asum product.
return is 0.0 if n <= 0.
*/
    pub fn hipblasSasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasum_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
asumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,
or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
vector, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
batchCount [int]
number of instances in the batch.
@param[out]
result
device array or host array of batchCount size for results.
return is 0.0 if n, incx<=0.
*/
    pub fn hipblasSasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
asumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,
or the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex
vector, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each vector x_i
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device pointer or host pointer to array for storing contiguous batchCount results.
return is 0.0 if n, incx<=0.
*/
    pub fn hipblasSasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSasumStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
axpy   computes constant alpha multiplied by vector x, plus vector y

y := alpha * x + y

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
alpha     device pointer or host pointer to specify the scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[out]
y         device pointer storing vector y.
@param[inout]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasHaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *mut hipblasHalf,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpy_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: i64,
        y: *mut hipblasHalf,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
axpyBatched   compute y := alpha * x + y over a set of batched vectors.

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
alpha     specifies the scalar alpha.
@param[in]
x         pointer storing vector x on the GPU.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[out]
y         pointer storing vector y on the GPU.
@param[inout]
incy      [int]
specifies the increment for the elements of y.

@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasHaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasHalf,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: i64,
        y: *const *mut hipblasHalf,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
axpyStridedBatched   compute y := alpha * x + y over a set of strided batched vectors.

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
@param[in]
alpha     specifies the scalar alpha.
@param[in]
x         pointer storing vector x on the GPU.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
stridex   [hipblasStride]
specifies the increment between vectors of x.
@param[out]
y         pointer storing vector y on the GPU.
@param[inout]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey   [hipblasStride]
specifies the increment between vectors of y.

@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasHaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasHalf,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHaxpyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasHalf,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
copy  copies each element x[i] into y[i], for  i = 1 , ... , n

y := x,

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x to be copied to y.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[out]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasScopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopy_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
copyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount

y_i := x_i,

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i to be copied to y_i.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i.
@param[out]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasScopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
copyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount

y_i := x_i,

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i to be copied to y_i.
@param[in]
x         device pointer to the first vector (x_1) in the batch.
@param[in]
incx      [int]
specifies the increments for the elements of vectors x_i.
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[out]
y         device pointer to the first vector (y_1) in the batch.
@param[in]
incy      [int]
specifies the increment for the elements of vectors y_i.
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stride_y, however the user should
take care to ensure that stride_y is of appropriate size, for a typical
case this means stride_y >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasScopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScopyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
dot(u)  performs the dot product of vectors x and y

result = x * y;

dotc  performs the dot product of the conjugate of complex vector x and complex vector y

result = conjugate (x) * y;

- Supported precisions in rocBLAS : h,bf,s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the dot product.
return is 0.0 if n <= 0.
*/
    pub fn hipblasHdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const hipblasHalf,
        incy: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        y: *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasHalf,
        incx: i64,
        y: *const hipblasHalf,
        incy: i64,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasBfloat16,
        incx: i64,
        y: *const hipblasBfloat16,
        incy: i64,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
dotBatched(u) performs a batch of dot products of vectors x and y

result_i = x_i * y_i;

dotcBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

result_i = conjugate (x_i) * y_i;

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors, for i = 1, ..., batchCount

- Supported precisions in rocBLAS : h,bf,s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
batchCount [int]
number of instances in the batch
@param[inout]
result
device array or host array of batchCount size to store the dot products of each batch.
return 0.0 for each element if n <= 0.
*/
    pub fn hipblasHdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasHalf,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasHalf,
        incx: i64,
        y: *const *const hipblasHalf,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasBfloat16,
        incx: i64,
        y: *const *const hipblasBfloat16,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        batchCount: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
dotStridedBatched(u)  performs a batch of dot products of vectors x and y

result_i = x_i * y_i;

dotcStridedBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y

result_i = conjugate (x_i) * y_i;

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors, for i = 1, ..., batchCount

- Supported precisions in rocBLAS : h,bf,s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
x         device pointer to the first vector (x_1) in the batch.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1)
@param[in]
y         device pointer to the first vector (y_1) in the batch.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1)
@param[in]
batchCount [int]
number of instances in the batch
@param[inout]
result
device array or host array of batchCount size to store the dot products of each batch.
return 0.0 for each element if n <= 0.
*/
    pub fn hipblasHdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasHalf,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHdotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasHalf,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasHalf,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasBfloat16,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasBfloat16,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *const f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *const f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
nrm2 computes the euclidean norm of a real or complex vector

result := sqrt( x'*x ) for real vectors
result := sqrt( x**H*x ) for complex vectors

- Supported precisions in rocBLAS : s,d,c,z,sc,dz
- Supported precisions in cuBLAS  : s,d,sc,dz

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the nrm2 product.
return is 0.0 if n, incx<=0.
*/
    pub fn hipblasSnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
nrm2Batched computes the euclidean norm over a batch of real or complex vectors

result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount

- Supported precisions in rocBLAS : s,d,c,z,sc,dz
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each x_i.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device pointer or host pointer to array of batchCount size for nrm2 results.
return is 0.0 for each element if n <= 0, incx<=0.
*/
    pub fn hipblasSnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2Batched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f32,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const f64,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
nrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors

:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount

- Supported precisions in rocBLAS : s,d,c,z,sc,dz
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each x_i.
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device pointer or host pointer to array for storing contiguous batchCount results.
return is 0.0 for each element if n <= 0, incx<=0.
*/
    pub fn hipblasSnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSnrm2StridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

- Supported precisions in rocBLAS : s,d,c,z,sc,dz
- Supported precisions in cuBLAS  : s,d,c,z,cs,zd

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in the x and y vectors.
@param[inout]
x       device pointer storing vector x.
@param[in]
incx    [int]
specifies the increment between elements of x.
@param[inout]
y       device pointer storing vector y.
@param[in]
incy    [int]
specifies the increment between elements of y.
@param[in]
c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer storing scalar sine component of the rotation matrix.
*/
    pub fn hipblasSrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        y: *mut hipblasComplex,
        incy: i64,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        y: *mut hipblasComplex,
        incy: i64,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        y: *mut hipComplex,
        incy: i64,
        c: *const f32,
        s: *const hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        y: *mut hipComplex,
        incy: i64,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        y: *mut hipDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        y: *mut hipDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

- Supported precisions in rocBLAS : s,d,sc,dz
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in each x_i and y_i vectors.
@param[inout]
x       device array of device pointers storing each vector x_i.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[inout]
y       device array of device pointers storing each vector y_i.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
c       device pointer or host pointer to scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer to scalar sine component of the rotation matrix.
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
*/
    pub fn hipblasSrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        y: *const *mut hipblasComplex,
        incy: i64,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        y: *const *mut hipblasComplex,
        incy: i64,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipComplex,
        incx: i64,
        y: *const *mut hipComplex,
        incy: i64,
        c: *const f32,
        s: *const hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipComplex,
        incx: i64,
        y: *const *mut hipComplex,
        incy: i64,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

- Supported precisions in rocBLAS : s,d,sc,dz
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in each x_i and y_i vectors.
@param[inout]
x       device pointer to the first vector x_1.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[in]
stridex [hipblasStride]
specifies the increment from the beginning of x_i to the beginning of x_(i+1)
@param[inout]
y       device pointer to the first vector y_1.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
stridey  [hipblasStride]
specifies the increment from the beginning of y_i to the beginning of y_(i+1)
@param[in]
c       device pointer or host pointer to scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer to scalar sine component of the rotation matrix.
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
*/
    pub fn hipblasSrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotg creates the Givens rotation matrix for the vector (a b).
Scalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
a       device pointer or host pointer to input vector element, overwritten with r.
@param[inout]
b       device pointer or host pointer to input vector element, overwritten with z.
@param[inout]
c       device pointer or host pointer to cosine element of Givens rotation.
@param[inout]
s       device pointer or host pointer sine element of Givens rotation.
*/
    pub fn hipblasSrotg(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        b: *mut hipComplex,
        c: *mut f32,
        s: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        b: *mut hipDoubleComplex,
        c: *mut f64,
        s: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotg_64(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg_64(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg_64(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg_64(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg_v2_64(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        b: *mut hipComplex,
        c: *mut f32,
        s: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg_v2_64(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        b: *mut hipDoubleComplex,
        c: *mut f64,
        s: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.
a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
a       device array of device pointers storing each single input vector element a_i, overwritten with r_i.
@param[inout]
b       device array of device pointers storing each single input vector element b_i, overwritten with z_i.
@param[inout]
c       device array of device pointers storing each cosine element of Givens rotation for the batch.
@param[inout]
s       device array of device pointers storing each sine element of Givens rotation for the batch.
@param[in]
batchCount [int]
number of batches (length of arrays a, b, c, and s).
*/
    pub fn hipblasSrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipComplex,
        b: *const *mut hipComplex,
        c: *const *mut f32,
        s: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipDoubleComplex,
        b: *const *mut hipDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgBatched_64(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched_64(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched_64(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched_64(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched_v2_64(
        handle: hipblasHandle_t,
        a: *const *mut hipComplex,
        b: *const *mut hipComplex,
        c: *const *mut f32,
        s: *const *mut hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched_v2_64(
        handle: hipblasHandle_t,
        a: *const *mut hipDoubleComplex,
        b: *const *mut hipDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.
a, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
a       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.
@param[in]
stridea [hipblasStride]
distance between elements of a in batch (distance between a_i and a_(i + 1))
@param[inout]
b       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.
@param[in]
strideb [hipblasStride]
distance between elements of b in batch (distance between b_i and b_(i + 1))
@param[inout]
c       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.
@param[in]
stridec [hipblasStride]
distance between elements of c in batch (distance between c_i and c_(i + 1))
@param[inout]
s       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.
@param[in]
strides [hipblasStride]
distance between elements of s in batch (distance between s_i and s_(i + 1))
@param[in]
batchCount [int]
number of batches (length of arrays a, b, c, and s).
*/
    pub fn hipblasSrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f32,
        stridea: hipblasStride,
        b: *mut f32,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut f32,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f64,
        stridea: hipblasStride,
        b: *mut f64,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut f64,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stridea: hipblasStride,
        b: *mut hipblasComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipblasComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipblasDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipblasDoubleComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        stridea: hipblasStride,
        b: *mut hipComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipDoubleComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotgStridedBatched_64(
        handle: hipblasHandle_t,
        a: *mut f32,
        stridea: hipblasStride,
        b: *mut f32,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut f32,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched_64(
        handle: hipblasHandle_t,
        a: *mut f64,
        stridea: hipblasStride,
        b: *mut f64,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut f64,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched_64(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stridea: hipblasStride,
        b: *mut hipblasComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipblasComplex,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched_64(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipblasDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipblasDoubleComplex,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched_v2_64(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        stridea: hipblasStride,
        b: *mut hipComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipComplex,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched_v2_64(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipDoubleComplex,
        strides: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotm applies the modified Givens rotation matrix defined by param to vectors x and y.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : s,d

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in the x and y vectors.
@param[inout]
x       device pointer storing vector x.
@param[in]
incx    [int]
specifies the increment between elements of x.
@param[inout]
y       device pointer storing vector y.
@param[in]
incy    [int]
specifies the increment between elements of y.
@param[in]
param   device vector or host vector of 5 elements defining the rotation.
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
*/
    pub fn hipblasSrotm(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotm_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in the x and y vectors.
@param[inout]
x       device array of device pointers storing each vector x_i.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[inout]
y       device array of device pointers storing each vector y_1.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
param   device array of device vectors of 5 elements defining the rotation.
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may ONLY be stored on the device for the batched version of this function.
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
*/
    pub fn hipblasSrotmBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        param: *const *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        param: *const *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        param: *const *const f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        param: *const *const f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in the x and y vectors.
@param[inout]
x       device pointer pointing to first strided batched vector x_1.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[in]
stridex [hipblasStride]
specifies the increment between the beginning of x_i and x_(i + 1)
@param[inout]
y       device pointer pointing to first strided batched vector y_1.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
stridey  [hipblasStride]
specifies the increment between the beginning of y_i and y_(i + 1)
@param[in]
param   device pointer pointing to first array of 5 elements defining the rotation (param_1).
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may ONLY be stored on the device for the strided_batched version of this function.
@param[in]
strideParam [hipblasStride]
specifies the increment between the beginning of param_i and param_(i + 1)
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
*/
    pub fn hipblasSrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        param: *const f32,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        param: *const f64,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        param: *const f32,
        strideParam: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        param: *const f64,
        strideParam: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).
Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : s,d

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
d1      device pointer or host pointer to input scalar that is overwritten.
@param[inout]
d2      device pointer or host pointer to input scalar that is overwritten.
@param[inout]
x1      device pointer or host pointer to input scalar that is overwritten.
@param[in]
y1      device pointer or host pointer to input scalar.
@param[out]
param   device vector or host vector of 5 elements defining the rotation.
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
*/
    pub fn hipblasSrotmg(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmg_64(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg_64(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
d1      device batched array or host batched array of input scalars that is overwritten.
@param[inout]
d2      device batched array or host batched array of input scalars that is overwritten.
@param[inout]
x1      device batched array or host batched array of input scalars that is overwritten.
@param[in]
y1      device batched array or host batched array of input scalars.
@param[out]
param   device batched array or host batched array of vectors of 5 elements defining the rotation.
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
@param[in]
batchCount [int]
the number of instances in the batch.
*/
    pub fn hipblasSrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgBatched_64(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched_64(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
rotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.
Parameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
If the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.
If the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[inout]
d1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
@param[in]
strided1 [hipblasStride]
specifies the increment between the beginning of d1_i and d1_(i+1)
@param[inout]
d2      device strided_batched array or host strided_batched array of input scalars that is overwritten.
@param[in]
strided2 [hipblasStride]
specifies the increment between the beginning of d2_i and d2_(i+1)
@param[inout]
x1      device strided_batched array or host strided_batched array of input scalars that is overwritten.
@param[in]
stridex1 [hipblasStride]
specifies the increment between the beginning of x1_i and x1_(i+1)
@param[in]
y1      device strided_batched array or host strided_batched array of input scalars.
@param[in]
stridey1 [hipblasStride]
specifies the increment between the beginning of y1_i and y1_(i+1)
@param[out]
param   device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.
param[0] = flag
param[1] = H11
param[2] = H21
param[3] = H12
param[4] = H22
The flag parameter defines the form of H:
flag = -1 => H = ( H11 H12 H21 H22 )
flag =  0 => H = ( 1.0 H12 H21 1.0 )
flag =  1 => H = ( H11 1.0 -1.0 H22 )
flag = -2 => H = ( 1.0 0.0 0.0 1.0 )
param may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.
@param[in]
strideParam [hipblasStride]
specifies the increment between the beginning of param_i and param_(i + 1)
@param[in]
batchCount [int]
the number of instances in the batch.
*/
    pub fn hipblasSrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f32,
        strided1: hipblasStride,
        d2: *mut f32,
        strided2: hipblasStride,
        x1: *mut f32,
        stridex1: hipblasStride,
        y1: *const f32,
        stridey1: hipblasStride,
        param: *mut f32,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f64,
        strided1: hipblasStride,
        d2: *mut f64,
        strided2: hipblasStride,
        x1: *mut f64,
        stridex1: hipblasStride,
        y1: *const f64,
        stridey1: hipblasStride,
        param: *mut f64,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSrotmgStridedBatched_64(
        handle: hipblasHandle_t,
        d1: *mut f32,
        strided1: hipblasStride,
        d2: *mut f32,
        strided2: hipblasStride,
        x1: *mut f32,
        stridex1: hipblasStride,
        y1: *const f32,
        stridey1: hipblasStride,
        param: *mut f32,
        strideParam: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched_64(
        handle: hipblasHandle_t,
        d1: *mut f64,
        strided1: hipblasStride,
        d2: *mut f64,
        strided2: hipblasStride,
        x1: *mut f64,
        stridex1: hipblasStride,
        y1: *const f64,
        stridey1: hipblasStride,
        param: *mut f64,
        strideParam: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
scal  scales each element of vector x with scalar alpha.

x := alpha * x

- Supported precisions in rocBLAS : s,d,c,z,cs,zd
- Supported precisions in cuBLAS  : s,d,c,z,cs,zd

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
alpha     device pointer or host pointer for the scalar alpha.
@param[inout]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasSscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API
\details
scalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.

x_i := alpha * x_i

where (x_i) is the i-th instance of the batch.

- Supported precisions in rocBLAS : s,d,c,z,cs,zd
- Supported precisions in cuBLAS  : No support

@param[in]
handle      [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n           [int]
the number of elements in each x_i.
@param[in]
alpha       host pointer or device pointer for the scalar alpha.
@param[inout]
x           device array of device pointers storing each vector x_i.
@param[in]
incx        [int]
specifies the increment for the elements of each x_i.
@param[in]
batchCount [int]
specifies the number of batches in x.
*/
    pub fn hipblasSscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API
\details
scalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.

x_i := alpha * x_i ,

where (x_i) is the i-th instance of the batch.

- Supported precisions in rocBLAS : s,d,c,z,cs,zd
- Supported precisions in cuBLAS  : No support

@param[in]
handle      [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n           [int]
the number of elements in each x_i.
@param[in]
alpha       host pointer or device pointer for the scalar alpha.
@param[inout]
x           device pointer to the first vector (x_1) in the batch.
@param[in]
incx        [int]
specifies the increment for the elements of x.
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[in]
batchCount [int]
specifies the number of batches in x.
*/
    pub fn hipblasSscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
swap  interchanges vectors x and y.

y := x; x := y

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[inout]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasSswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswap_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
swapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount

y_i := x_i; x_i := y_i

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[inout]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f32,
        incx: i64,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut f64,
        incx: i64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipComplex,
        incx: i64,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 1 API

\details
swapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount

y_i := x_i; x_i := y_i

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[inout]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[inout]
y         device pointer to the first vector y_1.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey   [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_y is of appropriate size, for a typical
case this means stride_y >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSswapStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gbmv performs one of the matrix-vector operations

y := alpha*A*x    + beta*y,   or
y := alpha*A**T*x + beta*y,   or
y := alpha*A**H*x + beta*y,

where alpha and beta are scalars, x and y are vectors and A is an
m by n banded matrix with kl sub-diagonals and ku super-diagonals.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
trans     [hipblasOperation_t]
indicates whether matrix A is tranposed (conjugated) or not
@param[in]
m         [int]
number of rows of matrix A
@param[in]
n         [int]
number of columns of matrix A
@param[in]
kl        [int]
number of sub-diagonals of A
@param[in]
ku        [int]
number of super-diagonals of A
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP    device pointer storing banded matrix A.
Leading (kl + ku + 1) by n part of the matrix contains the coefficients
of the banded matrix. The leading diagonal resides in row (ku + 1) with
the first super-diagonal above on the RHS of row ku. The first sub-diagonal
resides below on the LHS of row ku + 2. This propagates up and down across
sub/super-diagonals.
Ex: (m = n = 7; ku = 2, kl = 2)
1 2 3 0 0 0 0             0 0 3 3 3 3 3
4 1 2 3 0 0 0             0 2 2 2 2 2 2
5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
0 5 4 1 2 3 0             4 4 4 4 4 4 0
0 0 5 4 1 2 0             5 5 5 5 5 0 0
0 0 0 5 4 1 2             0 0 0 0 0 0 0
0 0 0 0 5 4 1             0 0 0 0 0 0 0
Note that the empty elements which don't correspond to data will not
be referenced.
@param[in]
lda       [int]
specifies the leading dimension of A. Must be >= (kl + ku + 1)
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasSgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gbmvBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i    + beta*y_i,   or
y_i := alpha*A_i**T*x_i + beta*y_i,   or
y_i := alpha*A_i**H*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
m by n banded matrix with kl sub-diagonals and ku super-diagonals,
for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
trans     [hipblasOperation_t]
indicates whether matrix A is tranposed (conjugated) or not
@param[in]
m         [int]
number of rows of each matrix A_i
@param[in]
n         [int]
number of columns of each matrix A_i
@param[in]
kl        [int]
number of sub-diagonals of each A_i
@param[in]
ku        [int]
number of super-diagonals of each A_i
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP    device array of device pointers storing each banded matrix A_i.
Leading (kl + ku + 1) by n part of the matrix contains the coefficients
of the banded matrix. The leading diagonal resides in row (ku + 1) with
the first super-diagonal above on the RHS of row ku. The first sub-diagonal
resides below on the LHS of row ku + 2. This propagates up and down across
sub/super-diagonals.
Ex: (m = n = 7; ku = 2, kl = 2)
1 2 3 0 0 0 0             0 0 3 3 3 3 3
4 1 2 3 0 0 0             0 2 2 2 2 2 2
5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
0 5 4 1 2 3 0             4 4 4 4 4 4 0
0 0 5 4 1 2 0             5 5 5 5 5 0 0
0 0 0 5 4 1 2             0 0 0 0 0 0 0
0 0 0 0 5 4 1             0 0 0 0 0 0 0
Note that the empty elements which don't correspond to data will not
be referenced.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. Must be >= (kl + ku + 1)
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
batchCount [int]
specifies the number of instances in the batch.
*/
    pub fn hipblasSgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gbmvStridedBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i    + beta*y_i,   or
y_i := alpha*A_i**T*x_i + beta*y_i,   or
y_i := alpha*A_i**H*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
m by n banded matrix with kl sub-diagonals and ku super-diagonals,
for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
trans     [hipblasOperation_t]
indicates whether matrix A is tranposed (conjugated) or not
@param[in]
m         [int]
number of rows of matrix A
@param[in]
n         [int]
number of columns of matrix A
@param[in]
kl        [int]
number of sub-diagonals of A
@param[in]
ku        [int]
number of super-diagonals of A
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP    device pointer to first banded matrix (A_1).
Leading (kl + ku + 1) by n part of the matrix contains the coefficients
of the banded matrix. The leading diagonal resides in row (ku + 1) with
the first super-diagonal above on the RHS of row ku. The first sub-diagonal
resides below on the LHS of row ku + 2. This propagates up and down across
sub/super-diagonals.
Ex: (m = n = 7; ku = 2, kl = 2)
1 2 3 0 0 0 0             0 0 3 3 3 3 3
4 1 2 3 0 0 0             0 2 2 2 2 2 2
5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1
0 5 4 1 2 3 0             4 4 4 4 4 4 0
0 0 5 4 1 2 0             5 5 5 5 5 0 0
0 0 0 5 4 1 2             0 0 0 0 0 0 0
0 0 0 0 5 4 1             0 0 0 0 0 0 0
Note that the empty elements which don't correspond to data will not
be referenced.
@param[in]
lda       [int]
specifies the leading dimension of A. Must be >= (kl + ku + 1)
@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         device pointer to first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1)
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer to first vector (y_1).
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (x_i+1)
@param[in]
batchCount [int]
specifies the number of instances in the batch.
*/
    pub fn hipblasSgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgbmvStridedBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        kl: i64,
        ku: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gemv performs one of the matrix-vector operations

y := alpha*A*x    + beta*y,   or
y := alpha*A**T*x + beta*y,   or
y := alpha*A**H*x + beta*y,

where alpha and beta are scalars, x and y are vectors and A is an
m by n matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
trans     [hipblasOperation_t]
indicates whether matrix A is tranposed (conjugated) or not
@param[in]
m         [int]
number of rows of matrix A
@param[in]
n         [int]
number of columns of matrix A
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasSgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gemvBatched performs a batch of matrix-vector operations

y_i := alpha*A_i*x_i    + beta*y_i,   or
y_i := alpha*A_i**T*x_i + beta*y_i,   or
y_i := alpha*A_i**H*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
m by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle      [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
trans       [hipblasOperation_t]
indicates whether matrices A_i are tranposed (conjugated) or not
@param[in]
m           [int]
number of rows of each matrix A_i
@param[in]
n           [int]
number of columns of each matrix A_i
@param[in]
alpha       device pointer or host pointer to scalar alpha.
@param[in]
AP         device array of device pointers storing each matrix A_i.
@param[in]
lda         [int]
specifies the leading dimension of each matrix A_i.
@param[in]
x           device array of device pointers storing each vector x_i.
@param[in]
incx        [int]
specifies the increment for the elements of each vector x_i.
@param[in]
beta        device pointer or host pointer to scalar beta.
@param[inout]
y           device array of device pointers storing each vector y_i.
@param[in]
incy        [int]
specifies the increment for the elements of each vector y_i.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched_v2_64(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gemvStridedBatched performs a batch of matrix-vector operations

y_i := alpha*A_i*x_i    + beta*y_i,   or
y_i := alpha*A_i**T*x_i + beta*y_i,   or
y_i := alpha*A_i**H*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
m by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle      [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA      [hipblasOperation_t]
indicates whether matrices A_i are tranposed (conjugated) or not
@param[in]
m           [int]
number of rows of matrices A_i
@param[in]
n           [int]
number of columns of matrices A_i
@param[in]
alpha       device pointer or host pointer to scalar alpha.
@param[in]
AP          device pointer to the first matrix (A_1) in the batch.
@param[in]
lda         [int]
specifies the leading dimension of matrices A_i.
@param[in]
strideA     [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x           device pointer to the first vector (x_1) in the batch.
@param[in]
incx        [int]
specifies the increment for the elements of vectors x_i.
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N
this typically means stridex >= n * incx, otherwise stridex >= m * incx.
@param[in]
beta        device pointer or host pointer to scalar beta.
@param[inout]
y           device pointer to the first vector (y_1) in the batch.
@param[in]
incy        [int]
specifies the increment for the elements of vectors y_i.
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N
this typically means stridey >= m * incy, otherwise stridey >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemvStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
ger,geru,gerc performs the matrix-vector operations

A := A + alpha*x*y**T , OR
A := A + alpha*x*y**H for gerc

where alpha is a scalar, x and y are vectors, and A is an
m by n matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
m         [int]
the number of rows of the matrix A.
@param[in]
n         [int]
the number of columns of the matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
*/
    pub fn hipblasSger(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSger_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        AP: *mut f32,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        AP: *mut f64,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations

A := A + alpha*x*y**T , OR
A := A + alpha*x*y**H for gerc

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha is a scalar, x_i and y_i are vectors and A_i is an
m by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
m         [int]
the number of rows of each matrix A_i.
@param[in]
n         [int]
the number of columns of eaceh matrix A_i.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i.
@param[inout]
AP        device array of device pointers storing each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSgerBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        AP: *const *mut f32,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        AP: *const *mut f64,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
gerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*y_i**T, OR
A_i := A_i + alpha*x_i*y_i**H  for gerc

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha is a scalar, x_i and y_i are vectors and A_i is an
m by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
m         [int]
the number of rows of each matrix A_i.
@param[in]
n         [int]
the number of columns of each matrix A_i.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer to the first vector (x_1) in the batch.
@param[in]
incx      [int]
specifies the increments for the elements of each vector x_i.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size, for a typical
case this means stridex >= m * incx.
@param[inout]
y         device pointer to the first vector (y_1) in the batch.
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i.
@param[in]
stridey   [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size, for a typical
case this means stridey >= n * incy.
@param[inout]
AP        device pointer to the first matrix (A_1) in the batch.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA     [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgerStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *const f32,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *const f64,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched_v2_64(
        handle: hipblasHandle_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hbmv performs the matrix-vector operations

y := alpha*A*x + beta*y

where alpha and beta are scalars, x and y are n element vectors and A is an
n by n Hermitian band matrix, with k super-diagonals.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.
@param[in]
n         [int]
the order of the matrix A.
@param[in]
k         [int]
the number of super-diagonals of the matrix A. Must be >= 0.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device pointer storing matrix A. Of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The leading (k + 1) by n part of A must contain the upper
triangular band part of the Hermitian matrix, with the leading
diagonal in row (k + 1), the first super-diagonal on the RHS
of row k, etc.
The top left k by x triangle of A will not be referenced.
Ex (upper, lda = n = 4, k = 1):
A                             Represented matrix
(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

if uplo == HIPBLAS_FILL_MODE_LOWER:
The leading (k + 1) by n part of A must contain the lower
triangular band part of the Hermitian matrix, with the leading
diagonal in row (1), the first sub-diagonal on the LHS of
row 2, etc.
The bottom right k by k triangle of A will not be referenced.
Ex (lower, lda = 2, n = 4, k = 1):
A                               Represented matrix
(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
(0, 0) (6, 8) (3, 0) (7,-7)
(0, 0) (0, 0) (7, 7) (4, 0)

As a Hermitian matrix, the imaginary part of the main diagonal
of A will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of A. must be >= k + 1
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasChbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hbmvBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
k         [int]
the number of super-diagonals of each matrix A_i. Must be >= 0.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device array of device pointers storing each matrix_i A of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The leading (k + 1) by n part of each A_i must contain the upper
triangular band part of the Hermitian matrix, with the leading
diagonal in row (k + 1), the first super-diagonal on the RHS
of row k, etc.
The top left k by x triangle of each A_i will not be referenced.
Ex (upper, lda = n = 4, k = 1):
A                             Represented matrix
(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

if uplo == HIPBLAS_FILL_MODE_LOWER:
The leading (k + 1) by n part of each A_i must contain the lower
triangular band part of the Hermitian matrix, with the leading
diagonal in row (1), the first sub-diagonal on the LHS of
row 2, etc.
The bottom right k by k triangle of each A_i will not be referenced.
Ex (lower, lda = 2, n = 4, k = 1):
A                               Represented matrix
(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
(0, 0) (6, 8) (3, 0) (7,-7)
(0, 0) (0, 0) (7, 7) (4, 0)

As a Hermitian matrix, the imaginary part of the main diagonal
of each A_i will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. must be >= max(1, n)
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hbmvStridedBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
k         [int]
the number of super-diagonals of each matrix A_i. Must be >= 0.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The leading (k + 1) by n part of each A_i must contain the upper
triangular band part of the Hermitian matrix, with the leading
diagonal in row (k + 1), the first super-diagonal on the RHS
of row k, etc.
The top left k by x triangle of each A_i will not be referenced.
Ex (upper, lda = n = 4, k = 1):
A                             Represented matrix
(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)
(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)
(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)

if uplo == HIPBLAS_FILL_MODE_LOWER:
The leading (k + 1) by n part of each A_i must contain the lower
triangular band part of the Hermitian matrix, with the leading
diagonal in row (1), the first sub-diagonal on the LHS of
row 2, etc.
The bottom right k by k triangle of each A_i will not be referenced.
Ex (lower, lda = 2, n = 4, k = 1):
A                               Represented matrix
(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)
(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)
(0, 0) (6, 8) (3, 0) (7,-7)
(0, 0) (0, 0) (7, 7) (4, 0)

As a Hermitian matrix, the imaginary part of the main diagonal
of each A_i will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. must be >= max(1, n)
@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         device array pointing to the first vector y_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1)
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array pointing to the first vector y_1.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1)
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hemv performs one of the matrix-vector operations

y := alpha*A*x + beta*y

where alpha and beta are scalars, x and y are n element vectors and A is an
n by n Hermitian matrix.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
@param[in]
n         [int]
the order of the matrix A.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device pointer storing matrix A. Of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular part of A must contain
the upper triangular part of a Hermitian matrix. The lower
triangular part of A will not be referenced.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular part of A must contain
the lower triangular part of a Hermitian matrix. The upper
triangular part of A will not be referenced.
As a Hermitian matrix, the imaginary part of the main diagonal
of A will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of A. must be >= max(1, n)
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasChemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hemvBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian matrix, for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device array of device pointers storing each matrix A_i of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular part of each A_i must contain
the upper triangular part of a Hermitian matrix. The lower
triangular part of each A_i will not be referenced.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular part of each A_i must contain
the lower triangular part of a Hermitian matrix. The upper
triangular part of each A_i will not be referenced.
As a Hermitian matrix, the imaginary part of the main diagonal
of each A_i will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. must be >= max(1, n)
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hemvStridedBatched performs one of the matrix-vector operations

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian matrix, for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device array of device pointers storing each matrix A_i of dimension (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular part of each A_i must contain
the upper triangular part of a Hermitian matrix. The lower
triangular part of each A_i will not be referenced.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular part of each A_i must contain
the lower triangular part of a Hermitian matrix. The upper
triangular part of each A_i will not be referenced.
As a Hermitian matrix, the imaginary part of the main diagonal
of each A_i will not be referenced and is assumed to be == 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. must be >= max(1, n)
@param[in]
strideA    [hipblasStride]
stride from the start of one (A_i) to the next (A_i+1)

@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
her performs the matrix-vector operations

A := A + alpha*x*x**H

where alpha is a real scalar, x is a vector, and A is an
n by n Hermitian matrix.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
AP        device pointer storing the specified triangular portion of
the Hermitian matrix A. Of size (lda * n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the Hermitian matrix A is supplied. The lower
triangluar portion will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the Hermitian matrix A is supplied. The upper
triangular portion will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of A. Must be at least max(1, n).*/
    pub fn hipblasCher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipComplex,
        incx: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
herBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**H

where alpha is a real scalar, x_i is a vector, and A_i is an
n by n symmetric matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
AP       device array of device pointers storing the specified triangular portion of
each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion
of each A_i will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion
of each A_i will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. Must be at least max(1, n).
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasCherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
herStridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**H

where alpha is a real scalar, x_i is a vector, and A_i is an
n by n Hermitian matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[inout]
AP        device array of device pointers storing the specified triangular portion of
each Hermitian matrix A_i. Points to the first matrix (A_1).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
portion of each A_i will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
portion of each A_i will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA    [hipblasStride]
stride from the start of one (A_i) and the next (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasCherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
her2 performs the matrix-vector operations

A := A + alpha*x*y**H + conj(alpha)*y*x**H

where alpha is a complex scalar, x and y are vectors, and A is an
n by n Hermitian matrix.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
AP         device pointer storing the specified triangular portion of
the Hermitian matrix A. Of size (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the Hermitian matrix A is supplied. The lower triangular
portion of A will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the Hermitian matrix A is supplied. The upper triangular
portion of A will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of A. Must be at least max(lda, 1).*/
    pub fn hipblasCher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
her2Batched performs the matrix-vector operations

A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
n by n Hermitian matrix for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[inout]
AP         device array of device pointers storing the specified triangular portion of
each Hermitian matrix A_i of size (lda, n).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
portion of each A_i will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
portion of each A_i will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. Must be at least max(lda, 1).
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasCher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
her2StridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
n by n Hermitian matrix for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
specifies the stride between the beginning of one vector (x_i) and the next (x_i+1).
@param[in]
y         device pointer pointing to the first vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey  [hipblasStride]
specifies the stride between the beginning of one vector (y_i) and the next (y_i+1).
@param[inout]
AP        device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of
each Hermitian matrix A_i.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular
portion of each A_i will not be touched.
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular
portion of each A_i will not be touched.
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
lda       [int]
specifies the leading dimension of each A_i. Must be at least max(lda, 1).
@param[in]
strideA  [hipblasStride]
specifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasCher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpmv performs the matrix-vector operation

y := alpha*A*x + beta*y

where alpha and beta are scalars, x and y are n element vectors and A is an
n by n Hermitian matrix, supplied in packed form (see description below).

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.
@param[in]
n         [int]
the order of the matrix A, must be >= 0.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device pointer storing the packed version of the specified triangular portion of
the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
(3,-2) (5, 1) (6, 0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
(3,-2) (5, 1) (6, 0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
*/
    pub fn hipblasChpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpmvBatched performs the matrix-vector operation

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian matrix, supplied in packed form (see description below),
for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP      device pointer of device pointers storing the packed version of the specified triangular
portion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that each AP_i contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
(3,-2) (5, 1) (6, 0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that each AP_i contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
(3,-2) (5, 1) (6, 0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpmvStridedBatched performs the matrix-vector operation

y_i := alpha*A_i*x_i + beta*y_i

where alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an
n by n Hermitian matrix, supplied in packed form (see description below),
for each batch in i = [1, batchCount].

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.
@param[in]
n         [int]
the order of each matrix A_i.
@param[in]
alpha     device pointer or host pointer to scalar alpha.
@param[in]
AP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed
version of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that each AP_i contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]
(3,-2) (5, 1) (6, 0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that each AP_i contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (3, 2)
(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]
(3,-2) (5, 1) (6, 0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (AP_i) and the next one (AP_i+1).
@param[in]
x         device array pointing to the beginning of the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[in]
beta      device pointer or host pointer to scalar beta.
@param[inout]
y         device array pointing to the beginning of the first vector (y_1).
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpr performs the matrix-vector operations

A := A + alpha*x*x**H

where alpha is a real scalar, x is a vector, and A is an
n by n Hermitian matrix, supplied in packed form.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.*/
    pub fn hipblasChpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: i64,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipComplex,
        incx: i64,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: i64,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hprBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**H

where alpha is a real scalar, x_i is a vector, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasChprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: i64,
        AP: *const *mut hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: i64,
        AP: *const *mut hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        AP: *const *mut hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hprStridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**H

where alpha is a real scalar, x_i is a vector, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each Hermitian matrix A_i. Points to the first matrix (A_1).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
strideA   [hipblasStride]
stride from the start of one (A_i) and the next (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasChprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpr2 performs the matrix-vector operations

A := A + alpha*x*y**H + conj(alpha)*y*x**H

where alpha is a complex scalar, x and y are vectors, and A is an
n by n Hermitian matrix, supplied in packed form.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
the Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the Hermitian matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.*/
    pub fn hipblasChpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpr2Batched performs the matrix-vector operations

A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasChpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        AP: *const *mut hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        AP: *const *mut hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        AP: *const *mut hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
hpr2StridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H

where alpha is a complex scalar, x_i and y_i are vectors, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[in]
y         device pointer pointing to the first vector (y_1).
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each Hermitian matrix A_i. Points to the first matrix (A_1).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]
(4,-9) (5,-3) (6,0)
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each Hermitian matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 3)
(1, 0) (2, 1) (4,9)
(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]
(4,-9) (5,-3) (6,0)
Note that the imaginary part of the diagonal elements are not accessed and are assumed
to be 0.
@param[in]
strideA    [hipblasStride]
stride from the start of one (A_i) and the next (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasChpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
sbmv performs the matrix-vector operation:

y := alpha*A*x + beta*y,

where alpha and beta are scalars, x and y are n element vectors and
A should contain an upper or lower triangular n by n symmetric banded matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : s,d

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
@param[in]
k         [int]
specifies the number of sub- and super-diagonals
@param[in]
alpha
specifies the scalar alpha
@param[in]
AP         pointer storing matrix A on the GPU
@param[in]
lda       [int]
specifies the leading dimension of matrix A
@param[in]
x         pointer storing vector x on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of x
@param[in]
beta      specifies the scalar beta
@param[out]
y         pointer storing vector y on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of y
*/
    pub fn hipblasSsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
sbmvBatched performs the matrix-vector operation:

y_i := alpha*A_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric banded matrix, for i = 1, ..., batchCount.
A should contain an upper or lower triangular n by n symmetric banded matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
k         [int]
specifies the number of sub- and super-diagonals
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP         device array of device pointers storing each matrix A_i
@param[in]
lda       [int]
specifies the leading dimension of each matrix A_i
@param[in]
x         device array of device pointers storing each vector x_i
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         device array of device pointers storing each vector y_i
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
sbmvStridedBatched performs the matrix-vector operation:

y_i := alpha*A_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric banded matrix, for i = 1, ..., batchCount.
A should contain an upper or lower triangular n by n symmetric banded matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
k         [int]
specifies the number of sub- and super-diagonals
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP        Device pointer to the first matrix A_1 on the GPU
@param[in]
lda       [int]
specifies the leading dimension of each matrix A_i
@param[in]
strideA     [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         Device pointer to the first vector x_1 on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size.
This typically means stridex >= n * incx. stridex should be non zero.
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         Device pointer to the first vector y_1 on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size.
This typically means stridey >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spmv performs the matrix-vector operation:

y := alpha*A*x + beta*y,

where alpha and beta are scalars, x and y are n element vectors and
A should contain an upper or lower triangular n by n packed symmetric matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : s,d

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
@param[in]
alpha
specifies the scalar alpha
@param[in]
AP         pointer storing matrix A on the GPU
@param[in]
x         pointer storing vector x on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of x
@param[in]
beta      specifies the scalar beta
@param[out]
y         pointer storing vector y on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of y
*/
    pub fn hipblasSspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spmvBatched performs the matrix-vector operation:

y_i := alpha*AP_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric matrix, for i = 1, ..., batchCount.
A should contain an upper or lower triangular n by n packed symmetric matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP         device array of device pointers storing each matrix A_i
@param[in]
x         device array of device pointers storing each vector x_i
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         device array of device pointers storing each vector y_i
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spmvStridedBatched performs the matrix-vector operation:

y_i := alpha*A_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric matrix, for i = 1, ..., batchCount.
A should contain an upper or lower triangular n by n packed symmetric matrix.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP        Device pointer to the first matrix A_1 on the GPU
@param[in]
strideA    [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         Device pointer to the first vector x_1 on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size.
This typically means stridex >= n * incx. stridex should be non zero.
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         Device pointer to the first vector y_1 on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size.
This typically means stridey >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spr performs the matrix-vector operations

A := A + alpha*x*x**T

where alpha is a scalar, x is a vector, and A is an
n by n symmetric matrix, supplied in packed form.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the symmetric matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the symmetric matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0*/
    pub fn hipblasSspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
sprBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**T

where alpha is a scalar, x_i is a vector, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasSsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        AP: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        AP: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        AP: *const *mut f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        AP: *const *mut f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        AP: *const *mut hipblasComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        AP: *const *mut hipComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        AP: *const *mut hipDoubleComplex,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
sprStridedBatched performs the matrix-vector operations

A_i := A_i + alpha*x_i*x_i**T

where alpha is a scalar, x_i is a vector, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
each symmetric matrix A_i. Points to the first A_1.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(2) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0
@param[in]
strideA    [hipblasStride]
stride from the start of one (A_i) and the next (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasSsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spr2 performs the matrix-vector operation

A := A + alpha*x*y**T + alpha*y*x**T

where alpha is a scalar, x and y are vectors, and A is an
n by n symmetric matrix, supplied in packed form.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : s,d

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of matrix A, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
the symmetric matrix A. Of at least size ((n * (n + 1)) / 2).
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of the symmetric matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of the symmetric matrix A is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(n) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0*/
    pub fn hipblasSspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spr2Batched performs the matrix-vector operation

A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T

where alpha is a scalar, x_i and y_i are vectors, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[inout]
AP        device array of device pointers storing the packed version of the specified triangular portion of
each symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(n) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasSspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        AP: *const *mut f32,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        AP: *const *mut f64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
spr2StridedBatched performs the matrix-vector operation

A_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T

where alpha is a scalar, x_i amd y_i are vectors, and A_i is an
n by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
HIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.
HIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.
@param[in]
n         [int]
the number of rows and columns of each matrix A_i, must be at least 0.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer pointing to the first vector (x_1).
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
@param[in]
y         device pointer pointing to the first vector (y_1).
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey  [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
@param[inout]
AP        device pointer storing the packed version of the specified triangular portion of
each symmetric matrix A_i. Points to the first A_1.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The upper triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(0,1)
AP(2) = A(1,1), etc.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 4)
1 2 4 7
2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
4 5 6 9
7 8 9 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The lower triangular portion of each symmetric matrix A_i is supplied.
The matrix is compacted so that AP contains the triangular portion column-by-column
so that:
AP(0) = A(0,0)
AP(1) = A(1,0)
AP(n) = A(2,1), etc.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 4)
1 2 3 4
2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
3 6 8 9
4 7 9 0
@param[in]
strideA   [hipblasStride]
stride from the start of one (A_i) and the next (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch.*/
    pub fn hipblasSspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSspr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *const f32,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *const f64,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
symv performs the matrix-vector operation:

y := alpha*A*x + beta*y,

where alpha and beta are scalars, x and y are n element vectors and
A should contain an upper or lower triangular n by n symmetric matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
@param[in]
alpha
specifies the scalar alpha
@param[in]
AP         pointer storing matrix A on the GPU
@param[in]
lda       [int]
specifies the leading dimension of A
@param[in]
x         pointer storing vector x on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of x
@param[in]
beta      specifies the scalar beta
@param[out]
y         pointer storing vector y on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of y
*/
    pub fn hipblasSsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
symvBatched performs the matrix-vector operation:

y_i := alpha*A_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric matrix, for i = 1, ..., batchCount.
A a should contain an upper or lower triangular symmetric matrix
and the opposing triangular part of A is not referenced

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP        device array of device pointers storing each matrix A_i
@param[in]
lda       [int]
specifies the leading dimension of each matrix A_i
@param[in]
x         device array of device pointers storing each vector x_i
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         device array of device pointers storing each vector y_i
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        beta: *const f32,
        y: *const *mut f32,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        beta: *const f64,
        y: *const *mut f64,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
symvStridedBatched performs the matrix-vector operation:

y_i := alpha*A_i*x_i + beta*y_i,

where (A_i, x_i, y_i) is the i-th instance of the batch.
alpha and beta are scalars, x_i and y_i are vectors and A_i is an
n by n symmetric matrix, for i = 1, ..., batchCount.
A a should contain an upper or lower triangular symmetric matrix
and the opposing triangular part of A is not referenced

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
number of rows and columns of each matrix A_i
@param[in]
alpha
device pointer or host pointer to scalar alpha
@param[in]
AP         Device pointer to the first matrix A_1 on the GPU
@param[in]
lda       [int]
specifies the leading dimension of each matrix A_i
@param[in]
strideA     [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         Device pointer to the first vector x_1 on the GPU
@param[in]
incx      [int]
specifies the increment for the elements of each vector x_i
@param[in]
stridex     [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size.
This typically means stridex >= n * incx. stridex should be non zero.
@param[in]
beta      device pointer or host pointer to scalar beta
@param[out]
y         Device pointer to the first vector y_1 on the GPU
@param[in]
incy      [int]
specifies the increment for the elements of each vector y_i
@param[in]
stridey     [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size.
This typically means stridey >= n * incy. stridey should be non zero.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syr performs the matrix-vector operations

A := A + alpha*x*x**T

where alpha is a scalar, x is a vector, and A is an
n by n symmetric matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

@param[in]
n         [int]
the number of rows and columns of matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
*/
    pub fn hipblasSsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        AP: *mut f32,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        AP: *mut f64,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syrBatched performs a batch of matrix-vector operations

A[i] := A[i] + alpha*x[i]*x[i]**T

where alpha is a scalar, x is an array of vectors, and A is an array of
n by n symmetric matrices, for i = 1 , ... , batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
the number of rows and columns of matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
AP         device array of device pointers storing each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        AP: *const *mut f32,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        AP: *const *mut f64,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syrStridedBatched performs the matrix-vector operations

A[i] := A[i] + alpha*x[i]*x[i]**T

where alpha is a scalar, vectors, and A is an array of
n by n symmetric matrices, for i = 1 , ... , batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
the number of rows and columns of each matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex   [hipblasStride]
specifies the pointer increment between vectors (x_i) and (x_i+1).
@param[inout]
AP         device pointer to the first matrix A_1.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA   [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut f32,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut f64,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syr2 performs the matrix-vector operations

A := A + alpha*x*y**T + alpha*y*x**T

where alpha is a scalar, x and y are vectors, and A is an
n by n symmetric matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced

@param[in]
n         [int]
the number of rows and columns of matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
y         device pointer storing vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
*/
    pub fn hipblasSsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        y: *const f32,
        incy: i64,
        AP: *mut f32,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        y: *const f64,
        incy: i64,
        AP: *mut f64,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        y: *const hipblasComplex,
        incy: i64,
        AP: *mut hipblasComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        y: *const hipblasDoubleComplex,
        incy: i64,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        y: *const hipComplex,
        incy: i64,
        AP: *mut hipComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        y: *const hipDoubleComplex,
        incy: i64,
        AP: *mut hipDoubleComplex,
        lda: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syr2Batched performs a batch of matrix-vector operations

A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T

where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
n by n symmetric matrix, for i = 1 , ... , batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
the number of rows and columns of matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[inout]
AP         device array of device pointers storing each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const *const f32,
        incx: i64,
        y: *const *const f32,
        incy: i64,
        AP: *const *mut f32,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const *const f64,
        incx: i64,
        y: *const *const f64,
        incy: i64,
        AP: *const *mut f64,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: i64,
        y: *const *const hipblasComplex,
        incy: i64,
        AP: *const *mut hipblasComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        y: *const *const hipblasDoubleComplex,
        incy: i64,
        AP: *const *mut hipblasDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: i64,
        y: *const *const hipComplex,
        incy: i64,
        AP: *const *mut hipComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: i64,
        y: *const *const hipDoubleComplex,
        incy: i64,
        AP: *const *mut hipDoubleComplex,
        lda: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
syr2StridedBatched the matrix-vector operations

A[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T

where alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a
n by n symmetric matrices, for i = 1 , ... , batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
n         [int]
the number of rows and columns of each matrix A.
@param[in]
alpha
device pointer or host pointer to scalar alpha.
@param[in]
x         device pointer to the first vector x_1.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex   [hipblasStride]
specifies the pointer increment between vectors (x_i) and (x_i+1).
@param[in]
y         device pointer to the first vector y_1.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey   [hipblasStride]
specifies the pointer increment between vectors (y_i) and (y_i+1).
@param[inout]
AP         device pointer to the first matrix A_1.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA   [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasSsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f32,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        y: *const f32,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const f64,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        y: *const f64,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: i64,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: i64,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbmv performs one of the matrix-vector operations

x := A*x      or
x := A**T*x   or
x := A**H*x,

x is a vectors and A is a banded n by n matrix (see description below).

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.
HIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.
@param[in]
transA     [hipblasOperation_t]
indicates whether matrix A is tranposed (conjugated) or not.
@param[in]
diag      [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only
1's and is not referenced.
HIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.
@param[in]
n         [int]
the number of rows and columns of the matrix represented by A.
@param[in]
k         [int]
if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
of the matrix A.
if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
of the matrix A.
k must satisfy k > 0 && k < lda.
@param[in]
AP         device pointer storing banded triangular matrix A.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The matrix represented is an upper banded triangular matrix
with the main diagonal and k super-diagonals, everything
else can be assumed to be 0.
The matrix is compacted so that the main diagonal resides on the k'th
row, the first super diagonal resides on the RHS of the k-1'th row, etc,
with the k'th diagonal on the RHS of the 0'th row.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
1 6 9 0 0              0 0 9 8 7
0 2 7 8 0              0 6 7 8 9
0 0 3 8 7     ---->    1 2 3 4 5
0 0 0 4 9              0 0 0 0 0
0 0 0 0 5              0 0 0 0 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The matrix represnted is a lower banded triangular matrix
with the main diagonal and k sub-diagonals, everything else can be
assumed to be 0.
The matrix is compacted so that the main diagonal resides on the 0'th row,
working up to the k'th diagonal residing on the LHS of the k'th row.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
1 0 0 0 0              1 2 3 4 5
6 2 0 0 0              6 7 8 9 0
9 7 3 0 0     ---->    9 8 7 0 0
0 8 8 4 0              0 0 0 0 0
0 0 7 9 5              0 0 0 0 0
@param[in]
lda       [int]
specifies the leading dimension of A. lda must satisfy lda > k.
@param[inout]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasStbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasComplex,
        lda: i64,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipComplex,
        lda: i64,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbmvBatched performs one of the matrix-vector operations

x_i := A_i*x_i      or
x_i := A_i**T*x_i   or
x_i := A_i**H*x_i,

where (A_i, x_i) is the i-th instance of the batch.
x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
@param[in]
transA     [hipblasOperation_t]
indicates whether each matrix A_i is tranposed (conjugated) or not.
@param[in]
diag      [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
1's and is not referenced.
HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
@param[in]
n         [int]
the number of rows and columns of the matrix represented by each A_i.
@param[in]
k         [int]
if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
of each matrix A_i.
if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
of each matrix A_i.
k must satisfy k > 0 && k < lda.
@param[in]
AP         device array of device pointers storing each banded triangular matrix A_i.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The matrix represented is an upper banded triangular matrix
with the main diagonal and k super-diagonals, everything
else can be assumed to be 0.
The matrix is compacted so that the main diagonal resides on the k'th
row, the first super diagonal resides on the RHS of the k-1'th row, etc,
with the k'th diagonal on the RHS of the 0'th row.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
1 6 9 0 0              0 0 9 8 7
0 2 7 8 0              0 6 7 8 9
0 0 3 8 7     ---->    1 2 3 4 5
0 0 0 4 9              0 0 0 0 0
0 0 0 0 5              0 0 0 0 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The matrix represnted is a lower banded triangular matrix
with the main diagonal and k sub-diagonals, everything else can be
assumed to be 0.
The matrix is compacted so that the main diagonal resides on the 0'th row,
working up to the k'th diagonal residing on the LHS of the k'th row.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
1 0 0 0 0              1 2 3 4 5
6 2 0 0 0              6 7 8 9 0
9 7 3 0 0     ---->    9 8 7 0 0
0 8 8 4 0              0 0 0 0 0
0 0 7 9 5              0 0 0 0 0
@param[in]
lda       [int]
specifies the leading dimension of each A_i. lda must satisfy lda > k.
@param[inout]
x         device array of device pointer storing each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasStbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbmvStridedBatched performs one of the matrix-vector operations

x_i := A_i*x_i      or
x_i := A_i**T*x_i   or
x_i := A_i**H*x_i,

where (A_i, x_i) is the i-th instance of the batch.
x_i is a vector and A_i is an n by n matrix, for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.
HIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.
@param[in]
transA     [hipblasOperation_t]
indicates whether each matrix A_i is tranposed (conjugated) or not.
@param[in]
diag      [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only
1's and is not referenced.
HIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.
@param[in]
n         [int]
the number of rows and columns of the matrix represented by each A_i.
@param[in]
k         [int]
if uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals
of each matrix A_i.
if uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals
of each matrix A_i.
k must satisfy k > 0 && k < lda.
@param[in]
AP         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.
if uplo == HIPBLAS_FILL_MODE_UPPER:
The matrix represented is an upper banded triangular matrix
with the main diagonal and k super-diagonals, everything
else can be assumed to be 0.
The matrix is compacted so that the main diagonal resides on the k'th
row, the first super diagonal resides on the RHS of the k-1'th row, etc,
with the k'th diagonal on the RHS of the 0'th row.
Ex: (HIPBLAS_FILL_MODE_UPPER; n = 5; k = 2)
1 6 9 0 0              0 0 9 8 7
0 2 7 8 0              0 6 7 8 9
0 0 3 8 7     ---->    1 2 3 4 5
0 0 0 4 9              0 0 0 0 0
0 0 0 0 5              0 0 0 0 0
if uplo == HIPBLAS_FILL_MODE_LOWER:
The matrix represnted is a lower banded triangular matrix
with the main diagonal and k sub-diagonals, everything else can be
assumed to be 0.
The matrix is compacted so that the main diagonal resides on the 0'th row,
working up to the k'th diagonal residing on the LHS of the k'th row.
Ex: (HIPBLAS_FILL_MODE_LOWER; n = 5; k = 2)
1 0 0 0 0              1 2 3 4 5
6 2 0 0 0              6 7 8 9 0
9 7 3 0 0     ---->    9 8 7 0 0
0 8 8 4 0              0 0 0 0 0
0 0 7 9 5              0 0 0 0 0
@param[in]
lda       [int]
specifies the leading dimension of each A_i. lda must satisfy lda > k.
@param[in]
strideA  [hipblasStride]
stride from the start of one A_i matrix to the next A_(i + 1).
@param[inout]
x         device array to the first vector x_i of the batch.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the start of one x_i matrix to the next x_(i + 1).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasStbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbsv solves

A*x = b or A**T*x = b or A**H*x = b,

where x and b are vectors and A is a banded triangular matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]
HIPBLAS_OP_N: Solves A*x = b
HIPBLAS_OP_T: Solves A**T*x = b
HIPBLAS_OP_C: Solves A**H*x = b

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
of A are not used in computations).
HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of b. n >= 0.
@param[in]
k         [int]
if(uplo == HIPBLAS_FILL_MODE_UPPER)
k specifies the number of super-diagonals of A.
if(uplo == HIPBLAS_FILL_MODE_LOWER)
k specifies the number of sub-diagonals of A.
k >= 0.

@param[in]
AP         device pointer storing the matrix A in banded format.

@param[in]
lda       [int]
specifies the leading dimension of A.
lda >= (k + 1).

@param[inout]
x         device pointer storing input vector b. Overwritten by the output vector x.

@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasStbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasComplex,
        lda: i64,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipComplex,
        lda: i64,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbsvBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,

where x_i and b_i are vectors and A_i is a banded triangular matrix,
for i = [1, batchCount].

The input vectors b_i are overwritten by the output vectors x_i.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]
HIPBLAS_OP_N: Solves A_i*x_i = b_i
HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
HIPBLAS_OP_C: Solves A_i**H*x_i = b_i

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
of each A_i are not used in computations).
HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of each b_i. n >= 0.
@param[in]
k         [int]
if(uplo == HIPBLAS_FILL_MODE_UPPER)
k specifies the number of super-diagonals of each A_i.
if(uplo == HIPBLAS_FILL_MODE_LOWER)
k specifies the number of sub-diagonals of each A_i.
k >= 0.

@param[in]
AP         device vector of device pointers storing each matrix A_i in banded format.

@param[in]
lda       [int]
specifies the leading dimension of each A_i.
lda >= (k + 1).

@param[inout]
x         device vector of device pointers storing each input vector b_i. Overwritten by each output
vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasStbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tbsvStridedBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,

where x_i and b_i are vectors and A_i is a banded triangular matrix,
for i = [1, batchCount].

The input vectors b_i are overwritten by the output vectors x_i.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]
HIPBLAS_OP_N: Solves A_i*x_i = b_i
HIPBLAS_OP_T: Solves A_i**T*x_i = b_i
HIPBLAS_OP_C: Solves A_i**H*x_i = b_i

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
of each A_i are not used in computations).
HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of each b_i. n >= 0.
@param[in]
k         [int]
if(uplo == HIPBLAS_FILL_MODE_UPPER)
k specifies the number of super-diagonals of each A_i.
if(uplo == HIPBLAS_FILL_MODE_LOWER)
k specifies the number of sub-diagonals of each A_i.
k >= 0.

@param[in]
AP         device pointer pointing to the first banded matrix A_1.

@param[in]
lda       [int]
specifies the leading dimension of each A_i.
lda >= (k + 1).
@param[in]
strideA  [hipblasStride]
specifies the distance between the start of one matrix (A_i) and the next (A_i+1).

@param[inout]
x         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
specifies the distance between the start of one vector (x_i) and the next (x_i+1).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasStbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStbsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        k: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpmv performs one of the matrix-vector operations

x = A*x or x = A**T*x,

where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.

The vector x is overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
n       [int]
n specifies the number of rows of A. n >= 0.

@param[in]
AP       device pointer storing matrix A,
of dimension at least ( n * ( n + 1 ) / 2 ).
Before entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A
must contain the upper triangular matrix packed sequentially,
column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
a_{0,1} and a_{1, 1} respectively, and so on.
Before entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A
must contain the lower triangular matrix packed sequentially,
column by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain
a_{1,0} and a_{2,0} respectively, and so on.
Note that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are
not referenced, but are assumed to be unity.

@param[in]
x       device pointer storing vector x.

@param[in]
incx    [int]
specifies the increment for the elements of x. incx must not be zero.
*/
    pub fn hipblasStpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpmvBatched performs one of the matrix-vector operations

x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)

The vectors x_i are overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of matrices A_i. n >= 0.

@param[in]
AP         device pointer storing pointer of matrices A_i,
of dimension ( lda, n )

@param[in]
x         device pointer storing vectors x_i.

@param[in]
incx      [int]
specifies the increment for the elements of vectors x_i.

@param[in]
batchCount [int]
The number of batched matrices/vectors.

*/
    pub fn hipblasStpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpmvStridedBatched performs one of the matrix-vector operations

x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).

The vectors x_i are overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of matrices A_i. n >= 0.

@param[in]
AP         device pointer of the matrix A_0,
of dimension ( lda, n )

@param[in]
strideA  [hipblasStride]
stride from the start of one A_i matrix to the next A_{i + 1}

@param[in]
x         device pointer storing the vector x_0.

@param[in]
incx      [int]
specifies the increment for the elements of one vector x.

@param[in]
stridex  [hipblasStride]
stride from the start of one x_i vector to the next x_{i + 1}

@param[in]
batchCount [int]
The number of batched matrices/vectors.

*/
    pub fn hipblasStpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpsv solves

A*x = b or A**T*x = b, or A**H*x = b,

where x and b are vectors and A is a triangular matrix stored in the packed format.

The input vector b is overwritten by the output vector x.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: Solves A*x = b
HIPBLAS_OP_T: Solves A**T*x = b
HIPBLAS_OP_C: Solves A**H*x = b

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements
of A are not used in computations).
HIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of b. n >= 0.

@param[in]
AP        device pointer storing the packed version of matrix A,
of dimension >= (n * (n + 1) / 2)

@param[inout]
x         device pointer storing vector b on input, overwritten by x on output.

@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasStpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpsvBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,

where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
for i in [1, batchCount].

The input vectors b_i are overwritten by the output vectors x_i.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: Solves A*x = b
HIPBLAS_OP_T: Solves A**T*x = b
HIPBLAS_OP_C: Solves A**H*x = b

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
of each A_i are not used in computations).
HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of each b_i. n >= 0.

@param[in]
AP        device array of device pointers storing the packed versions of each matrix A_i,
of dimension >= (n * (n + 1) / 2)

@param[inout]
x         device array of device pointers storing each input vector b_i, overwritten by x_i on output.

@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
batchCount [int]
specifies the number of instances in the batch.
*/
    pub fn hipblasStpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
tpsvStridedBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,

where x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,
for i in [1, batchCount].

The input vectors b_i are overwritten by the output vectors x_i.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: Solves A*x = b
HIPBLAS_OP_T: Solves A**T*x = b
HIPBLAS_OP_C: Solves A**H*x = b

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements
of each A_i are not used in computations).
HIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of each b_i. n >= 0.

@param[in]
AP        device pointer pointing to the first packed matrix A_1,
of dimension >= (n * (n + 1) / 2)

@param[in]
strideA  [hipblasStride]
stride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).

@param[inout]
x         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.

@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex  [hipblasStride]
stride from the beginning of one vector (x_i) and the next (x_i+1).
@param[in]
batchCount [int]
specifies the number of instances in the batch.
*/
    pub fn hipblasStpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStpsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trmv performs one of the matrix-vector operations

x = A*x or x = A**T*x,

where x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.

The vector x is overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of A. n >= 0.

@param[in]
AP        device pointer storing matrix A,
of dimension ( lda, n )

@param[in]
lda       [int]
specifies the leading dimension of A.
lda = max( 1, n ).

@param[in]
x         device pointer storing vector x.

@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasStrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trmvBatched performs one of the matrix-vector operations

x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)

The vectors x_i are overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of matrices A_i. n >= 0.

@param[in]
AP        device pointer storing pointer of matrices A_i,
of dimension ( lda, n )

@param[in]
lda       [int]
specifies the leading dimension of A_i.
lda >= max( 1, n ).

@param[in]
x         device pointer storing vectors x_i.

@param[in]
incx      [int]
specifies the increment for the elements of vectors x_i.

@param[in]
batchCount [int]
The number of batched matrices/vectors.

*/
    pub fn hipblasStrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trmvStridedBatched performs one of the matrix-vector operations

x_i = A_i*x_i or x_i = A**T*x_i, 0 \le i < batchCount

where x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)
with strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).

The vectors x_i are overwritten.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of matrices A_i. n >= 0.

@param[in]
AP        device pointer of the matrix A_0,
of dimension ( lda, n )

@param[in]
lda       [int]
specifies the leading dimension of A_i.
lda >= max( 1, n ).

@param[in]
strideA  [hipblasStride]
stride from the start of one A_i matrix to the next A_{i + 1}

@param[in]
x         device pointer storing the vector x_0.

@param[in]
incx      [int]
specifies the increment for the elements of one vector x.

@param[in]
stridex  [hipblasStride]
stride from the start of one x_i vector to the next x_{i + 1}

@param[in]
batchCount [int]
The number of batched matrices/vectors.

*/
    pub fn hipblasStrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trsv solves

A*x = b or A**T*x = b,

where x and b are vectors and A is a triangular matrix.

The vector x is overwritten on b.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of b. n >= 0.

@param[in]
AP        device pointer storing matrix A,
of dimension ( lda, n )

@param[in]
lda       [int]
specifies the leading dimension of A.
lda = max( 1, n ).

@param[in]
x         device pointer storing vector x.

@param[in]
incx      [int]
specifies the increment for the elements of x.
*/
    pub fn hipblasStrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        lda: i64,
        x: *mut f32,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        lda: i64,
        x: *mut f64,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        x: *mut hipblasComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *mut hipblasDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        x: *mut hipComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *mut hipDoubleComplex,
        incx: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trsvBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i,

where (A_i, x_i, b_i) is the i-th instance of the batch.
x_i and b_i are vectors and A_i is an
n by n triangular matrix.

The vector x is overwritten on b.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of b. n >= 0.

@param[in]
AP         device array of device pointers storing each matrix A_i.

@param[in]
lda       [int]
specifies the leading dimension of each A_i.
lda = max(1, n)

@param[in]
x         device array of device pointers storing each vector x_i.

@param[in]
incx      [int]
specifies the increment for the elements of x.

@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasStrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f32,
        lda: i64,
        x: *const *mut f32,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const f64,
        lda: i64,
        x: *const *mut f64,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *mut hipblasComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *mut hipblasDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *mut hipComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *mut hipDoubleComplex,
        incx: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 2 API

\details
trsvStridedBatched solves

A_i*x_i = b_i or A_i**T*x_i = b_i,

where (A_i, x_i, b_i) is the i-th instance of the batch.
x_i and b_i are vectors and A_i is an n by n triangular matrix, for i = 1, ..., batchCount.

The vector x is overwritten on b.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA     [hipblasOperation_t]

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
n         [int]
n specifies the number of rows of each b_i. n >= 0.

@param[in]
AP         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, n )

@param[in]
strideA  [hipblasStride]
stride from the start of one A_i matrix to the next A_(i + 1)

@param[in]
lda       [int]
specifies the leading dimension of each A_i.
lda = max( 1, n ).

@param[in, out]
x         device pointer to the first vector (x_1) in the batch.

@param[in]
stridex [hipblasStride]
stride from the start of one x_i vector to the next x_(i + 1)

@param[in]
incx      [int]
specifies the increment for the elements of each x_i.

@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasStrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f32,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
gemm performs one of the matrix-matrix operations

C = alpha*op( A )*op( B ) + beta*C,

where op( X ) is one of

op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,

alpha and beta are scalars, and A, B and C are matrices, with
op( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : h,s,d,c,z

@param[in]
handle    [hipblasHandle_t]

.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )
@param[in]
m         [int]
number or rows of matrices op( A ) and C
@param[in]
n         [int]
number of columns of matrices op( B ) and C
@param[in]
k         [int]
number of columns of matrix op( A ) and number of rows of matrix op( B )
@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.
@param[in]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
BP         device pointer storing matrix B.
@param[in]
ldb       [int]
specifies the leading dimension of B.
@param[in]
beta      device pointer or host pointer specifying the scalar beta.
@param[in, out]
CP         device pointer storing matrix C on the GPU.
@param[in]
ldc       [int]
specifies the leading dimension of C.
*/
    pub fn hipblasHgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::core::ffi::c_int,
        BP: *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemm_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: i64,
        BP: *const hipblasHalf,
        ldb: i64,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        BP: *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        BP: *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API
\details
gemmBatched performs one of the batched matrix-matrix operations
C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.
where op( X ) is one of
op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,
alpha and beta are scalars, and A, B and C are strided batched matrices, with
op( A ) an m by k by batchCount strided_batched matrix,
op( B ) an k by n by batchCount strided_batched matrix and
C an m by n by batchCount strided_batched matrix.

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : h,s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
k         [int]
matrix dimension k.
@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.
@param[in]
AP         device array of device pointers storing each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
BP         device array of device pointers storing each matrix B_i.
@param[in]
ldb       [int]
specifies the leading dimension of each B_i.
@param[in]
beta      device pointer or host pointer specifying the scalar beta.
@param[in, out]
CP         device array of device pointers storing each matrix C_i.
@param[in]
ldc       [int]
specifies the leading dimension of each C_i.
@param[in]
batchCount
[int]
number of gemm operations in the batch*/
    pub fn hipblasHgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const *const hipblasHalf,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasHalf,
        CP: *const *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasHalf,
        AP: *const *const hipblasHalf,
        lda: i64,
        BP: *const *const hipblasHalf,
        ldb: i64,
        beta: *const hipblasHalf,
        CP: *const *mut hipblasHalf,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        BP: *const *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        BP: *const *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
gemmStridedBatched performs one of the strided batched matrix-matrix operations

C_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.

where op( X ) is one of

op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,

alpha and beta are scalars, and A, B and C are strided batched matrices, with
op( A ) an m by k by batchCount strided_batched matrix,
op( B ) an k by n by batchCount strided_batched matrix and
C an m by n by batchCount strided_batched matrix.

- Supported precisions in rocBLAS : h,s,d,c,z
- Supported precisions in cuBLAS  : h,s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
k         [int]
matrix dimension k.
@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.
@param[in]
AP         device pointer pointing to the first matrix A_1.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA  [hipblasStride]
stride from the start of one A_i matrix to the next A_(i + 1).
@param[in]
BP         device pointer pointing to the first matrix B_1.
@param[in]
ldb       [int]
specifies the leading dimension of each B_i.
@param[in]
strideB  [hipblasStride]
stride from the start of one B_i matrix to the next B_(i + 1).
@param[in]
beta      device pointer or host pointer specifying the scalar beta.
@param[in, out]
CP         device pointer pointing to the first matrix C_1.
@param[in]
ldc       [int]
specifies the leading dimension of each C_i.
@param[in]
strideC  [hipblasStride]
stride from the start of one C_i matrix to the next C_(i + 1).
@param[in]
batchCount
[int]
number of gemm operatons in the batch
*/
    pub fn hipblasHgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasHgemmStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasHalf,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const f32,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const f64,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipComplex,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: ::core::ffi::c_longlong,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herk performs one of the matrix-matrix operations for a Hermitian rank-k update

C := alpha*op( A )*op( A )^H + beta*C

where  alpha and beta are scalars, op(A) is an n by k matrix, and
C is a n x n Hermitian matrix stored as either upper or lower.

op( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N
op( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C:  op(A) = A^H
HIPBLAS_ON_N:  op(A) = A

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasCherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: i64,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: i64,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: i64,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i

where  alpha and beta are scalars, op(A) is an n by k matrix, and
C_i is a n x n Hermitian matrix stored as either upper or lower.

op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op(A) = A^H
HIPBLAS_OP_N: op(A) = A

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const hipblasComplex,
        lda: i64,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const hipComplex,
        lda: i64,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

C_i := alpha*op( A_i )*op( A_i )^H + beta*C_i

where  alpha and beta are scalars, op(A) is an n by k matrix, and
C_i is a n x n Hermitian matrix stored as either upper or lower.

op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
op( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op(A) = A^H
HIPBLAS_OP_N: op(A) = A

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herkx performs one of the matrix-matrix operations for a Hermitian rank-k update

C := alpha*op( A )*op( B )^H + beta*C

where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
C is a n x n Hermitian matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.


op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
HIPBLAS_OP_N:  op( A ) = A, op( B ) = B

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP      pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).
@param[in]
BP       pointer storing matrix B on the GPU.
Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
only the upper/lower triangular part is accessed.

@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasCherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
C_i is a n x n Hermitian matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op(A) = A^H
HIPBLAS_OP_N: op(A) = A

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

herkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update

C_i := alpha*op( A_i )*op( B_i )^H + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
C_i is a n x n Hermitian matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

her2k performs one of the matrix-matrix operations for a Hermitian rank-2k update

C := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C

where  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and
C is a n x n Hermitian matrix stored as either upper or lower.

op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
op( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H
HIPBLAS_OP_N:  op( A ) = A, op( B ) = B

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).
@param[in]
BP       pointer storing matrix B on the GPU.
Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
only the upper/lower triangular part is accessed.

@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasCher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

her2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update

C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
C_i is a n x n Hermitian matrix stored as either upper or lower.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op(A) = A^H
HIPBLAS_OP_N: op(A) = A

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).
@param[in]
BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

her2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update

C_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and
C_i is a n x n Hermitian matrix stored as either upper or lower.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H
HIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU.
The imaginary component of the diagonal elements are not used but are set to zero unless quick return.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasCher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

symm performs one of the matrix-matrix operations:

C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B and C are m by n matrices, and
A is a symmetric matrix stored as either upper or lower.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix

@param[in]
m       [int]
m specifies the number of rows of B and C. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B and C. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A and B are not referenced.

@param[in]
AP       pointer storing matrix A on the GPU.
A is m by m if side == HIPBLAS_SIDE_LEFT
A is n by n if side == HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
BP       pointer storing matrix B on the GPU.
Matrix dimension is m by n

@param[in]
ldb     [int]
ldb specifies the first dimension of B. ldb >= max( 1, m )

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.
Matrix dimension is m by n

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, m )
*/
    pub fn hipblasSsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        BP: *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        BP: *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

symmBatched performs a batch of the matrix-matrix operations:

C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B_i and C_i are m by n matrices, and
A_i is a symmetric matrix stored as either upper or lower.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

@param[in]
m       [int]
m specifies the number of rows of B_i and C_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B_i and C_i. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i and B_i are not referenced.

@param[in]
AP      device array of device pointers storing each matrix A_i on the GPU.
A_i is m by m if side == HIPBLAS_SIDE_LEFT
A_i is n by n if side == HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
BP       device array of device pointers storing each matrix B_i on the GPU.
Matrix dimension is m by n

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i. ldb >= max( 1, m )

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C_i need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.
Matrix dimension is m by n

@param[in]
ldc    [int]
ldc specifies the first dimension of C_i. ldc >= max( 1, m )

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        BP: *const *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        BP: *const *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

symmStridedBatched performs a batch of the matrix-matrix operations:

C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B_i and C_i are m by n matrices, and
A_i is a symmetric matrix stored as either upper or lower.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

@param[in]
m       [int]
m specifies the number of rows of B_i and C_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B_i and C_i. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i and B_i are not referenced.

@param[in]
AP       device pointer to first matrix A_1
A_i is m by m if side == HIPBLAS_SIDE_LEFT
A_i is n by n if side == HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i. ldb >= max( 1, m )

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, m ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsymmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrk performs one of the matrix-matrix operations for a symmetric rank-k update

C := alpha*op( A )*op( A )^T + beta*C

where  alpha and beta are scalars, op(A) is an n by k matrix, and
C is a symmetric n x n matrix stored as either upper or lower.

op( A ) = A, and A is n by k if transA == HIPBLAS_OP_N
op( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T: op(A) = A^T
HIPBLAS_OP_N: op(A) = A
HIPBLAS_OP_C: op(A) = A^T

HIPBLAS_OP_C is not supported for complex types, see cherk
and zherk.

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasSsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i

where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.

op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T: op(A) = A^T
HIPBLAS_OP_N: op(A) = A
HIPBLAS_OP_C: op(A) = A^T

HIPBLAS_OP_C is not supported for complex types, see cherk
and zherk.

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

C_i := alpha*op( A_i )*op( A_i )^T + beta*C_i

where  alpha and beta are scalars, op(A_i) is an n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.

op( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N
op( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T: op(A) = A^T
HIPBLAS_OP_N: op(A) = A
HIPBLAS_OP_C: op(A) = A^T

HIPBLAS_OP_C is not supported for complex types, see cherk
and zherk.

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if transA = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU. on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syr2k performs one of the matrix-matrix operations for a symmetric rank-2k update

C := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C

where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
C is a symmetric n x n matrix stored as either upper or lower.

op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
HIPBLAS_OP_N:           op( A ) = A, op( B ) = B

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A) and op(B). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).
@param[in]
BP       pointer storing matrix B on the GPU.
Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
only the upper/lower triangular part is accessed.

@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasSsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        BP: *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        BP: *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update

C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).
@param[in]
BP      device array of device pointers storing each matrix_i B of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)
@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).
@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP      device array of device pointers storing each matrix C_i on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        BP: *const *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        BP: *const *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update

C_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyr2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrkx performs one of the matrix-matrix operations for a symmetric rank-k update

C := alpha*op( A )*op( B )^T + beta*C

where  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and
C is a symmetric n x n matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.

op( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N
op( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T
HIPBLAS_OP_N:           op( A ) = A, op( B ) = B

@param[in]
n       [int]
n specifies the number of rows and columns of C. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A) and op(B). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       pointer storing matrix A on the GPU.
Martrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
BP       pointer storing matrix B on the GPU.
Martrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)
only the upper/lower triangular part is accessed.

@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).
*/
    pub fn hipblasSsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        BP: *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        BP: *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       device array of device pointers storing each matrix_i A of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
BP       device array of device pointers storing each matrix_i B of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        BP: *const *const f32,
        ldb: i64,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        BP: *const *const f64,
        ldb: i64,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

syrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update

C_i := alpha*op( A_i )*op( B_i )^T + beta*C_i

where  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and
C_i is a symmetric n x n matrix stored as either upper or lower.
This routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.

op( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N
op( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T
HIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i

@param[in]
n       [int]
n specifies the number of rows and columns of C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of op(A). k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and A need not be set before
entry.

@param[in]
AP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if trans = HIPBLAS_OP_N,  lda >= max( 1, n ),
otherwise lda >= max( 1, k ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)
when trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),
otherwise ldb >= max( 1, k ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       Device pointer to the first matrix C_1 on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, n ).

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSsyrkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched_v2_64(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
geam performs one of the matrix-matrix operations

C = alpha*op( A ) + beta*op( B ),

where op( X ) is one of

op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,

alpha and beta are scalars, and A, B and C are matrices, with
op( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.
@param[in]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
beta      device pointer or host pointer specifying the scalar beta.
@param[in]
BP         device pointer storing matrix B.
@param[in]
ldb       [int]
specifies the leading dimension of B.
@param[in, out]
CP         device pointer storing matrix C.
@param[in]
ldc       [int]
specifies the leading dimension of C.
*/
    pub fn hipblasSgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeam_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        beta: *const f32,
        BP: *const f32,
        ldb: i64,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        beta: *const f64,
        BP: *const f64,
        ldb: i64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: i64,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: i64,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: i64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
geamBatched performs one of the batched matrix-matrix operations

C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1

where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
and op( X ) is one of

op( X ) = X      or
op( X ) = X**T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.
@param[in]
AP         device array of device pointers storing each matrix A_i on the GPU.
Each A_i is of dimension ( lda, k ), where k is m
when  transA == HIPBLAS_OP_N and
is  n  when  transA == HIPBLAS_OP_T.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
beta      device pointer or host pointer specifying the scalar beta.
@param[in]
BP         device array of device pointers storing each matrix B_i on the GPU.
Each B_i is of dimension ( ldb, k ), where k is m
when  transB == HIPBLAS_OP_N and
is  n  when  transB == HIPBLAS_OP_T.
@param[in]
ldb       [int]
specifies the leading dimension of B.
@param[in, out]
CP         device array of device pointers storing each matrix C_i on the GPU.
Each C_i is of dimension ( ldc, n ).
@param[in]
ldc       [int]
specifies the leading dimension of C.

@param[in]
batchCount [int]
number of instances i in the batch.
*/
    pub fn hipblasSgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeamBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        beta: *const f32,
        BP: *const *const f32,
        ldb: i64,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        beta: *const f64,
        BP: *const *const f64,
        ldb: i64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        beta: *const hipblasComplex,
        BP: *const *const hipblasComplex,
        ldb: i64,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        beta: *const hipblasDoubleComplex,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        beta: *const hipComplex,
        BP: *const *const hipComplex,
        ldb: i64,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        beta: *const hipDoubleComplex,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
geamStridedBatched performs one of the batched matrix-matrix operations

C_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1

where alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices
and op( X ) is one of

op( X ) = X      or
op( X ) = X**T

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support


@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A )

@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B )

@param[in]
m         [int]
matrix dimension m.

@param[in]
n         [int]
matrix dimension n.

@param[in]
alpha     device pointer or host pointer specifying the scalar alpha.

@param[in]
AP         device pointer to the first matrix A_0 on the GPU.
Each A_i is of dimension ( lda, k ), where k is m
when  transA == HIPBLAS_OP_N and
is  n  when  transA == HIPBLAS_OP_T.

@param[in]
lda       [int]
specifies the leading dimension of A.

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
beta      device pointer or host pointer specifying the scalar beta.

@param[in]
BP         pointer to the first matrix B_0 on the GPU.
Each B_i is of dimension ( ldb, k ), where k is m
when  transB == HIPBLAS_OP_N and
is  n  when  transB == HIPBLAS_OP_T.

@param[in]
ldb       [int]
specifies the leading dimension of B.

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in, out]
CP         pointer to the first matrix C_0 on the GPU.
Each C_i is of dimension ( ldc, n ).

@param[in]
ldc       [int]
specifies the leading dimension of C.

@param[in]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances i in the batch.
*/
    pub fn hipblasSgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgeamStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f32,
        BP: *const f32,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        beta: *const f64,
        BP: *const f64,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

hemm performs one of the matrix-matrix operations:

C := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,
C := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B and C are m by n matrices, and
A is a Hermitian matrix stored as either upper or lower.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C
HIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix

@param[in]
n       [int]
n specifies the number of rows of B and C. n >= 0.

@param[in]
k       [int]
n specifies the number of columns of B and C. k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A and B are not referenced.

@param[in]
AP       pointer storing matrix A on the GPU.
A is m by m if side == HIPBLAS_SIDE_LEFT
A is n by n if side == HIPBLAS_SIDE_RIGHT
Only the upper/lower triangular part is accessed.
The imaginary component of the diagonal elements is not used.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
BP       pointer storing matrix B on the GPU.
Matrix dimension is m by n

@param[in]
ldb     [int]
ldb specifies the first dimension of B. ldb >= max( 1, m )

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP       pointer storing matrix C on the GPU.
Matrix dimension is m by n

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, m )
*/
    pub fn hipblasChemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

hemmBatched performs a batch of the matrix-matrix operations:

C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B_i and C_i are m by n matrices, and
A_i is a Hermitian matrix stored as either upper or lower.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

@param[in]
n       [int]
n specifies the number of rows of B_i and C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of B_i and C_i. k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i and B_i are not referenced.

@param[in]
AP       device array of device pointers storing each matrix A_i on the GPU.
A_i is m by m if side == HIPBLAS_SIDE_LEFT
A_i is n by n if side == HIPBLAS_SIDE_RIGHT
Only the upper/lower triangular part is accessed.
The imaginary component of the diagonal elements is not used.

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
BP       device array of device pointers storing each matrix B_i on the GPU.
Matrix dimension is m by n

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i. ldb >= max( 1, m )

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C_i need not be set before entry.

@param[in]
CP       device array of device pointers storing each matrix C_i on the GPU.
Matrix dimension is m by n

@param[in]
ldc    [int]
ldc specifies the first dimension of C_i. ldc >= max( 1, m )

@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasChemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *const hipblasComplex,
        ldb: i64,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *const hipblasDoubleComplex,
        ldb: i64,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *const hipComplex,
        ldb: i64,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *const hipDoubleComplex,
        ldb: i64,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

hemmStridedBatched performs a batch of the matrix-matrix operations:

C_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,
C_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,

where alpha and beta are scalars, B_i and C_i are m by n matrices, and
A_i is a Hermitian matrix stored as either upper or lower.

- Supported precisions in rocBLAS : c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side  [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i
HIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix
HIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix

@param[in]
n       [int]
n specifies the number of rows of B_i and C_i. n >= 0.

@param[in]
k       [int]
k specifies the number of columns of B_i and C_i. k >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i and B_i are not referenced.

@param[in]
AP       device pointer to first matrix A_1
A_i is m by m if side == HIPBLAS_SIDE_LEFT
A_i is n by n if side == HIPBLAS_SIDE_RIGHT
Only the upper/lower triangular part is accessed.
The imaginary component of the diagonal elements is not used.

@param[in]
lda     [int]
lda specifies the first dimension of A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
otherwise lda >= max( 1, n ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[in]
BP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU

@param[in]
ldb     [int]
ldb specifies the first dimension of B_i.
if side = HIPBLAS_OP_N,  ldb >= max( 1, m ),
otherwise ldb >= max( 1, n ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
beta
beta specifies the scalar beta. When beta is
zero then C need not be set before entry.

@param[in]
CP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.

@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, m )

@param[inout]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances in the batch
*/
    pub fn hipblasChemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: i64,
        k: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

trmm performs one of the matrix-matrix operations

C := alpha*op( A )*B,   or   C := alpha*B*op( A )

where  alpha  is a scalar, B and C are an m by n matrices,  A  is a unit, or
non-unit,  upper or lower triangular matrix  and  op( A )  is one  of

op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

Note that trmm can provide in-place functionality by passing in the same address for both
matrices B and C and by setting ldb equal to ldc.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
Specifies whether op(A) multiplies B from the left or right as follows:
HIPBLAS_SIDE_LEFT:       C := alpha*op( A )*B.
HIPBLAS_SIDE_RIGHT:      C := alpha*B*op( A ).

@param[in]
uplo    [hipblasFillMode_t]
Specifies whether the matrix A is an upper or lower triangular matrix as follows:
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
Specifies the form of op(A) to be used in the matrix multiplication as follows:
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.

@param[in]
diag    [hipblasDiagType_t]
Specifies whether or not A is unit triangular as follows:
HIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of B and C. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B and C. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A is not referenced and B need not be set before
entry.

@param[in]
A       Device pointer to matrix A on the GPU.
A has dimension ( lda, k ), where k is m
when  side == HIPBLAS_SIDE_LEFT  and
is  n  when  side == HIPBLAS_SIDE_RIGHT.

When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
upper triangular part of the array  A must contain the upper
triangular matrix  and the strictly lower triangular part of
A is not referenced.

When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
lower triangular part of the array  A must contain the lower
triangular matrix  and the strictly upper triangular part of
A is not referenced.

Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
A  are not referenced either,  but are assumed to be  unity.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[inout]
B       Device pointer to the matrix B of dimension (ldb, n) on the GPU.

@param[in]
ldb    [int]
ldb specifies the first dimension of B. ldb >= max( 1, m ).

@param[in]
C      Device pointer to the matrix C of dimension (ldc, n) on the GPU.
Users can pass in the same matrix B to parameter C to achieve
in-place functionality of trmm.
@param[in]
ldc    [int]
ldc specifies the first dimension of C. ldc >= max( 1, m ).
*/
    pub fn hipblasStrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::core::ffi::c_int,
        B: *const f32,
        ldb: ::core::ffi::c_int,
        C: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::core::ffi::c_int,
        B: *const f64,
        ldb: ::core::ffi::c_int,
        C: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::core::ffi::c_int,
        B: *const hipComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        B: *const f32,
        ldb: i64,
        C: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        B: *const f64,
        ldb: i64,
        C: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: i64,
        B: *const hipblasComplex,
        ldb: i64,
        C: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: i64,
        B: *const hipblasDoubleComplex,
        ldb: i64,
        C: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: i64,
        B: *const hipComplex,
        ldb: i64,
        C: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: i64,
        B: *const hipDoubleComplex,
        ldb: i64,
        C: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

trmmBatched performs one of the batched matrix-matrix operations

C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1

where alpha is a scalar, B_i and C_i are m by n matrices, A_i is a unit, or
non-unit, upper or lower triangular matrix and op( A_i ) is one of

op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

Note that trmmBatched can provide in-place functionality by passing in the same address for both
matrices B and C and by setting ldb equal to ldc.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
Specifies whether op(A_i) multiplies B_i from the left or right as follows:
HIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.
HIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).

@param[in]
uplo    [hipblasFillMode_t]
Specifies whether the matrix A is an upper or lower triangular matrix as follows:
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
HIPBLAS_OP_N:  op(A_i) = A_i.
HIPBLAS_OP_T:  op(A_i) = A_i^T.
HIPBLAS_OP_C:  op(A_i) = A_i^H.

@param[in]
diag    [hipblasDiagType_t]
Specifies whether or not A_i is unit triangular as follows:
HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of B_i and C_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B_i and C_i. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i is not referenced and B_i need not be set before
entry.

@param[in]
A       Device array of device pointers storing each matrix A_i on the GPU.
Each A_i is of dimension ( lda, k ), where k is m
when  side == HIPBLAS_SIDE_LEFT  and
is  n  when  side == HIPBLAS_SIDE_RIGHT.

When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
upper triangular part of the array  A must contain the upper
triangular matrix  and the strictly lower triangular part of
A is not referenced.

When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
lower triangular part of the array  A must contain the lower
triangular matrix  and the strictly upper triangular part of
A is not referenced.

Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
A_i  are not referenced either,  but are assumed to be  unity.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[inout]
B       device array of device pointers storing each matrix B_i of
dimension (ldb, n) on the GPU.

@param[in]
ldb    [int]
ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

@param[in]
C      device array of device pointers storing each matrix C_i of
dimension (ldc, n) on the GPU. Users can pass in the same
matrices B to parameter C to achieve in-place functionality of trmmBatched.

@param[in]
ldc    lec specifies the first dimension of C_i. ldc >= max( 1, m ).

@param[in]
batchCount [int]
number of instances i in the batch.*/
    pub fn hipblasStrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::core::ffi::c_int,
        B: *const *const f32,
        ldb: ::core::ffi::c_int,
        C: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::core::ffi::c_int,
        B: *const *const f64,
        ldb: ::core::ffi::c_int,
        C: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const *const f32,
        lda: i64,
        B: *const *const f32,
        ldb: i64,
        C: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const *const f64,
        lda: i64,
        B: *const *const f64,
        ldb: i64,
        C: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: i64,
        B: *const *const hipblasComplex,
        ldb: i64,
        C: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: i64,
        B: *const *const hipblasDoubleComplex,
        ldb: i64,
        C: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        A: *const *const hipComplex,
        lda: i64,
        B: *const *const hipComplex,
        ldb: i64,
        C: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        A: *const *const hipDoubleComplex,
        lda: i64,
        B: *const *const hipDoubleComplex,
        ldb: i64,
        C: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

trmmStridedBatched performs one of the strided_batched matrix-matrix operations

C_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1

where alpha is a scalar,  B_i and C_i are m by n matrices, A_i is a unit, or
non-unit, upper or lower triangular matrix and op( A_i ) is one of

op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

Note that trmmStridedBatched can provide in-place functionality by passing
in the same address for both matrices B and C and by setting ldb equal to ldc.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
Specifies whether op(A_i) multiplies B_i from the left or right as follows:
HIPBLAS_SIDE_LEFT:       C_i := alpha*op( A_i )*B_i.
HIPBLAS_SIDE_RIGHT:      C_i := alpha*B_i*op( A_i ).

@param[in]
uplo    [hipblasFillMode_t]
Specifies whether the matrix A is an upper or lower triangular matrix as follows:
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
Specifies the form of op(A_i) to be used in the matrix multiplication as follows:
HIPBLAS_OP_N:  op(A_i) = A_i.
HIPBLAS_OP_T:  op(A_i) = A_i^T.
HIPBLAS_OP_C:  op(A_i) = A_i^H.

@param[in]
diag    [hipblasDiagType_t]
Specifies whether or not A_i is unit triangular as follows:
HIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of B_i and C_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B_i and C_i. n >= 0.

@param[in]
alpha
alpha specifies the scalar alpha. When alpha is
zero then A_i is not referenced and B_i need not be set before
entry.

@param[in]
A       Device pointer to the first matrix A_0 on the GPU.
Each A_i is of dimension ( lda, k ), where k is m
when  side == HIPBLAS_SIDE_LEFT  and
is  n  when  side == HIPBLAS_SIDE_RIGHT.

When uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k
upper triangular part of the array  A must contain the upper
triangular matrix  and the strictly lower triangular part of
A is not referenced.

When uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k
lower triangular part of the array  A must contain the lower
triangular matrix  and the strictly upper triangular part of
A is not referenced.

Note that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of
A_i  are not referenced either,  but are assumed to be  unity.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)

@param[inout]
B      Device pointer to the first matrix B_0 on the GPU. Each B_i is of
dimension ( ldb, n )

@param[in]
ldb    [int]
ldb specifies the first dimension of B_i. ldb >= max( 1, m ).

@param[in]
strideB  [hipblasStride]
stride from the start of one matrix (B_i) and the next one (B_i+1)

@param[in]
C      Device pointer to the first matrix C_0 on the GPU. Each C_i is of
dimension ( ldc, n ).

@param[in]
ldc    [int]
ldc specifies the first dimension of C_i. ldc >= max( 1, m ).

@param[in]
strideC [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)

@param[in]
batchCount [int]
number of instances i in the batch.*/
    pub fn hipblasStrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        A: *const f32,
        lda: i64,
        strideA: hipblasStride,
        B: *const f32,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        A: *const f64,
        lda: i64,
        strideA: hipblasStride,
        B: *const f64,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        B: *const hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        B: *const hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        B: *const hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        B: *const hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        C: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details

trsm solves

op(A)*X = alpha*B or  X*op(A) = alpha*B,

where alpha is a scalar, X and B are m by n matrices,
A is triangular matrix and op(A) is one of

op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

The matrix X is overwritten on B.

Note about memory allocation:
When trsm is launched with a k evenly divisible by the internal block size of 128,
and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
memory found in the handle to increase overall performance. This memory can be managed by using
the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
used for temporary storage will default to 1 MB and may result in chunking, which in turn may
reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
to the desired chunk of right hand sides to be used at a time.

(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of B. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B. n >= 0.

@param[in]
alpha
device pointer or host pointer specifying the scalar alpha. When alpha is
&zero then A is not referenced and B need not be set before
entry.

@param[in]
AP       device pointer storing matrix A.
of dimension ( lda, k ), where k is m
when  HIPBLAS_SIDE_LEFT  and
is  n  when  HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[in,out]
BP       device pointer storing matrix B.

@param[in]
ldb    [int]
ldb specifies the first dimension of B. ldb >= max( 1, m ).
*/
    pub fn hipblasStrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *mut f32,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *mut f64,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        BP: *mut f32,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        BP: *mut f64,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        BP: *mut hipblasComplex,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        BP: *mut hipblasDoubleComplex,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        BP: *mut hipComplex,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        BP: *mut hipDoubleComplex,
        ldb: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API
\details
trsmBatched performs the following batched operation:

op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.

where alpha is a scalar, X and B are batched m by n matrices,
A is triangular batched matrix and op(A) is one of

op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.

Note about memory allocation:
When trsm is launched with a k evenly divisible by the internal block size of 128,
and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
memory found in the handle to increase overall performance. This memory can be managed by using
the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
used for temporary storage will default to 1 MB and may result in chunking, which in turn may
reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
to the desired chunk of right hand sides to be used at a time.
(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.
@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.
@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
@param[in]
m       [int]
m specifies the number of rows of each B_i. m >= 0.
@param[in]
n       [int]
n specifies the number of columns of each B_i. n >= 0.
@param[in]
alpha
device pointer or host pointer specifying the scalar alpha. When alpha is
&zero then A is not referenced and B need not be set before
entry.
@param[in]
AP       device array of device pointers storing each matrix A_i on the GPU.
Matricies are of dimension ( lda, k ), where k is m
when  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.
@param[in]
lda     [int]
lda specifies the first dimension of each A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
@param[in,out]
BP       device array of device pointers storing each matrix B_i on the GPU.
@param[in]
ldb    [int]
ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
@param[in]
batchCount [int]
number of trsm operatons in the batch.*/
    pub fn hipblasStrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *mut f32,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *mut f64,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const *const f32,
        lda: i64,
        BP: *const *mut f32,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const *const f64,
        lda: i64,
        BP: *const *mut f64,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: i64,
        BP: *const *mut hipblasComplex,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        BP: *const *mut hipblasDoubleComplex,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: i64,
        BP: *const *mut hipComplex,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        BP: *const *mut hipDoubleComplex,
        ldb: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API
\details
trsmSridedBatched performs the following strided batched operation:

op(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.

where alpha is a scalar, X and B are strided batched m by n matrices,
A is triangular strided batched matrix and op(A) is one of

op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

Each matrix X_i is overwritten on B_i for i = 1, ..., batchCount.

Note about memory allocation:
When trsm is launched with a k evenly divisible by the internal block size of 128,
and is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated
memory found in the handle to increase overall performance. This memory can be managed by using
the environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory
used for temporary storage will default to 1 MB and may result in chunking, which in turn may
reduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set
to the desired chunk of right hand sides to be used at a time.
(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.
@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.
@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.
@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.
@param[in]
m       [int]
m specifies the number of rows of each B_i. m >= 0.
@param[in]
n       [int]
n specifies the number of columns of each B_i. n >= 0.
@param[in]
alpha
device pointer or host pointer specifying the scalar alpha. When alpha is
&zero then A is not referenced and B need not be set before
entry.
@param[in]
AP       device pointer pointing to the first matrix A_1.
of dimension ( lda, k ), where k is m
when  HIPBLAS_SIDE_LEFT  and
is  n  when  HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.
@param[in]
lda     [int]
lda specifies the first dimension of each A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).
@param[in]
strideA [hipblasStride]
stride from the start of one A_i matrix to the next A_(i + 1).
@param[in,out]
BP       device pointer pointing to the first matrix B_1.
@param[in]
ldb    [int]
ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).
@param[in]
strideB [hipblasStride]
stride from the start of one B_i matrix to the next B_(i + 1).
@param[in]
batchCount [int]
number of trsm operatons in the batch.*/
    pub fn hipblasStrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasStrsmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f32,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut f32,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const f64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut f64,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut hipblasComplex,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut hipblasDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut hipComplex,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: i64,
        n: i64,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        BP: *mut hipDoubleComplex,
        ldb: i64,
        strideB: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
trtri  compute the inverse of a matrix A, namely, invA

and write the result into invA;

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
if HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced
if HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced
@param[in]
diag      [hipblasDiagType_t]
= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
= 'HIPBLAS_DIAG_UNIT', A is unit triangular;
@param[in]
n         [int]
size of matrix A and invA
@param[in]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[out]
invA      device pointer storing matrix invA.
@param[in]
ldinvA    [int]
specifies the leading dimension of invA.*/
    pub fn hipblasStrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        invA: *mut f32,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        invA: *mut f64,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
trtriBatched  compute the inverse of A_i and write into invA_i where
A_i and invA_i are the i-th matrices in the batch,
for i = 1, ..., batchCount.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
@param[in]
diag      [hipblasDiagType_t]
= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
= 'HIPBLAS_DIAG_UNIT', A is unit triangular;
@param[in]
n         [int]
@param[in]
AP         device array of device pointers storing each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[out]
invA      device array of device pointers storing the inverse of each matrix A_i.
Partial inplace operation is supported, see below.
If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
the inverse of the upper triangular matrix, and the strictly lower
triangular part of invA is cleared.
If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
the inverse of the lower triangular matrix, and the strictly upper
triangular part of invA is cleared.
@param[in]
ldinvA    [int]
specifies the leading dimension of each invA_i.
@param[in]
batchCount [int]
numbers of matrices in the batch*/
    pub fn hipblasStrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        invA: *mut *mut f32,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        invA: *mut *mut f64,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
trtriStridedBatched compute the inverse of A_i and write into invA_i where
A_i and invA_i are the i-th matrices in the batch,
for i = 1, ..., batchCount

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
uplo      [hipblasFillMode_t]
specifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'
@param[in]
diag      [hipblasDiagType_t]
= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;
= 'HIPBLAS_DIAG_UNIT', A is unit triangular;
@param[in]
n         [int]
@param[in]
AP         device pointer pointing to address of first matrix A_1.
@param[in]
lda       [int]
specifies the leading dimension of each A.
@param[in]
strideA  [hipblasStride]
"batch stride a": stride from the start of one A_i matrix to the next A_(i + 1).
@param[out]
invA      device pointer storing the inverses of each matrix A_i.
Partial inplace operation is supported, see below.
If UPLO = 'U', the leading N-by-N upper triangular part of the invA will store
the inverse of the upper triangular matrix, and the strictly lower
triangular part of invA is cleared.
If UPLO = 'L', the leading N-by-N lower triangular part of the invA will store
the inverse of the lower triangular matrix, and the strictly upper
triangular part of invA is cleared.
@param[in]
ldinvA    [int]
specifies the leading dimension of each invA_i.
@param[in]
stride_invA  [hipblasStride]
"batch stride invA": stride from the start of one invA_i matrix to the next invA_(i + 1).
@param[in]
batchCount  [int]
numbers of matrices in the batch*/
    pub fn hipblasStrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut f32,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut f64,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
dgmm performs one of the matrix-matrix operations

C = A * diag(x) if side == HIPBLAS_SIDE_RIGHT
C = diag(x) * A if side == HIPBLAS_SIDE_LEFT

where C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix
and x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
if side == HIPBLAS_SIDE_LEFT.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : s,d,c,z

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
side      [hipblasSideMode_t]
specifies the side of diag(x)
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
AP         device pointer storing matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
x         device pointer storing vector x.
@param[in]
incx      [int]
specifies the increment between values of x
@param[in, out]
CP         device pointer storing matrix C.
@param[in]
ldc       [int]
specifies the leading dimension of C.
*/
    pub fn hipblasSdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdgmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const f32,
        lda: i64,
        x: *const f32,
        incx: i64,
        CP: *mut f32,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const f64,
        lda: i64,
        x: *const f64,
        incx: i64,
        CP: *mut f64,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        x: *const hipblasComplex,
        incx: i64,
        CP: *mut hipblasComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        x: *const hipblasDoubleComplex,
        incx: i64,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        x: *const hipComplex,
        incx: i64,
        CP: *mut hipComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        x: *const hipDoubleComplex,
        incx: i64,
        CP: *mut hipDoubleComplex,
        ldc: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
dgmmBatched performs one of the batched matrix-matrix operations

C_i = A_i * diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT
C_i = diag(x_i) * A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT

where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
if side == HIPBLAS_SIDE_LEFT.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
side      [hipblasSideMode_t]
specifies the side of diag(x)
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
AP         device array of device pointers storing each matrix A_i on the GPU.
Each A_i is of dimension ( lda, n )
@param[in]
lda       [int]
specifies the leading dimension of A_i.
@param[in]
x         device array of device pointers storing each vector x_i on the GPU.
Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
m if side == HIPBLAS_SIDE_LEFT
@param[in]
incx      [int]
specifies the increment between values of x_i
@param[in, out]
CP         device array of device pointers storing each matrix C_i on the GPU.
Each C_i is of dimension ( ldc, n ).
@param[in]
ldc       [int]
specifies the leading dimension of C_i.
@param[in]
batchCount [int]
number of instances in the batch.
*/
    pub fn hipblasSdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdgmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const f32,
        lda: i64,
        x: *const *const f32,
        incx: i64,
        CP: *const *mut f32,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const f64,
        lda: i64,
        x: *const *const f64,
        incx: i64,
        CP: *const *mut f64,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const hipblasComplex,
        lda: i64,
        x: *const *const hipblasComplex,
        incx: i64,
        CP: *const *mut hipblasComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const hipblasDoubleComplex,
        lda: i64,
        x: *const *const hipblasDoubleComplex,
        incx: i64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const hipComplex,
        lda: i64,
        x: *const *const hipComplex,
        incx: i64,
        CP: *const *mut hipComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const *const hipDoubleComplex,
        lda: i64,
        x: *const *const hipDoubleComplex,
        incx: i64,
        CP: *const *mut hipDoubleComplex,
        ldc: i64,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS Level 3 API

\details
dgmmStridedBatched performs one of the batched matrix-matrix operations

C_i = A_i * diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1
C_i = diag(x_i) * A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1

where C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix
and x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m
if side == HIPBLAS_SIDE_LEFT.

- Supported precisions in rocBLAS : s,d,c,z
- Supported precisions in cuBLAS  : No support

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
side      [hipblasSideMode_t]
specifies the side of diag(x)
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
AP         device pointer to the first matrix A_0 on the GPU.
Each A_i is of dimension ( lda, n )
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
strideA  [hipblasStride]
stride from the start of one matrix (A_i) and the next one (A_i+1)
@param[in]
x         pointer to the first vector x_0 on the GPU.
Each x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension
m if side == HIPBLAS_SIDE_LEFT
@param[in]
incx      [int]
specifies the increment between values of x
@param[in]
stridex  [hipblasStride]
stride from the start of one vector(x_i) and the next one (x_i+1)
@param[in, out]
CP         device pointer to the first matrix C_0 on the GPU.
Each C_i is of dimension ( ldc, n ).
@param[in]
ldc       [int]
specifies the leading dimension of C.
@param[in]
strideC  [hipblasStride]
stride from the start of one matrix (C_i) and the next one (C_i+1)
@param[in]
batchCount [int]
number of instances i in the batch.
*/
    pub fn hipblasSdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdgmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const f32,
        lda: i64,
        strideA: hipblasStride,
        x: *const f32,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut f32,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const f64,
        lda: i64,
        strideA: hipblasStride,
        x: *const f64,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut f64,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipblasComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipblasDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut hipComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched_v2_64(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: i64,
        n: i64,
        AP: *const hipDoubleComplex,
        lda: i64,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: i64,
        stridex: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getrf computes the LU factorization of a general n-by-n matrix A
using partial pivoting with row interchanges. The LU factorization can
be done without pivoting if ipiv is passed as a nullptr.

In the case that ipiv is not null, the factorization has the form:

\f[
A = PLU
\f]

where P is a permutation matrix, L is lower triangular with unit
diagonal elements, and U is upper triangular.

In the case that ipiv is null, the factorization is done without pivoting:

\f[
A = LU
\f]

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
n         int. n >= 0.\n
The number of columns and rows of the matrix A.
@param[inout]
A         pointer to type. Array on the GPU of dimension lda*n.\n
On entry, the n-by-n matrix A to be factored.
On exit, the factors L and U from the factorization.
The unit diagonal elements of L are not stored.
@param[in]
lda       int. lda >= n.\n
Specifies the leading dimension of A.
@param[out]
ipiv      pointer to int. Array on the GPU of dimension n.\n
The vector of pivot indices. Elements of ipiv are 1-based indices.
For 1 <= i <= n, the row i of the
matrix was interchanged with row ipiv[i].
Matrix P of the factorization can be derived from ipiv.
The factorization here can be done without pivoting if ipiv is passed
in as a nullptr.
@param[out]
info      pointer to a int on the GPU.\n
If info = 0, successful exit.
If info = j > 0, U is singular. U[j,j] is the first zero pivot.*/
    pub fn hipblasSgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getrfBatched computes the LU factorization of a batch of general
n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
be done without pivoting if ipiv is passed as a nullptr.

In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:

\f[
A_i = P_iL_iU_i
\f]

where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
diagonal elements, and \f$U_i\f$ is upper triangular.

In the case that ipiv is null, the factorization is done without pivoting:

\f[
A_i = L_iU_i
\f]

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
n         int. n >= 0.\n
The number of columns and rows of all matrices A_i in the batch.
@param[inout]
A         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
On entry, the n-by-n matrices A_i to be factored.
On exit, the factors L_i and U_i from the factorizations.
The unit diagonal elements of L_i are not stored.
@param[in]
lda       int. lda >= n.\n
Specifies the leading dimension of matrices A_i.
@param[out]
ipiv      pointer to int. Array on the GPU.\n
Contains the vectors of pivot indices ipiv_i (corresponding to A_i).
Dimension of ipiv_i is n.
Elements of ipiv_i are 1-based indices.
For each instance A_i in the batch and for 1 <= j <= n, the row j of the
matrix A_i was interchanged with row ipiv_i[j].
Matrix P_i of the factorization can be derived from ipiv_i.
The factorization here can be done without pivoting if ipiv is passed
in as a nullptr.
@param[out]
info      pointer to int. Array of batchCount integers on the GPU.\n
If info[i] = 0, successful exit for factorization of A_i.
If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
@param[in]
batchCount int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getrfStridedBatched computes the LU factorization of a batch of
general n-by-n matrices using partial pivoting with row interchanges. The LU factorization can
be done without pivoting if ipiv is passed as a nullptr.

In the case that ipiv is not null, the factorization of matrix \f$A_i\f$ in the batch has the form:

\f[
A_i = P_iL_iU_i
\f]

where \f$P_i\f$ is a permutation matrix, \f$L_i\f$ is lower triangular with unit
diagonal elements, and \f$U_i\f$ is upper triangular.

In the case that ipiv is null, the factorization is done without pivoting:

\f[
A_i = L_iU_i
\f]

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
n         int. n >= 0.\n
The number of columns and rows of all matrices A_i in the batch.
@param[inout]
A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
On entry, the n-by-n matrices A_i to be factored.
On exit, the factors L_i and U_i from the factorization.
The unit diagonal elements of L_i are not stored.
@param[in]
lda       int. lda >= n.\n
Specifies the leading dimension of matrices A_i.
@param[in]
strideA   hipblasStride.\n
Stride from the start of one matrix A_i to the next one A_(i+1).
There is no restriction for the value of strideA. Normal use case is strideA >= lda*n
@param[out]
ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
Contains the vectors of pivots indices ipiv_i (corresponding to A_i).
Dimension of ipiv_i is n.
Elements of ipiv_i are 1-based indices.
For each instance A_i in the batch and for 1 <= j <= n, the row j of the
matrix A_i was interchanged with row ipiv_i[j].
Matrix P_i of the factorization can be derived from ipiv_i.
The factorization here can be done without pivoting if ipiv is passed
in as a nullptr.
@param[in]
strideP   hipblasStride.\n
Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
There is no restriction for the value of strideP. Normal use case is strideP >= n.
@param[out]
info      pointer to int. Array of batchCount integers on the GPU.\n
If info[i] = 0, successful exit for factorization of A_i.
If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
@param[in]
batchCount int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getrs solves a system of n linear equations on n variables in its factorized form.

It solves one of the following systems, depending on the value of trans:

\f[
\begin{array}{cl}
A X = B & \: \text{not transposed,}\\
A^T X = B & \: \text{transposed, or}\\
A^H X = B & \: \text{conjugate transposed.}
\end{array}
\f]

Matrix A is defined by its triangular factors as returned by \ref hipblasSgetrf "getrf".

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z


@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations.
@param[in]
n           int. n >= 0.\n
The order of the system, i.e. the number of columns and rows of A.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of right hand sides, i.e., the number of columns
of the matrix B.
@param[in]
A           pointer to type. Array on the GPU of dimension lda*n.\n
The factors L and U of the factorization A = P*L*U returned by \ref hipblasSgetrf "getrf".
@param[in]
lda         int. lda >= n.\n
The leading dimension of A.
@param[in]
ipiv        pointer to int. Array on the GPU of dimension n.\n
The pivot indices returned by \ref hipblasSgetrf "getrf".
@param[in,out]
B           pointer to type. Array on the GPU of dimension ldb*nrhs.\n
On entry, the right hand side matrix B.
On exit, the solution matrix X.
@param[in]
ldb         int. ldb >= n.\n
The leading dimension of B.
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.*/
    pub fn hipblasSgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details getrsBatched solves a batch of systems of n linear equations on n
variables in its factorized forms.

For each instance i in the batch, it solves one of the following systems, depending on the value of trans:

\f[
\begin{array}{cl}
A_i X_i = B_i & \: \text{not transposed,}\\
A_i^T X_i = B_i & \: \text{transposed, or}\\
A_i^H X_i = B_i & \: \text{conjugate transposed.}
\end{array}
\f]

Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfBatched "getrfBatched".

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations of each instance in the batch.
@param[in]
n           int. n >= 0.\n
The order of the system, i.e. the number of columns and rows of all A_i matrices.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of right hand sides, i.e., the number of columns
of all the matrices B_i.
@param[in]
A           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfBatched "getrfBatched".
@param[in]
lda         int. lda >= n.\n
The leading dimension of matrices A_i.
@param[in]
ipiv        pointer to int. Array on the GPU.\n
Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
@param[in,out]
B           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\n
On entry, the right hand side matrices B_i.
On exit, the solution matrix X_i of each system in the batch.
@param[in]
ldb         int. ldb >= n.\n
The leading dimension of matrices B_i.
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[in]
batchCount int. batchCount >= 0.\n
Number of instances (systems) in the batch.
*/
    pub fn hipblasSgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getrsStridedBatched solves a batch of systems of n linear equations
on n variables in its factorized forms.

For each instance i in the batch, it solves one of the following systems, depending on the value of trans:

\f[
\begin{array}{cl}
A_i X_i = B_i & \: \text{not transposed,}\\
A_i^T X_i = B_i & \: \text{transposed, or}\\
A_i^H X_i = B_i & \: \text{conjugate transposed.}
\end{array}
\f]

Matrix \f$A_i\f$ is defined by its triangular factors as returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : No support

@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations of each instance in the batch.
@param[in]
n           int. n >= 0.\n
The order of the system, i.e. the number of columns and rows of all A_i matrices.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of right hand sides, i.e., the number of columns
of all the matrices B_i.
@param[in]
A           pointer to type. Array on the GPU (the size depends on the value of strideA).\n
The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
@param[in]
lda         int. lda >= n.\n
The leading dimension of matrices A_i.
@param[in]
strideA     hipblasStride.\n
Stride from the start of one matrix A_i to the next one A_(i+1).
There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.
@param[in]
ipiv        pointer to int. Array on the GPU (the size depends on the value of strideP).\n
Contains the vectors ipiv_i of pivot indices returned by \ref hipblasSgetrfStridedBatched "getrfStridedBatched".
@param[in]
strideP     hipblasStride.\n
Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
There is no restriction for the value of strideP. Normal use case is strideP >= n.
@param[in,out]
B           pointer to type. Array on the GPU (size depends on the value of strideB).\n
On entry, the right hand side matrices B_i.
On exit, the solution matrix X_i of each system in the batch.
@param[in]
ldb         int. ldb >= n.\n
The leading dimension of matrices B_i.
@param[in]
strideB     hipblasStride.\n
Stride from the start of one matrix B_i to the next one B_(i+1).
There is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[in]
batchCount int. batchCount >= 0.\n
Number of instances (systems) in the batch.
*/
    pub fn hipblasSgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
getriBatched computes the inverse \f$C_i = A_i^{-1}\f$ of a batch of general n-by-n matrices \f$A_i\f$.

The inverse is computed by solving the linear system

\f[
A_i C_i = I
\f]

where I is the identity matrix, and \f$A_i\f$ is factorized as \f$A_i = P_i  L_i  U_i\f$ as given by \ref hipblasSgetrfBatched "getrfBatched".

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
n         int. n >= 0.\n
The number of rows and columns of all matrices A_i in the batch.
@param[in]
A         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
The factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \ref hipblasSgetrfBatched "getrfBatched".
@param[in]
lda       int. lda >= n.\n
Specifies the leading dimension of matrices A_i.
@param[in]
ipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\n
The pivot indices returned by \ref hipblasSgetrfBatched "getrfBatched".
ipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.
@param[out]
C         array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\n
If info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.
@param[in]
ldc       int. ldc >= n.\n
Specifies the leading dimension of C_i.
@param[out]
info      pointer to int. Array of batchCount integers on the GPU.\n
If info[i] = 0, successful exit for inversion of A_i.
If info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.
@param[in]
batchCount int. batchCount >= 0.\n
Number of matrices in the batch.
*/
    pub fn hipblasSgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut f32,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut f64,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n
matrix A, and a corresponding matrix B, using the QR factorization computed by \ref hipblasSgeqrf "GEQRF" (or the LQ
factorization computed by "GELQF").

\details
Depending on the value of trans, the problem solved by this function is either of the form

\f[
\begin{array}{cl}
A X = B & \: \text{not transposed, or}\\
A' X = B & \: \text{transposed if real, or conjugate transposed if complex}
\end{array}
\f]

If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
and a least-squares solution approximating X is found by minimizing

\f[
|| B - A  X || \quad \text{(or} \: || B - A' X ||\text{)}
\f]

If m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined
and a unique solution for X is chosen such that \f$|| X ||\f$ is minimal.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : currently unsupported

@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations.
@param[in]
m           int. m >= 0.\n
The number of rows of matrix A.
@param[in]
n           int. n >= 0.\n
The number of columns of matrix A.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of columns of matrices B and X;
i.e., the columns on the right hand side.
@param[inout]
A           pointer to type. Array on the GPU of dimension lda*n.\n
On entry, the matrix A.
On exit, the QR (or LQ) factorization of A as returned by "GEQRF" (or "GELQF").
@param[in]
lda         int. lda >= m.\n
Specifies the leading dimension of matrix A.
@param[inout]
B           pointer to type. Array on the GPU of dimension ldb*nrhs.\n
On entry, the matrix B.
On exit, when info = 0, B is overwritten by the solution vectors (and the residuals in
the overdetermined cases) stored as columns.
@param[in]
ldb         int. ldb >= max(m,n).\n
Specifies the leading dimension of matrix B.
@param[out]
info        pointer to an int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[out]
deviceInfo  pointer to int on the GPU.\n
If info = 0, successful exit.
If info = i > 0, the solution could not be computed because input matrix A is
rank deficient; the i-th diagonal element of its triangular factor is zero.*/
    pub fn hipblasSgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief gelsBatched solves a batch of overdetermined (or underdetermined) linear systems
defined by a set of m-by-n matrices \f$A_j\f$, and corresponding matrices \f$B_j\f$, using the
QR factorizations computed by "GEQRF_BATCHED" (or the LQ factorizations computed by "GELQF_BATCHED").

\details
For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form

\f[
\begin{array}{cl}
A_j X_j = B_j & \: \text{not transposed, or}\\
A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
\end{array}
\f]

If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
and a least-squares solution approximating X_j is found by minimizing

\f[
|| B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}
\f]

If m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined
and a unique solution for X_j is chosen such that \f$|| X_j ||\f$ is minimal.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z
Note that cuBLAS backend supports only the non-transpose operation and only solves over-determined systems (m >= n).

@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations.
@param[in]
m           int. m >= 0.\n
The number of rows of all matrices A_j in the batch.
@param[in]
n           int. n >= 0.\n
The number of columns of all matrices A_j in the batch.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of columns of all matrices B_j and X_j in the batch;
i.e., the columns on the right hand side.
@param[inout]
A           array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.\n
On entry, the matrices A_j.
On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_BATCHED"
(or "GELQF_BATCHED").
@param[in]
lda         int. lda >= m.\n
Specifies the leading dimension of matrices A_j.
@param[inout]
B           array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\n
On entry, the matrices B_j.
On exit, when info[j] = 0, B_j is overwritten by the solution vectors (and the residuals in
the overdetermined cases) stored as columns.
@param[in]
ldb         int. ldb >= max(m,n).\n
Specifies the leading dimension of matrices B_j.
@param[out]
info        pointer to an int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[out]
deviceInfo  pointer to int. Array of batchCount integers on the GPU.\n
If deviceInfo[j] = 0, successful exit for solution of A_j.
If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.
@param[in]
batchCount  int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        B: *const *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        B: *const *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief gelsStridedBatched solves a batch of overdetermined (or underdetermined) linear
systems defined by a set of m-by-n matrices \f$A_j\f$, and corresponding matrices \f$B_j\f$,
using the QR factorizations computed by "GEQRF_STRIDED_BATCHED"
(or the LQ factorizations computed by "GELQF_STRIDED_BATCHED").

\details
For each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form

\f[
\begin{array}{cl}
A_j X_j = B_j & \: \text{not transposed, or}\\
A_j' X_j = B_j & \: \text{transposed if real, or conjugate transposed if complex}
\end{array}
\f]

If m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined
and a least-squares solution approximating X_j is found by minimizing

\f[
|| B_j - A_j  X_j || \quad \text{(or} \: || B_j - A_j' X_j ||\text{)}
\f]

If m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined
and a unique solution for X_j is chosen such that \f$|| X_j ||\f$ is minimal.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : currently unsupported

@param[in]
handle      hipblasHandle_t.
@param[in]
trans       hipblasOperation_t.\n
Specifies the form of the system of equations.
@param[in]
m           int. m >= 0.\n
The number of rows of all matrices A_j in the batch.
@param[in]
n           int. n >= 0.\n
The number of columns of all matrices A_j in the batch.
@param[in]
nrhs        int. nrhs >= 0.\n
The number of columns of all matrices B_j and X_j in the batch;
i.e., the columns on the right hand side.
@param[inout]
A           pointer to type. Array on the GPU (the size depends on the value of strideA).\n
On entry, the matrices A_j.
On exit, the QR (or LQ) factorizations of A_j as returned by "GEQRF_STRIDED_BATCHED"
(or "GELQF_STRIDED_BATCHED").
@param[in]
lda         int. lda >= m.\n
Specifies the leading dimension of matrices A_j.
@param[in]
strideA     hipblasStride.\n
Stride from the start of one matrix A_j to the next one A_(j+1).
There is no restriction for the value of strideA. Normal use case is strideA >= lda*n
@param[inout]
B           pointer to type. Array on the GPU (the size depends on the value of strideB).\n
On entry, the matrices B_j.
On exit, when info[j] = 0, each B_j is overwritten by the solution vectors (and the residuals in
the overdetermined cases) stored as columns.
@param[in]
ldb         int. ldb >= max(m,n).\n
Specifies the leading dimension of matrices B_j.
@param[in]
strideB     hipblasStride.\n
Stride from the start of one matrix B_j to the next one B_(j+1).
There is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs
@param[out]
info        pointer to an int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[out]
deviceInfo  pointer to int. Array of batchCount integers on the GPU.\n
If deviceInfo[j] = 0, successful exit for solution of A_j.
If deviceInfo[j] = i > 0, the solution of A_j could not be computed because input
matrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.
@param[in]
batchCount  int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
geqrf computes a QR factorization of a general m-by-n matrix A.

The factorization has the form

\f[
A = Q\left[\begin{array}{c}
R\\
0
\end{array}\right]
\f]

where R is upper triangular (upper trapezoidal if m < n), and Q is
a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

\f[
Q = H_1H_2\cdots H_k, \quad \text{with} \: k = \text{min}(m,n)
\f]

Each Householder matrix \f$H_i\f$ is given by

\f[
H_i = I - \text{ipiv}[i] \cdot v_i v_i'
\f]

where the first i-1 elements of the Householder vector \f$v_i\f$ are zero, and \f$v_i[i] = 1\f$.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
m         int. m >= 0.\n
The number of rows of the matrix A.
@param[in]
n         int. n >= 0.\n
The number of columns of the matrix A.
@param[inout]
A         pointer to type. Array on the GPU of dimension lda*n.\n
On entry, the m-by-n matrix to be factored.
On exit, the elements on and above the diagonal contain the
factor R; the elements below the diagonal are the last m - i elements
of Householder vector v_i.
@param[in]
lda       int. lda >= m.\n
Specifies the leading dimension of A.
@param[out]
ipiv      pointer to type. Array on the GPU of dimension min(m,n).\n
The Householder scalars.
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
*/
    pub fn hipblasSgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut f32,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut f64,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipblasComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipblasDoubleComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipDoubleComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
geqrfBatched computes the QR factorization of a batch of general
m-by-n matrices.

The factorization of matrix \f$A_i\f$ in the batch has the form

\f[
A_i = Q_i\left[\begin{array}{c}
R_i\\
0
\end{array}\right]
\f]

where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

\f[
Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
\f]

Each Householder matrix \f$H_{i_j}\f$ is given by

\f[
H_{i_j} = I - \text{ipiv}_i[j] \cdot v_{i_j} v_{i_j}'
\f]

where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : s,d,c,z

@param[in]
handle    hipblasHandle_t.
@param[in]
m         int. m >= 0.\n
The number of rows of all the matrices A_i in the batch.
@param[in]
n         int. n >= 0.\n
The number of columns of all the matrices A_i in the batch.
@param[inout]
A         Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\n
On entry, the m-by-n matrices A_i to be factored.
On exit, the elements on and above the diagonal contain the
factor R_i. The elements below the diagonal are the last m - j elements
of Householder vector v_(i_j).
@param[in]
lda       int. lda >= m.\n
Specifies the leading dimension of matrices A_i.
@param[out]
ipiv      array of pointers to type. Each pointer points to an array on the GPU
of dimension min(m, n).\n
Contains the vectors ipiv_i of corresponding Householder scalars.
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[in]
batchCount  int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut f32,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut f64,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipblasComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipblasDoubleComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipDoubleComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief SOLVER API

\details
geqrfStridedBatched computes the QR factorization of a batch of
general m-by-n matrices.

The factorization of matrix \f$A_i\f$ in the batch has the form

\f[
A_i = Q_i\left[\begin{array}{c}
R_i\\
0
\end{array}\right]
\f]

where \f$R_i\f$ is upper triangular (upper trapezoidal if m < n), and \f$Q_i\f$ is
a m-by-m orthogonal/unitary matrix represented as the product of Householder matrices

\f[
Q_i = H_{i_1}H_{i_2}\cdots H_{i_k}, \quad \text{with} \: k = \text{min}(m,n)
\f]

Each Householder matrix \f$H_{i_j}\f$ is given by

\f[
H_{i_j} = I - \text{ipiv}_j[j] \cdot v_{i_j} v_{i_j}'
\f]

where the first j-1 elements of Householder vector \f$v_{i_j}\f$ are zero, and \f$v_{i_j}[j] = 1\f$.

- Supported precisions in rocSOLVER : s,d,c,z
- Supported precisions in cuBLAS    : No support

@param[in]
handle    hipblasHandle_t.
@param[in]
m         int. m >= 0.\n
The number of rows of all the matrices A_i in the batch.
@param[in]
n         int. n >= 0.\n
The number of columns of all the matrices A_i in the batch.
@param[inout]
A         pointer to type. Array on the GPU (the size depends on the value of strideA).\n
On entry, the m-by-n matrices A_i to be factored.
On exit, the elements on and above the diagonal contain the
factor R_i. The elements below the diagonal are the last m - j elements
of Householder vector v_(i_j).
@param[in]
lda       int. lda >= m.\n
Specifies the leading dimension of matrices A_i.
@param[in]
strideA   hipblasStride.\n
Stride from the start of one matrix A_i to the next one A_(i+1).
There is no restriction for the value of strideA. Normal use case is strideA >= lda*n.
@param[out]
ipiv      pointer to type. Array on the GPU (the size depends on the value of strideP).\n
Contains the vectors ipiv_i of corresponding Householder scalars.
@param[in]
strideP   hipblasStride.\n
Stride from the start of one vector ipiv_i to the next one ipiv_(i+1).
There is no restriction for the value
of strideP. Normal use is strideP >= min(m,n).
@param[out]
info      pointer to a int on the host.\n
If info = 0, successful exit.
If info = j < 0, the argument at position -j is invalid.
@param[in]
batchCount  int. batchCount >= 0.\n
Number of matrices in the batch.*/
    pub fn hipblasSgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut f32,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut f64,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
gemmEx performs one of the matrix-matrix operations

C = alpha*op( A )*op( B ) + beta*C,

where op( X ) is one of

op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,

alpha and beta are scalars, and A, B, and C are matrices, with
op( A ) an m by k matrix, op( B ) a k by n matrix and C is a m by n matrix.

- Supported types are determined by the backend. See cuBLAS documentation for cuBLAS backend.
For rocBLAS backend, conversion from hipblasComputeType_t to rocblas_datatype_t happens within hipBLAS.
Supported types are as follows:

|   aType    |   bType    |   cType    |     computeType     |
| ---------- | ---------- | ---------- | ------------------- |
| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_16F |
| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_32F |
| HIP_R_16F  | HIP_R_16F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
| HIP_R_16BF | HIP_R_16BF | HIP_R_16BF | HIPBLAS_COMPUTE_32F |
| HIP_R_16BF | HIP_R_16BF | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
| HIP_R_32F  | HIP_R_32F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |
| HIP_R_64F  | HIP_R_64F  | HIP_R_64F  | HIPBLAS_COMPUTE_64F |
| HIP_R_8I   | HIP_R_8I   | HIP_R_32I  | HIPBLAS_COMPUTE_32I |
| HIP_C_32F  | HIP_C_32F  | HIP_C_32F  | HIPBLAS_COMPUTE_32F |
| HIP_C_64F  | HIP_C_64F  | HIP_C_64F  | HIPBLAS_COMPUTE_64F |

hipblasGemmExWithFlags is also available which is identical to hipblasGemmEx
with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

With HIPBLAS_V2 define, hipblasGemmEx accepts hipDataType for aType, bType, and cType.
It also accepts hipblasComputeType_t for computeType. hipblasGemmEx will no
longer support hipblasDataType_t for these parameters in a future release. hipblasGemmEx follows
the same convention.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasGemmEx(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipDataType          aType,
int                  lda,
const void*          B,
hipDataType          bType,
int                  ldb,
const void*          beta,
void*                C,
hipDataType          cType,
int                  ldc,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo)

hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipDataType          aType,
int                  lda,
const void*          B,
hipDataType          bType,
int                  ldb,
const void*          beta,
void*                C,
hipDataType          cType,
int                  ldc,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#else // [DEPRECATED]

hipblasStatus_t hipblasGemmEx(hipblasHandle_t    handle,
hipblasOperation_t transA,
hipblasOperation_t transB,
int                m,
int                n,
int                k,
const void*        alpha,
const void*        A,
hipblasDatatype_t  aType,
int                lda,
const void*        B,
hipblasDatatype_t  bType,
int                ldb,
const void*        beta,
void*              C,
hipblasDatatype_t  cType,
int                ldc,
hipblasDatatype_t  computeType,
hipblasGemmAlgo_t  algo)

hipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipblasDatatype_t    aType,
int                  lda,
const void*          B,
hipblasDatatype_t    bType,
int                  ldb,
const void*          beta,
void*                C,
hipblasDatatype_t    cType,
int                  ldc,
hipblasDatatype_t    computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A ).
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B ).
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
k         [int]
matrix dimension k.
@param[in]
alpha     [const void *]
device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
@param[in]
A         [void *]
device pointer storing matrix A.
@param[in]
aType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of matrix A.\n
[hipDataType]
specifies the datatype of matrix A.
@param[in]
lda       [int]
specifies the leading dimension of A.
@param[in]
B         [void *]
device pointer storing matrix B.
@param[in]
bType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of matrix B.\n
[hipDataType]
specifies the datatype of matrix B.
@param[in]
ldb       [int]
specifies the leading dimension of B.
@param[in]
beta      [const void *]
device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
@param[in]
C         [void *]
device pointer storing matrix C.
@param[in]
cType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of matrix C.\n
[hipDataType]
specifies the datatype of matrix C.
@param[in]
ldc       [int]
specifies the leading dimension of C.
@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipblasComputeType_t]
specifies the datatype of computation.
@param[in]
algo      [hipblasGemmAlgo_t]
enumerant specifying the algorithm type.
*/
    pub fn hipblasGemmEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API
\details
gemmBatchedEx performs one of the batched matrix-matrix operations
C_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount.
where op( X ) is one of
op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,
alpha and beta are scalars, and A, B, and C are batched pointers to matrices, with
op( A ) an m by k by batchCount batched matrix,
op( B ) a k by n by batchCount batched matrix and
C a m by n by batchCount batched matrix.
The batched matrices are an array of pointers to matrices.
The number of pointers to matrices is batchCount.

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

hipblasGemmBatchedExWithFlags is also available which is identical to hipblasGemmBatchedEx
with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

With HIPBLAS_V2 define, hipblasGemmBatchedEx accepts hipDataType for aType, bType, and cType.
It also accepts hipblasComputeType_t for computeType. hipblasGemmBatchedEx will no
longer support hipblasDataType_t for these parameters in a future release. hipblasGemmBatchedExWithFlags
follows the same convention.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A[],
hipDataType          aType,
int                  lda,
const void*          B[],
hipDataType          bType,
int                  ldb,
const void*          beta,
void*                C[],
hipDataType          cType,
int                  ldc,
int                  batchCount,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo)

hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A[],
hipDataType          aType,
int                  lda,
const void*          B[],
hipDataType          bType,
int                  ldb,
const void*          beta,
void*                C[],
hipDataType          cType,
int                  ldc,
int                  batchCount,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#else // [DEPRECATED]

hipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t    handle,
hipblasOperation_t transA,
hipblasOperation_t transB,
int                m,
int                n,
int                k,
const void*        alpha,
const void*        A[],
hipblasDatatype_t  aType,
int                lda,
const void*        B[],
hipblasDatatype_t  bType,
int                ldb,
const void*        beta,
void*              C[],
hipblasDatatype_t  cType,
int                ldc,
int                batchCount,
hipblasDatatype_t  computeType,
hipblasGemmAlgo_t  algo)

hipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A[],
hipblasDatatype_t    aType,
int                  lda,
const void*          B[],
hipblasDatatype_t    bType,
int                  ldb,
const void*          beta,
void*                C[],
hipblasDatatype_t    cType,
int                  ldc,
int                  batchCount,
hipblasDatatype_t    computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#endif





@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A ).
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B ).
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
k         [int]
matrix dimension k.
@param[in]
alpha     [const void *]
device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
@param[in]
A         [void *]
device pointer storing array of pointers to each matrix A_i.
@param[in]
aType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix A_i.\n
[hipDataType]
specifies the datatype of each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
B         [void *]
device pointer storing array of pointers to each matrix B_i.
@param[in]
bType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix B_i.\n
[hipDataType]
specifies the datatype of each matrix B_i.
@param[in]
ldb       [int]
specifies the leading dimension of each B_i.
@param[in]
beta      [const void *]
device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
@param[in]
C         [void *]
device array of device pointers to each matrix C_i.
@param[in]
cType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix C_i.\n
[hipDataType]
specifies the datatype of each matrix C_i.
@param[in]
ldc       [int]
specifies the leading dimension of each C_i.
@param[in]
batchCount
[int]
number of gemm operations in the batch.
@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipblasComputeType_t]
specifies the datatype of computation.
@param[in]
algo      [hipblasGemmAlgo_t]
enumerant specifying the algorithm type.
*/
    pub fn hipblasGemmBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedEx_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        batchCount: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedEx_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        batchCount: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        batchCount: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        batchCount: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
gemmStridedBatchedEx performs one of the strided_batched matrix-matrix operations

C_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount

where op( X ) is one of

op( X ) = X      or
op( X ) = X**T   or
op( X ) = X**H,

alpha and beta are scalars, and A, B, and C are strided_batched matrices, with
op( A ) an m by k by batchCount strided_batched matrix,
op( B ) a k by n by batchCount strided_batched matrix and
C a m by n by batchCount strided_batched matrix.

The strided_batched matrices are multiple matrices separated by a constant stride.
The number of matrices is batchCount.

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

hipblasGemmStridedBatchedExWithFlags is also available which is identical to hipblasStridedBatchedGemmEx
with the addition of a "flags" parameter which controls flags used in Tensile to control gemm algorithms with the
rocBLAS backend. When using a cuBLAS backend this parameter is ignored.

With HIPBLAS_V2 define, hipblasGemmStridedBatchedEx accepts hipDataType for aType, bType, and cType.
It also accepts hipblasComputeType_t for computeType. hipblasGemmStridedBatchedEx will no
longer support hipblasDataType_t for these parameters in a future release. hipblasGemmStridedBatchedExWithFlags
follows the same convention.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipDataType          aType,
int                  lda,
hipblasStride        strideA,
const void*          B,
hipDataType          bType,
int                  ldb,
hipblasStride        strideB,
const void*          beta,
void*                C,
hipDataType          cType,
int                  ldc,
hipblasStride        strideC,
int                  batchCount,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo)

hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipDataType          aType,
int                  lda,
hipblasStride        strideA,
const void*          B,
hipDataType          bType,
int                  ldb,
hipblasStride        strideB,
const void*          beta,
void*                C,
hipDataType          cType,
int                  ldc,
hipblasStride        strideC,
int                  batchCount,
hipblasComputeType_t computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#else // [DEPRECATED]

hipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t    handle,
hipblasOperation_t transA,
hipblasOperation_t transB,
int                m,
int                n,
int                k,
const void*        alpha,
const void*        A,
hipblasDatatype_t  aType,
int                lda,
hipblasStride      strideA,
const void*        B,
hipblasDatatype_t  bType,
int                ldb,
hipblasStride      strideB,
const void*        beta,
void*              C,
hipblasDatatype_t  cType,
int                ldc,
hipblasStride      strideC,
int                batchCount,
hipblasDatatype_t  computeType,
hipblasGemmAlgo_t  algo)

hipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,
hipblasOperation_t   transA,
hipblasOperation_t   transB,
int                  m,
int                  n,
int                  k,
const void*          alpha,
const void*          A,
hipblasDatatype_t    aType,
int                  lda,
hipblasStride        strideA,
const void*          B,
hipblasDatatype_t    bType,
int                  ldb,
hipblasStride        strideB,
const void*          beta,
void*                C,
hipblasDatatype_t    cType,
int                  ldc,
hipblasStride        strideC,
int                  batchCount,
hipblasDatatype_t    computeType,
hipblasGemmAlgo_t    algo,
hipblasGemmFlags_t   flags)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
transA    [hipblasOperation_t]
specifies the form of op( A ).
@param[in]
transB    [hipblasOperation_t]
specifies the form of op( B ).
@param[in]
m         [int]
matrix dimension m.
@param[in]
n         [int]
matrix dimension n.
@param[in]
k         [int]
matrix dimension k.
@param[in]
alpha     [const void *]
device pointer or host pointer specifying the scalar alpha. Same datatype as computeType.
@param[in]
A         [void *]
device pointer pointing to first matrix A_1.
@param[in]
aType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix A_i.\n
[hipDataType]
specifies the datatype of each matrix A_i.
@param[in]
lda       [int]
specifies the leading dimension of each A_i.
@param[in]
strideA  [hipblasStride]
specifies stride from start of one A_i matrix to the next A_(i + 1).
@param[in]
B         [void *]
device pointer pointing to first matrix B_1.
@param[in]
bType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix B_i.\n
[hipDataType]
specifies the datatype of each matrix B_i.
@param[in]
ldb       [int]
specifies the leading dimension of each B_i.
@param[in]
strideB  [hipblasStride]
specifies stride from start of one B_i matrix to the next B_(i + 1).
@param[in]
beta      [const void *]
device pointer or host pointer specifying the scalar beta. Same datatype as computeType.
@param[in]
C         [void *]
device pointer pointing to first matrix C_1.
@param[in]
cType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each matrix C_i.\n
[hipDataType]
specifies the datatype of each matrix C_i.
@param[in]
ldc       [int]
specifies the leading dimension of each C_i.
@param[in]
strideC  [hipblasStride]
specifies stride from start of one C_i matrix to the next C_(i + 1).
@param[in]
batchCount
[int]
number of gemm operations in the batch.
@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipblasComputeType_t]
specifies the datatype of computation.
@param[in]
algo      [hipblasGemmAlgo_t]
enumerant specifying the algorithm type.
*/
    pub fn hipblasGemmStridedBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedEx_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: i64,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags_v2_64(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: i64,
        n: i64,
        k: i64,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: i64,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: i64,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: i64,
        strideC: hipblasStride,
        batchCount: i64,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** BLAS EX API

\details
trsmEx solves

op(A)*X = alpha*B or X*op(A) = alpha*B,

where alpha is a scalar, X and B are m by n matrices,
A is triangular matrix and op(A) is one of

op( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.

The matrix X is overwritten on B.

This function gives the user the ability to reuse the invA matrix between runs.
If invA == NULL, hipblasTrsmEx will automatically calculate invA on every run.

Setting up invA:
The accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of
matrix A, followed by any smaller diagonal block that remains.
To set up invA it is recommended that hipblasTrtriBatched be used with matrix A as the input.

Device memory of size 128 x k should be allocated for invA ahead of time, where k is m when
HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in invA
should be passed as invAsize.

To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of
matrix A. Below are the restricted parameters:
- n = 128
- ldinvA = 128
- stride_invA = 128x128
- batchCount = k / 128,

Then any remaining block may be added:
- n = k % 128
- invA = invA + stride_invA * previousBatchCount
- ldinvA = 128
- batchCount = 1

With HIPBLAS_V2 define, hipblasTrsmEx accepts hipDataType for computeType rather than
hipblasDatatype_t. hipblasTrsmEx will only accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
void*              B,
int                ldb,
const void*        invA,
int                invAsize,
hipDataType        computeType)

#else // [DEPRECATED]

hipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
void*              B,
int                ldb,
const void*        invA,
int                invAsize,
hipblasDatatype_t  computeType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  A is a lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_ON_C: op(A) = A^H.

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of B. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of B. n >= 0.

@param[in]
alpha   [void *]
device pointer or host pointer specifying the scalar alpha. When alpha is
&zero then A is not referenced, and B need not be set before
entry.

@param[in]
A       [void *]
device pointer storing matrix A.
of dimension ( lda, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[in, out]
B       [void *]
device pointer storing matrix B.
B is of dimension ( ldb, n ).
Before entry, the leading m by n part of the array B must
contain the right-hand side matrix B, and on exit is
overwritten by the solution matrix X.

@param[in]
ldb    [int]
ldb specifies the first dimension of B. ldb >= max( 1, m ).

@param[in]
invA    [void *]
device pointer storing the inverse diagonal blocks of A.
invA is of dimension ( ld_invA, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT.
ld_invA must be equal to 128.

@param[in]
invAsize [int]
invAsize specifies the number of elements of device memory in invA.

@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasTrsmEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** BLAS EX API

\details
trsmBatchedEx solves

op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

for i = 1, ..., batchCount; and where alpha is a scalar, X and B are arrays of m by n matrices,
A is an array of triangular matrix and each op(A_i) is one of

op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

Each matrix X_i is overwritten on B_i.

This function gives the user the ability to reuse the invA matrix between runs.
If invA == NULL, hipblasTrsmBatchedEx will automatically calculate each invA_i on every run.

Setting up invA:
Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
matrix A_i, followed by any smaller diagonal block that remains.
To set up each invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
invA is an array of pointers of batchCount length holding each invA_i.

Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
should be passed as invAsize.

To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
matrix A_i. Below are the restricted parameters:
- n = 128
- ldinvA = 128
- stride_invA = 128x128
- batchCount = k / 128,

Then any remaining block may be added:
- n = k % 128
- invA = invA + stride_invA * previousBatchCount
- ldinvA = 128
- batchCount = 1

With HIPBLAS_V2 define, hipblasTrsmBatchedEx accepts hipDataType for computeType rather than
hipblasDatatype_t. hipblasTrsmBatchedEx will only accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
void*              B,
int                ldb,
int                batchCount,
const void*        invA,
int                invAsize,
hipDataType        computeType)

#else // [DEPRECATED]

hipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
void*              B,
int                ldb,
int                batchCount,
const void*        invA,
int                invAsize,
hipblasDatatype_t  computeType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of each B_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of each B_i. n >= 0.

@param[in]
alpha   [void *]
device pointer or host pointer alpha specifying the scalar alpha. When alpha is
&zero then A is not referenced, and B need not be set before
entry.

@param[in]
A       [void *]
device array of device pointers storing each matrix A_i.
each A_i is of dimension ( lda, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of each A_i.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[in, out]
B       [void *]
device array of device pointers storing each matrix B_i.
each B_i is of dimension ( ldb, n ).
Before entry, the leading m by n part of the array B_i must
contain the right-hand side matrix B_i, and on exit is
overwritten by the solution matrix X_i

@param[in]
ldb    [int]
ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

@param[in]
batchCount [int]
specifies how many batches.

@param[in]
invA    [void *]
device array of device pointers storing the inverse diagonal blocks of each A_i.
each invA_i is of dimension ( ld_invA, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT.
ld_invA must be equal to 128.

@param[in]
invAsize [int]
invAsize specifies the number of elements of device memory in each invA_i.

@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasTrsmBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** BLAS EX API

\details
trsmStridedBatchedEx solves

op(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,

for i = 1, ..., batchCount; and where alpha is a scalar, X and B are strided batched m by n matrices,
A is a strided batched triangular matrix and op(A_i) is one of

op( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.

Each matrix X_i is overwritten on B_i.

This function gives the user the ability to reuse each invA_i matrix between runs.
If invA == NULL, hipblasTrsmStridedBatchedEx will automatically calculate each invA_i on every run.

Setting up invA:
Each accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of
matrix A_i, followed by any smaller diagonal block that remains.
To set up invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.
invA is a contiguous piece of memory holding each invA_i.

Device memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when
HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i
should be passed as invAsize.

To begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each
matrix A_i. Below are the restricted parameters:
- n = 128
- ldinvA = 128
- stride_invA = 128x128
- batchCount = k / 128,

Then any remaining block may be added:
- n = k % 128
- invA = invA + stride_invA * previousBatchCount
- ldinvA = 128
- batchCount = 1

With HIPBLAS_V2 define, hipblasStridedBatchedTrsmEx accepts hipDataType for computeType rather than
hipblasDatatype_t. hipblasTrsmStridedBatchedEx will only accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
hipblasStride      strideA,
void*              B,
int                ldb,
hipblasStride      strideB,
int                batchCount,
const void*        invA,
int                invAsize,
hipblasStride      strideInvA,
hipDataType        computeType);

#else // [DEPRECATED]

hipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,
hipblasSideMode_t  side,
hipblasFillMode_t  uplo,
hipblasOperation_t transA,
hipblasDiagType_t  diag,
int                m,
int                n,
const void*        alpha,
void*              A,
int                lda,
hipblasStride      strideA,
void*              B,
int                ldb,
hipblasStride      strideB,
int                batchCount,
const void*        invA,
int                invAsize,
hipblasStride      strideInvA,
hipblasDatatype_t  computeType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.

@param[in]
side    [hipblasSideMode_t]
HIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.
HIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.

@param[in]
uplo    [hipblasFillMode_t]
HIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.
HIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.

@param[in]
transA  [hipblasOperation_t]
HIPBLAS_OP_N: op(A) = A.
HIPBLAS_OP_T: op(A) = A^T.
HIPBLAS_OP_C: op(A) = A^H.

@param[in]
diag    [hipblasDiagType_t]
HIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.
HIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.

@param[in]
m       [int]
m specifies the number of rows of each B_i. m >= 0.

@param[in]
n       [int]
n specifies the number of columns of each B_i. n >= 0.

@param[in]
alpha   [void *]
device pointer or host pointer specifying the scalar alpha. When alpha is
&zero then A is not referenced, and B need not be set before
entry.

@param[in]
A       [void *]
device pointer storing matrix A.
of dimension ( lda, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT
only the upper/lower triangular part is accessed.

@param[in]
lda     [int]
lda specifies the first dimension of A.
if side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),
if side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).

@param[in]
strideA [hipblasStride]
The stride between each A matrix.

@param[in, out]
B       [void *]
device pointer pointing to first matrix B_i.
each B_i is of dimension ( ldb, n ).
Before entry, the leading m by n part of each array B_i must
contain the right-hand side of matrix B_i, and on exit is
overwritten by the solution matrix X_i.

@param[in]
ldb    [int]
ldb specifies the first dimension of each B_i. ldb >= max( 1, m ).

@param[in]
strideB [hipblasStride]
The stride between each B_i matrix.

@param[in]
batchCount [int]
specifies how many batches.

@param[in]
invA    [void *]
device pointer storing the inverse diagonal blocks of each A_i.
invA points to the first invA_1.
each invA_i is of dimension ( ld_invA, k ), where k is m
when HIPBLAS_SIDE_LEFT and
is n when HIPBLAS_SIDE_RIGHT.
ld_invA must be equal to 128.

@param[in]
invAsize [int]
invAsize specifies the number of elements of device memory in each invA_i.

@param[in]
strideInvA [hipblasStride]
The stride between each invA matrix.

@param[in]
computeType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasTrsmStridedBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        strideInvA: hipblasStride,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        strideInvA: hipblasStride,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
axpyEx computes constant alpha multiplied by vector x, plus vector y

y := alpha * x + y

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasAxpyEx accepts hipDataType for alphaType, xType, yType,
and executionType rather than hipblasDatatype_t. hipblasAxpyEx will only accept hipDataType
in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasAxpyEx(hipblasHandle_t handle,
int             n,
const void*     alpha,
hipDataType     alphaType,
const void*     x,
hipDataType     xType,
int             incx,
void*           y,
hipDataType     yType,
int             incy,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasAxpyEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
const void*       x,
hipblasDatatype_t xType,
int               incx,
void*             y,
hipblasDatatype_t yType,
int               incy,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
alpha     device pointer or host pointer to specify the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[in]
x         device pointer storing vector x.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector x.\n
[hipDataType]
specifies the datatype of vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[inout]
y         device pointer storing vector y.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector y.\n
[hipDataType]
specifies the datatype of vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasAxpyEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
axpyBatchedEx computes constant alpha multiplied by vector x, plus vector y over
a set of batched vectors.

y := alpha * x + y

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasAxpyBatchedEx accepts hipDataType for alphaType, xType, yType,
and executionType rather than hipblasDatatype_t. hipblasAxpyBatchedEx will only accept hipDataType
in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t handle,
int             n,
const void*     alpha,
hipDataType     alphaType,
const void*     x,
hipDataType     xType,
int             incx,
void*           y,
hipDataType     yType,
int             incy,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
const void*       x,
hipblasDatatype_t xType,
int               incx,
void*             y,
hipblasDatatype_t yType,
int               incy,
int               batchCount,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
alpha     device pointer or host pointer to specify the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[inout]
y         device array of device pointers storing each vector y_i.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
batchCount [int]
number of instances in the batch.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasAxpyBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
axpyStridedBatchedEx computes constant alpha multiplied by vector x, plus vector y over
a set of strided batched vectors.

y := alpha * x + y

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasAxpyStridedBatchedEx accepts hipDataType for alphaType, xType, yType,
and executionType rather than hipblasDatatype_t. hipblasAxpyStridedBatchedEx will only accept hipDataType
in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t handle,
int             n,
const void*     alpha,
hipDataType     alphaType,
const void*     x,
hipDataType     xType,
int             incx,
hipblasStride   stridex,
void*           y,
hipDataType     yType,
int             incy,
hipblasStride   stridey,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
const void*       x,
hipblasDatatype_t xType,
int               incx,
hipblasStride     stridex,
void*             y,
hipblasDatatype_t yType,
int               incy,
hipblasStride     stridey,
int               batchCount,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
alpha     device pointer or host pointer to specify the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[in]
x         device pointer to the first vector x_1.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) to the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size, for a typical
case this means stridex >= n * incx.
@param[inout]
y         device pointer to the first vector y_1.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey   [hipblasStride]
stride from the start of one vector (y_i) to the next one (y_i+1).
There are no restrictions placed on stridey, however the user should
take care to ensure that stridey is of appropriate size, for a typical
case this means stridey >= n * incy.
@param[in]
batchCount [int]
number of instances in the batch.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasAxpyStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyStridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS EX API

\details
dotEx  performs the dot product of vectors x and y

result = x * y;

dotcEx  performs the dot product of the conjugate of complex vector x and complex vector y

result = conjugate (x) * y;

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasDot(c)Ex accepts hipDataType for xType, yType,
resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)Ex will only
accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasDotEx(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
const void*     y,
hipDataType     yType,
int             incy,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasDotEx(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
const void*       y,
hipblasDatatype_t yType,
int               incy,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x and y.
@param[in]
x         device pointer storing vector x.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector x.\n
[hipDataType]
specifies the datatype of vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[in]
y         device pointer storing vector y.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector y.\n
[hipDataType]
specifies the datatype of vector y.
@param[in]
incy      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the dot product.
return is 0.0 if n <= 0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasDotEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    ///! @}
    pub fn hipblasDotEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS EX API

\details
dotBatchedEx performs a batch of dot products of vectors x and y

result_i = x_i * y_i;

dotcBatchedEx  performs a batch of dot products of the conjugate of complex vector x and complex vector y

result_i = conjugate (x_i) * y_i;

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors, for i = 1, ..., batchCount

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasDot(c)BatchedEx accepts hipDataType for xType, yType,
resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)BatchedEx will only
accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
const void*     y,
hipDataType     yType,
int             incy,
int             batchCount,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
const void*       y,
hipblasDatatype_t yType,
int               incy,
int               batchCount,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
y         device array of device pointers storing each vector y_i.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
batchCount [int]
number of instances in the batch
@param[inout]
result
device array or host array of batchCount size to store the dot products of each batch.
return 0.0 for each element if n <= 0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasDotBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    ///! @}
    pub fn hipblasDotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** @{
\brief BLAS EX API

\details
dotStridedBatchedEx  performs a batch of dot products of vectors x and y

result_i = x_i * y_i;

dotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y

result_i = conjugate (x_i) * y_i;

where (x_i, y_i) is the i-th instance of the batch.
x_i and y_i are vectors, for i = 1, ..., batchCount

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasDot(c)StridedBatchedEx accepts hipDataType for xType, yType,
resultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)StridedBatchedEx will only
accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
hipblasStride   stridex,
const void*     y,
hipDataType     yType,
int             incy,
hipblasStride   stridey,
int             batchCount,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
hipblasStride     stridex,
const void*       y,
hipblasDatatype_t yType,
int               incy,
hipblasStride     stridey,
int               batchCount,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in each x_i and y_i.
@param[in]
x         device pointer to the first vector (x_1) in the batch.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1)
@param[in]
y         device pointer to the first vector (y_1) in the batch.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy      [int]
specifies the increment for the elements of each y_i.
@param[in]
stridey   [hipblasStride]
stride from the start of one vector (y_i) and the next one (y_i+1)
@param[in]
batchCount [int]
number of instances in the batch
@param[inout]
result
device array or host array of batchCount size to store the dot products of each batch.
return 0.0 for each element if n <= 0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasDotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    ///! @}
    pub fn hipblasDotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotStridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        stridey: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS_EX API

\details
nrm2Ex computes the euclidean norm of a real or complex vector

result := sqrt( x'*x ) for real vectors
result := sqrt( x**H*x ) for complex vectors

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasNrm2Ex accepts hipDataType for xType, resultType,
and executionType rather than hipblasDatatype_t. hipblasNrm2Ex will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasNrm2Ex(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
x         device pointer storing vector x.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the vector x.\n
[hipDataType]
specifies the datatype of the vector x.
@param[in]
incx      [int]
specifies the increment for the elements of y.
@param[inout]
result
device pointer or host pointer to store the nrm2 product.
return is 0.0 if n, incx<=0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.*/
    pub fn hipblasNrm2Ex(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2Ex_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2Ex_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2Ex_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS_EX API

\details
nrm2BatchedEx computes the euclidean norm over a batch of real or complex vectors

result := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
result := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasNrm2BatchedEx accepts hipDataType for xType, resultType,
and executionType rather than hipblasDatatype_t. hipblasNrm2BatchedEx will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
int             batchCount,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
int               batchCount,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each x_i.
@param[in]
x         device array of device pointers storing each vector x_i.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device pointer or host pointer to array of batchCount size for nrm2 results.
return is 0.0 for each element if n <= 0, incx<=0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasNrm2BatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2BatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2BatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2BatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS_EX API

\details
nrm2StridedBatchedEx computes the euclidean norm over a batch of real or complex vectors

:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount
:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasNrm2StridedBatchedEx accepts hipDataType for xType, resultType,
and executionType rather than hipblasDatatype_t. hipblasNrm2StridedBatchedEx will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t handle,
int             n,
const void*     x,
hipDataType     xType,
int             incx,
hipblasStride   stridex,
int             batchCount,
void*           result,
hipDataType     resultType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       x,
hipblasDatatype_t xType,
int               incx,
hipblasStride     stridex,
int               batchCount,
void*             result,
hipblasDatatype_t resultType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
number of elements in each x_i.
@param[in]
x         device pointer to the first vector x_1.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i. incx must be > 0.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) and the next one (x_i+1).
There are no restrictions placed on stride_x, however the user should
take care to ensure that stride_x is of appropriate size, for a typical
case this means stride_x >= n * incx.
@param[in]
batchCount [int]
number of instances in the batch
@param[out]
result
device pointer or host pointer to array for storing contiguous batchCount results.
return is 0.0 for each element if n <= 0, incx<=0.
@param[in]
resultType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of the result.\n
[hipDataType]
specifies the datatype of the result.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasNrm2StridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2StridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2StridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2StridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
rotEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

In the case where cs_type is real:
x := c * x + s * y
y := c * y - s * x

In the case where cs_type is complex, the imaginary part of c is ignored:
x := real(c) * x + s * y
y := real(c) * y - conj(s) * x

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasRotEx accepts hipDataType for xType, yType, csType,
and executionType rather than hipblasDatatype_t. hipblasRotEx will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasRotEx(hipblasHandle_t handle,
int             n,
void*           x,
hipDataType     xType,
int             incx,
void*           y,
hipDataType     yType,
int             incy,
const void*     c,
const void*     s,
hipDataType     csType,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasRotEx(hipblasHandle_t   handle,
int               n,
void*             x,
hipblasDatatype_t xType,
int               incx,
void*             y,
hipblasDatatype_t yType,
int               incy,
const void*       c,
const void*       s,
hipblasDatatype_t csType,
hipblasDatatype_t executionType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in the x and y vectors.
@param[inout]
x       device pointer storing vector x.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector x.\n
[hipDataType]
specifies the datatype of vector x.
@param[in]
incx    [int]
specifies the increment between elements of x.
@param[inout]
y       device pointer storing vector y.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector y.\n
[hipDataType]
specifies the datatype of vector y.
@param[in]
incy    [int]
specifies the increment between elements of y.
@param[in]
c       device pointer or host pointer storing scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer storing scalar sine component of the rotation matrix.
@param[in]
csType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of c and s.\n
[hipDataType]
specifies the datatype of c and s.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasRotEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
rotBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

In the case where cs_type is real:
x := c * x + s * y
y := c * y - s * x

In the case where cs_type is complex, the imaginary part of c is ignored:
x := real(c) * x + s * y
y := real(c) * y - conj(s) * x

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasRotBatchedEx accepts hipDataType for xType, yType, csType,
and executionType rather than hipblasDatatype_t. hipblasRotBatchedEx will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t handle,
int             n,
void*           x,
hipDataType     xType,
int             incx,
void*           y,
hipDataType     yType,
int             incy,
const void*     c,
const void*     s,
hipDataType     csType,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t   handle,
int               n,
void*             x,
hipblasDatatype_t xType,
int               incx,
void*             y,
hipblasDatatype_t yType,
int               incy,
const void*       c,
const void*       s,
hipblasDatatype_t csType,
int               batchCount,
hipblasDatatype_t executionType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in each x_i and y_i vectors.
@param[inout]
x       device array of device pointers storing each vector x_i.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[inout]
y       device array of device pointers storing each vector y_i.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
c       device pointer or host pointer to scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer to scalar sine component of the rotation matrix.
@param[in]
csType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of c and s.\n
[hipDataType]
specifies the datatype of c and s.
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasRotBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS Level 1 API

\details
rotStridedBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.
Scalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.

In the case where cs_type is real:
x := c * x + s * y
y := c * y - s * x

In the case where cs_type is complex, the imaginary part of c is ignored:
x := real(c) * x + s * y
y := real(c) * y - conj(s) * x

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasRotStridedBatchedEx accepts hipDataType for xType, yType, csType,
and executionType rather than hipblasDatatype_t. hipblasRotStridedBatchedEx will only accept
hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t handle,
int             n,
void*           x,
hipDataType     xType,
int             incx,
hipblasStride   stridex,
void*           y,
hipDataType     yType,
int             incy,
hipblasStride   stridey,
const void*     c,
const void*     s,
hipDataType     csType,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t   handle,
int               n,
void*             x,
hipblasDatatype_t xType,
int               incx,
hipblasStride     stridex,
void*             y,
hipblasDatatype_t yType,
int               incy,
hipblasStride     stridey,
const void*       c,
const void*       s,
hipblasDatatype_t csType,
int               batchCount,
hipblasDatatype_t executionType)

#endif

@param[in]
handle  [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n       [int]
number of elements in each x_i and y_i vectors.
@param[inout]
x       device pointer to the first vector x_1.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx    [int]
specifies the increment between elements of each x_i.
@param[in]
stridex [hipblasStride]
specifies the increment from the beginning of x_i to the beginning of x_(i+1)
@param[inout]
y       device pointer to the first vector y_1.
@param[in]
yType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector y_i.\n
[hipDataType]
specifies the datatype of each vector y_i.
@param[in]
incy    [int]
specifies the increment between elements of each y_i.
@param[in]
stridey [hipblasStride]
specifies the increment from the beginning of y_i to the beginning of y_(i+1)
@param[in]
c       device pointer or host pointer to scalar cosine component of the rotation matrix.
@param[in]
s       device pointer or host pointer to scalar sine component of the rotation matrix.
@param[in]
csType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of c and s.\n
[hipDataType]
specifies the datatype of c and s.
@param[in]
batchCount [int]
the number of x and y arrays, i.e. the number of batches.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasRotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotStridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: i64,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: i64,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
scalEx  scales each element of vector x with scalar alpha.

x := alpha * x

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasScalEx accepts hipDataType for alphaType,
xType, and executionType rather than hipblasDatatype_t. hipblasScalEx will only
accept hipDataType in a future release.

#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasScalEx(hipblasHandle_t handle,a
int             n,
const void*     alpha,
hipDataType     alphaType,
void*           x,
hipDataType     xType,
int             incx,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasScalEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
void*             x,
hipblasDatatype_t xType,
int               incx,
hipblasDatatype_t executionType)

#endif

@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
alpha     device pointer or host pointer for the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[inout]
x         device pointer storing vector x.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of vector x.\n
[hipDataType]
specifies the datatype of vector x.
@param[in]
incx      [int]
specifies the increment for the elements of x.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasScalEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
scalBatchedEx  scales each element of each vector x_i with scalar alpha.

x_i := alpha * x_i

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasScalBatchedEx accepts hipDataType for alphaType,
xType, and executionType rather than hipblasDatatype_t. hipblasScalBatchedEx will only
accept hipDataType in a future release.
\code{.cpp}
#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t handle,
int             n,
const void*     alpha,
hipDataType     alphaType,
void*           x,
hipDataType     xType,
int             incx,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
void*             x,
hipblasDatatype_t xType,
int               incx,
int               batchCount,
hipblasDatatype_t executionType)

#endif
\endcode
@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
alpha     device pointer or host pointer for the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[inout]
x         device array of device pointers storing each vector x_i.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
batchCount [int]
number of instances in the batch.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasScalBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** \brief BLAS EX API

\details
scalStridedBatchedEx  scales each element of vector x with scalar alpha over a set
of strided batched vectors.

x := alpha * x

- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.

With HIPBLAS_V2 define, hipblasScalStridedBatchedEx accepts hipDataType for alphaType,
xType, and executionType rather than hipblasDatatype_t. hipblasScalStridedBatchedEx will only
accept hipDataType in a future release.
\code{.cpp}
#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2

hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t handle,
int             n,
const void*     alpha,
hipDataType     alphaType,
void*           x,
hipDataType     xType,
int             incx,
hipblasStride   stridex,
int             batchCount,
hipDataType     executionType)

#else // [DEPRECATED]

hipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t   handle,
int               n,
const void*       alpha,
hipblasDatatype_t alphaType,
void*             x,
hipblasDatatype_t xType,
int               incx,
hipblasStride     stridex,
int               batchCount,
hipblasDatatype_t executionType)

#endif
\endcode
@param[in]
handle    [hipblasHandle_t]
handle to the hipblas library context queue.
@param[in]
n         [int]
the number of elements in x.
@param[in]
alpha     device pointer or host pointer for the scalar alpha.
@param[in]
alphaType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of alpha.\n
[hipDataType]
specifies the datatype of alpha.
@param[inout]
x         device pointer to the first vector x_1.
@param[in]
xType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of each vector x_i.\n
[hipDataType]
specifies the datatype of each vector x_i.
@param[in]
incx      [int]
specifies the increment for the elements of each x_i.
@param[in]
stridex   [hipblasStride]
stride from the start of one vector (x_i) to the next one (x_i+1).
There are no restrictions placed on stridex, however the user should
take care to ensure that stridex is of appropriate size, for a typical
case this means stridex >= n * incx.
@param[in]
batchCount [int]
number of instances in the batch.
@param[in]
executionType
[hipblasDatatype_t] [DEPRECATED]
specifies the datatype of computation.\n
[hipDataType]
specifies the datatype of computation.
*/
    pub fn hipblasScalStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalStridedBatchedEx_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalStridedBatchedEx_v2_64(
        handle: hipblasHandle_t,
        n: i64,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: i64,
        stridex: hipblasStride,
        batchCount: i64,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    /** HIPBLAS Auxiliary API

\details
hipblasStatusToString

Returns string representing hipblasStatus_t value

@param[in]
status  [hipblasStatus_t]
hipBLAS status to convert to string*/
    pub fn hipblasStatusToString(status: hipblasStatus_t) -> *const ::core::ffi::c_char;
}
impl hipblasErrorCode_t {
    pub const NOT_INITIALIZED: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(1)
    });
    pub const ALLOC_FAILED: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(2)
    });
    pub const INVALID_VALUE: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(3)
    });
    pub const MAPPING_ERROR: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(4)
    });
    pub const EXECUTION_FAILED: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(5)
    });
    pub const INTERNAL_ERROR: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(6)
    });
    pub const NOT_SUPPORTED: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(7)
    });
    pub const ARCH_MISMATCH: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(8)
    });
    pub const HANDLE_IS_NULLPTR: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(9)
    });
    pub const INVALID_ENUM: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(10)
    });
    pub const UNKNOWN: hipblasErrorCode_t = hipblasErrorCode_t(unsafe {
        ::core::num::NonZeroU32::new_unchecked(11)
    });
}
#[repr(transparent)]
#[derive(Debug, Hash, Copy, Clone, PartialEq, Eq)]
pub struct hipblasErrorCode_t(pub ::core::num::NonZeroU32);
pub trait hipblasStatus_tConsts {
    const SUCCESS: hipblasStatus_t = hipblasStatus_t::Ok(());
    const ERROR_NOT_INITIALIZED: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::NOT_INITIALIZED,
    );
    const ERROR_ALLOC_FAILED: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::ALLOC_FAILED,
    );
    const ERROR_INVALID_VALUE: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::INVALID_VALUE,
    );
    const ERROR_MAPPING_ERROR: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::MAPPING_ERROR,
    );
    const ERROR_EXECUTION_FAILED: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::EXECUTION_FAILED,
    );
    const ERROR_INTERNAL_ERROR: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::INTERNAL_ERROR,
    );
    const ERROR_NOT_SUPPORTED: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::NOT_SUPPORTED,
    );
    const ERROR_ARCH_MISMATCH: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::ARCH_MISMATCH,
    );
    const ERROR_HANDLE_IS_NULLPTR: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::HANDLE_IS_NULLPTR,
    );
    const ERROR_INVALID_ENUM: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::INVALID_ENUM,
    );
    const ERROR_UNKNOWN: hipblasStatus_t = hipblasStatus_t::Err(
        hipblasErrorCode_t::UNKNOWN,
    );
}
impl hipblasStatus_tConsts for hipblasStatus_t {}
#[must_use]
pub type hipblasStatus_t = ::core::result::Result<(), hipblasErrorCode_t>;
const _: fn() = || {
    let _ = std::mem::transmute::<hipblasStatus_t, u32>;
};
unsafe impl Send for hipblasHandle_t {}
unsafe impl Sync for hipblasHandle_t {}
