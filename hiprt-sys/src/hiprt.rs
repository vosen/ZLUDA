/* automatically generated by rust-bindgen 0.69.0 */

pub const HIPRT_API_MAJOR_VERSION: u32 = 1;
pub const HIPRT_API_MINOR_VERSION: u32 = 2;
pub const HIPRT_API_PATCH_VERSION: u32 = 0;
pub const HIPRT_API_VERSION: u32 = 1002000;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt2 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat2 {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt3 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtInt4 {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub z: ::std::os::raw::c_int,
    pub w: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFloat4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtUint2 {
    pub x: ::std::os::raw::c_uint,
    pub y: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _hiprtCustomFuncTable {
    _unused: [u8; 0],
}
pub type hiprtDevicePtr = *mut ::std::os::raw::c_void;
pub type hiprtGeometry = hiprtDevicePtr;
pub type hiprtScene = hiprtDevicePtr;
pub type hiprtBuildFlags = u32;
pub type hiprtRayMask = u32;
pub type hiprtCustomType = u32;
pub type hiprtContext = *mut _hiprtContext;
pub type hiprtCustomFuncTable = *mut _hiprtCustomFuncTable;
pub type hiprtApiDevice = ::std::os::raw::c_int;
pub type hiprtApiCtx = *mut ::std::os::raw::c_void;
pub type hiprtApiStream = *mut ::std::os::raw::c_void;
pub type hiprtApiFunction = *mut ::std::os::raw::c_void;
impl hiprtError {
    pub const hiprtSuccess: hiprtError = hiprtError(0);
}
impl hiprtError {
    pub const hiprtErrorNotImplemented: hiprtError = hiprtError(1);
}
impl hiprtError {
    pub const hiprtErrorInternal: hiprtError = hiprtError(2);
}
impl hiprtError {
    pub const hiprtErrorOutOfHostMemory: hiprtError = hiprtError(3);
}
impl hiprtError {
    pub const hiprtErrorOutOfDeviceMemory: hiprtError = hiprtError(4);
}
impl hiprtError {
    pub const hiprtErrorInvalidApiVersion: hiprtError = hiprtError(5);
}
impl hiprtError {
    pub const hiprtErrorInvalidParameter: hiprtError = hiprtError(6);
}
#[repr(transparent)]
#[doc = " \\brief Error codes.\n"]
#[must_use]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtError(pub ::std::os::raw::c_uint);
impl hiprtBuildOperation {
    pub const hiprtBuildOperationBuild: hiprtBuildOperation = hiprtBuildOperation(1);
}
impl hiprtBuildOperation {
    pub const hiprtBuildOperationUpdate: hiprtBuildOperation = hiprtBuildOperation(2);
}
#[repr(transparent)]
#[doc = " \\brief Type of geometry/scene build operation.\n\n hiprtBuildGeometry/hiprtBuildScene can either build or update\n an underlying acceleration structure."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBuildOperation(pub ::std::os::raw::c_uint);
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferFastBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(0);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferBalancedBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(1);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitPreferHighQualityBuild: hiprtBuildFlagBits = hiprtBuildFlagBits(2);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitCustomBvhImport: hiprtBuildFlagBits = hiprtBuildFlagBits(3);
}
impl hiprtBuildFlagBits {
    pub const hiprtBuildFlagBitDisableSpatialSplits: hiprtBuildFlagBits = hiprtBuildFlagBits(4);
}
#[repr(transparent)]
#[doc = " \\brief Hint flags for geometry/scene build functions.\n\n hiprtBuildGeometry/hiprtBuildScene use these flags to choose\n an appropriate build format/algorithm."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBuildFlagBits(pub ::std::os::raw::c_uint);
impl hiprtPrimitiveType {
    pub const hiprtPrimitiveTypeTriangleMesh: hiprtPrimitiveType = hiprtPrimitiveType(0);
}
impl hiprtPrimitiveType {
    pub const hiprtPrimitiveTypeAABBList: hiprtPrimitiveType = hiprtPrimitiveType(1);
}
#[repr(transparent)]
#[doc = " \\brief Geometric primitive type.\n\n hiprtGeometry can be built from multiple primitive types,\n such as triangle meshes, AABB lists, line lists, etc. This enum\n defines primitive type for hiprtBuildGeometry function."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtPrimitiveType(pub ::std::os::raw::c_uint);
impl hiprtTraversalState {
    pub const hiprtTraversalStateInit: hiprtTraversalState = hiprtTraversalState(0);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateFinished: hiprtTraversalState = hiprtTraversalState(1);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateHit: hiprtTraversalState = hiprtTraversalState(2);
}
impl hiprtTraversalState {
    pub const hiprtTraversalStateStackOverflow: hiprtTraversalState = hiprtTraversalState(3);
}
#[repr(transparent)]
#[doc = " \\brief Traversal state.\n\n On-device traversal can be in either hit state (and can be continued using\n hiprtNextHit) or finished state."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtTraversalState(pub ::std::os::raw::c_uint);
impl hiprtTraversalType {
    pub const hiprtTraversalTerminateAtAnyHit: hiprtTraversalType = hiprtTraversalType(1);
}
impl hiprtTraversalType {
    pub const hiprtTraversalTerminateAtClosestHit: hiprtTraversalType = hiprtTraversalType(2);
}
#[repr(transparent)]
#[doc = " \\brief Ray traversal type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtTraversalType(pub ::std::os::raw::c_uint);
impl hiprtBvhNodeType {
    pub const hiprtBvhNodeTypeInternal: hiprtBvhNodeType = hiprtBvhNodeType(0);
}
impl hiprtBvhNodeType {
    pub const hiprtBvhNodeTypeLeaf: hiprtBvhNodeType = hiprtBvhNodeType(1);
}
#[repr(transparent)]
#[doc = " \\brief Bvh node type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtBvhNodeType(pub ::std::os::raw::c_uint);
#[doc = " \\brief Ray data structure.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtRay {
    pub origin: hiprtFloat3,
    pub time: f32,
    pub direction: hiprtFloat3,
    pub maxT: f32,
}
#[doc = " \\brief Ray hit data structure.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtHit {
    pub instanceID: u32,
    pub primID: u32,
    pub uv: hiprtFloat2,
    pub normal: hiprtFloat3,
    pub t: f32,
}
#[doc = " \\brief Insersection function for custom primitives.\n\n \\param ray Ray.\n \\param primID Primtive ID.\n \\param data User data.\n \\param payload Payload for additional outputs.\n \\param uv Output texture coordinates.\n \\param normal Output normal.\n \\param t Output distance.\n \\return A flag indicating hit."]
pub type hiprtIntersectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        ray: *const hiprtRay,
        primID: u32,
        data: *const ::std::os::raw::c_void,
        payload: *mut ::std::os::raw::c_void,
        uv: *mut hiprtFloat2,
        normal: *mut hiprtFloat3,
        t: *mut f32,
    ) -> bool,
>;
#[doc = " \\brief Set of functions for custom primitives.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtCustomFuncSet {
    pub intersectFunc: hiprtIntersectFunc,
    pub intersectFuncData: *const ::std::os::raw::c_void,
}
impl hiprtDeviceType {
    pub const hiprtDeviceAMD: hiprtDeviceType = hiprtDeviceType(0);
}
impl hiprtDeviceType {
    pub const hiprtDeviceNVIDIA: hiprtDeviceType = hiprtDeviceType(1);
}
#[repr(transparent)]
#[doc = " \\brief Device type.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprtDeviceType(pub ::std::os::raw::c_uint);
#[doc = " \\brief Context creation input.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtContextCreationInput {
    pub ctxt: hiprtApiCtx,
    pub device: hiprtApiDevice,
    pub deviceType: hiprtDeviceType,
}
#[doc = " \\brief Various flags controlling scene/geometry build process.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtBuildOptions {
    pub buildFlags: hiprtBuildFlags,
}
#[doc = " \\brief Triangle mesh primitive.\n\n Triangle mesh primitive is represented as an indexed vertex array.\n Vertex and index arrays are defined using device pointers and strides.\n Each vertex has to have 3 components: (x, y, z) coordinates.\n Indices are organized into triples (i0, i1, i2) - one for each triangle."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtTriangleMeshPrimitive {
    pub vertices: hiprtDevicePtr,
    pub vertexCount: u32,
    pub vertexStride: u32,
    pub triangleIndices: hiprtDevicePtr,
    pub triangleCount: u32,
    pub triangleStride: u32,
}
#[doc = " \\brief AABB list primitive.\n\n AABB list is an array of axis aligned bounding boxes, represented\n by device memory pointer and stride between two consequetive boxes.\n Each AABB is a pair of float4 values (xmin, ymin, zmin, unused), (xmax, ymax,\n zmax, unused)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtAABBListPrimitive {
    pub aabbs: hiprtDevicePtr,
    pub aabbCount: u32,
    pub aabbStride: u32,
}
#[doc = " \\brief Bvh node for custom import Bvh.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtBvhNode {
    pub childIndices: [u32; 4usize],
    pub childNodeTypes: [hiprtBvhNodeType; 4usize],
    pub boundingBoxMin: hiprtFloat3,
    pub boundingBoxMax: hiprtFloat3,
    pub pad: [::std::os::raw::c_int; 2usize],
}
#[doc = " \\brief Bvh node list.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtBvhNodeList {
    pub nodes: hiprtDevicePtr,
    pub nodeCount: u32,
}
#[doc = " \\brief Input for geometry build/update operation.\n\n Build input defines concrete primitive type and a pointer to an actual\n primitive description."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtGeometryBuildInput {
    pub type_: hiprtPrimitiveType,
    pub __bindgen_anon_1: hiprtGeometryBuildInput__bindgen_ty_1,
    pub nodes: *mut hiprtBvhNodeList,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union hiprtGeometryBuildInput__bindgen_ty_1 {
    pub triangleMesh: hiprtGeometryBuildInput__bindgen_ty_1__bindgen_ty_1,
    pub aabbList: hiprtGeometryBuildInput__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtGeometryBuildInput__bindgen_ty_1__bindgen_ty_1 {
    pub primitive: *mut hiprtTriangleMeshPrimitive,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtGeometryBuildInput__bindgen_ty_1__bindgen_ty_2 {
    pub primitive: *mut hiprtAABBListPrimitive,
    pub customType: hiprtCustomType,
}
#[doc = " \\brief Build input for the scene.\n\n Scene consists of a set of instances. Each of the instances is defined by:\n  - Root pointer of the corresponding geometry\n  - Transformation header\n  - Mask\n\n Instances can refer to the same geometry but with different transformations\n (essentially implementing instancing). Mask is used to implement ray\n masking: ray mask is bitwise &ded with an instance mask, and no intersections\n are evaluated with the primitive of corresponding instance if the result is\n 0. The transformation header defines the offset and the number of consecutive\n transformation frames in the frame array for each instance. More than one frame\n is interpreted as motion blur. If the transformation headers is NULL, it\n assumes one frame per instance. Optionally, it is possible to import a custom\n BVH by setting nodes and the corresponding build flag."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtSceneBuildInput {
    pub instanceGeometries: hiprtDevicePtr,
    pub instanceTransformHeaders: hiprtDevicePtr,
    pub instanceFrames: hiprtDevicePtr,
    pub instanceMasks: hiprtDevicePtr,
    pub nodes: *mut hiprtBvhNodeList,
    pub instanceCount: u32,
    pub frameCount: u32,
}
#[doc = " \\brief Transformation frame.\n\n Defines scale, translation, rotation, and time."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtFrame {
    pub rotation: hiprtFloat4,
    pub scale: hiprtFloat3,
    pub translation: hiprtFloat3,
    pub time: f32,
    pub pad: ::std::os::raw::c_int,
}
#[doc = " \\brief Transformation header.\n\n Defines defines the index to the array of frames and the number of frames."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hiprtTransformHeader {
    pub frameIndex: u32,
    pub frameCount: u32,
}
extern crate libloading;
pub struct HipRt {
    __library: ::libloading::Library,
    pub hiprtCreateContext: Result<
        unsafe extern "C" fn(
            hiprtApiVersion: u32,
            input: *mut hiprtContextCreationInput,
            outContext: *mut hiprtContext,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyContext:
        Result<unsafe extern "C" fn(context: hiprtContext) -> hiprtError, ::libloading::Error>,
    pub hiprtCreateGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: *const hiprtBuildOptions,
            outGeometry: *mut hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyGeometry: Result<
        unsafe extern "C" fn(context: hiprtContext, outGeometry: hiprtGeometry) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: *const hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            outGeometry: hiprtGeometry,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetGeometryBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtGeometryBuildInput,
            buildOptions: *const hiprtBuildOptions,
            outSize: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetGeometryTraceTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            scene: hiprtGeometry,
            numRays: u32,
            outSize: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: *const hiprtBuildOptions,
            outScene: *mut hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyScene: Result<
        unsafe extern "C" fn(context: hiprtContext, outScene: hiprtScene) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildOperation: hiprtBuildOperation,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: *const hiprtBuildOptions,
            temporaryBuffer: hiprtDevicePtr,
            stream: hiprtApiStream,
            outScene: hiprtScene,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetSceneBuildTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            buildInput: *const hiprtSceneBuildInput,
            buildOptions: *const hiprtBuildOptions,
            outSize: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtGetSceneTraceTemporaryBufferSize: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            scene: hiprtScene,
            numRays: u32,
            outSize: *mut usize,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtCreateCustomFuncTable: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            outFuncTable: *mut hiprtCustomFuncTable,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSetCustomFuncTable: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            outFuncTable: hiprtCustomFuncTable,
            index: u32,
            set: hiprtCustomFuncSet,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtDestroyCustomFuncTable: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            outFuncTable: hiprtCustomFuncTable,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSaveGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            inGeometry: hiprtGeometry,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtLoadGeometry: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            outGeometry: *mut hiprtGeometry,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSaveScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            inScene: hiprtScene,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtLoadScene: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            outScene: *mut hiprtScene,
            filename: *const ::std::os::raw::c_char,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtExportGeometryAabb: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            inGeometry: hiprtGeometry,
            outAabbMin: *mut hiprtFloat3,
            outAabbMax: *mut hiprtFloat3,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtExportSceneAabb: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            inScene: hiprtScene,
            outAabbMin: *mut hiprtFloat3,
            outAabbMax: *mut hiprtFloat3,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildTraceProgram: Result<
        unsafe extern "C" fn(
            context: hiprtContext,
            functionName: *const ::std::os::raw::c_char,
            src: *const ::std::os::raw::c_char,
            name: *const ::std::os::raw::c_char,
            numHeaders: ::std::os::raw::c_int,
            headers: *mut *const ::std::os::raw::c_char,
            includeNames: *mut *const ::std::os::raw::c_char,
            options: *mut *const ::std::os::raw::c_char,
            nOptions: ::std::os::raw::c_int,
            progOut: *mut ::std::os::raw::c_void,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtBuildTraceGetBinary: Result<
        unsafe extern "C" fn(
            prog: *mut ::std::os::raw::c_void,
            size: *mut usize,
            binary: *mut ::std::os::raw::c_void,
        ) -> hiprtError,
        ::libloading::Error,
    >,
    pub hiprtSetCacheDirPath:
        Result<unsafe extern "C" fn(path: *const ::std::os::raw::c_char), ::libloading::Error>,
    pub hiprtSetLogLevel:
        Result<unsafe extern "C" fn(level: ::std::os::raw::c_int), ::libloading::Error>,
}
impl HipRt {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let hiprtCreateContext = __library.get(b"hiprtCreateContext\0").map(|sym| *sym);
        let hiprtDestroyContext = __library.get(b"hiprtDestroyContext\0").map(|sym| *sym);
        let hiprtCreateGeometry = __library.get(b"hiprtCreateGeometry\0").map(|sym| *sym);
        let hiprtDestroyGeometry = __library.get(b"hiprtDestroyGeometry\0").map(|sym| *sym);
        let hiprtBuildGeometry = __library.get(b"hiprtBuildGeometry\0").map(|sym| *sym);
        let hiprtGetGeometryBuildTemporaryBufferSize = __library
            .get(b"hiprtGetGeometryBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtGetGeometryTraceTemporaryBufferSize = __library
            .get(b"hiprtGetGeometryTraceTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtCreateScene = __library.get(b"hiprtCreateScene\0").map(|sym| *sym);
        let hiprtDestroyScene = __library.get(b"hiprtDestroyScene\0").map(|sym| *sym);
        let hiprtBuildScene = __library.get(b"hiprtBuildScene\0").map(|sym| *sym);
        let hiprtGetSceneBuildTemporaryBufferSize = __library
            .get(b"hiprtGetSceneBuildTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtGetSceneTraceTemporaryBufferSize = __library
            .get(b"hiprtGetSceneTraceTemporaryBufferSize\0")
            .map(|sym| *sym);
        let hiprtCreateCustomFuncTable = __library
            .get(b"hiprtCreateCustomFuncTable\0")
            .map(|sym| *sym);
        let hiprtSetCustomFuncTable = __library.get(b"hiprtSetCustomFuncTable\0").map(|sym| *sym);
        let hiprtDestroyCustomFuncTable = __library
            .get(b"hiprtDestroyCustomFuncTable\0")
            .map(|sym| *sym);
        let hiprtSaveGeometry = __library.get(b"hiprtSaveGeometry\0").map(|sym| *sym);
        let hiprtLoadGeometry = __library.get(b"hiprtLoadGeometry\0").map(|sym| *sym);
        let hiprtSaveScene = __library.get(b"hiprtSaveScene\0").map(|sym| *sym);
        let hiprtLoadScene = __library.get(b"hiprtLoadScene\0").map(|sym| *sym);
        let hiprtExportGeometryAabb = __library.get(b"hiprtExportGeometryAabb\0").map(|sym| *sym);
        let hiprtExportSceneAabb = __library.get(b"hiprtExportSceneAabb\0").map(|sym| *sym);
        let hiprtBuildTraceProgram = __library.get(b"hiprtBuildTraceProgram\0").map(|sym| *sym);
        let hiprtBuildTraceGetBinary = __library.get(b"hiprtBuildTraceGetBinary\0").map(|sym| *sym);
        let hiprtSetCacheDirPath = __library.get(b"hiprtSetCacheDirPath\0").map(|sym| *sym);
        let hiprtSetLogLevel = __library.get(b"hiprtSetLogLevel\0").map(|sym| *sym);
        Ok(HipRt {
            __library,
            hiprtCreateContext,
            hiprtDestroyContext,
            hiprtCreateGeometry,
            hiprtDestroyGeometry,
            hiprtBuildGeometry,
            hiprtGetGeometryBuildTemporaryBufferSize,
            hiprtGetGeometryTraceTemporaryBufferSize,
            hiprtCreateScene,
            hiprtDestroyScene,
            hiprtBuildScene,
            hiprtGetSceneBuildTemporaryBufferSize,
            hiprtGetSceneTraceTemporaryBufferSize,
            hiprtCreateCustomFuncTable,
            hiprtSetCustomFuncTable,
            hiprtDestroyCustomFuncTable,
            hiprtSaveGeometry,
            hiprtLoadGeometry,
            hiprtSaveScene,
            hiprtLoadScene,
            hiprtExportGeometryAabb,
            hiprtExportSceneAabb,
            hiprtBuildTraceProgram,
            hiprtBuildTraceGetBinary,
            hiprtSetCacheDirPath,
            hiprtSetLogLevel,
        })
    }
    #[must_use]
    #[doc = " \\brief Create HIPRT API context.\n\n All HIPRT functions expect context as their first argument. Context\n keeps global data required by HIPRT session. Calls made from different\n threads with different HIPRT contexts are safe. Calls with the same context\n should be externally synchronized by the client.\n\n \\param hiprtApiVersion API version.\n \\param outContext Created context.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateContext(
        &self,
        hiprtApiVersion: u32,
        input: *mut hiprtContextCreationInput,
        outContext: *mut hiprtContext,
    ) -> hiprtError {
        (self
            .hiprtCreateContext
            .as_ref()
            .expect("Expected function, got error."))(hiprtApiVersion, input, outContext)
    }
    #[must_use]
    #[doc = " \\brief Destory HIPRT API context.\n\n Destroys all the global resources used by HIPRT session. Further calls\n with this context are prohibited.\n\n \\param context API context.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyContext(&self, context: hiprtContext) -> hiprtError {
        (self
            .hiprtDestroyContext
            .as_ref()
            .expect("Expected function, got error."))(context)
    }
    #[must_use]
    #[doc = " \\brief Create a geometry.\n\n This function creates\n hiprtGeometry representing acceleration structure topology.\n\n \\param context HIPRT API context.\n \\param buildInput Describes input primitive to build geometry from.\n \\param buildOptions Various flags controlling build process.\n \\param outGeometry Resulting geometry.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateGeometry(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: *const hiprtBuildOptions,
        outGeometry: *mut hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtCreateGeometry
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildInput,
            buildOptions,
            outGeometry,
        )
    }
    #[must_use]
    #[doc = " \\brief Destroy a geometry.\n\n This function destroys\n hiprtGeometry representing acceleration structure topology.\n\n \\param context HIPRT API context.\n \\param outGeometry Resulting geometry.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyGeometry(
        &self,
        context: hiprtContext,
        outGeometry: hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtDestroyGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, outGeometry)
    }
    #[must_use]
    #[doc = " \\brief Build or update a geometry.\n\n Given geometry description from the client, this function builds\n hiprtGeometry representing acceleration structure topology (in case of a\n build) or updates acceleration structure keeping topology intact (update).\n\n \\param context HIPRT API context.\n \\param buildOperation Type of build operation.\n \\param buildInput Describes input primitive to build geometry from.\n \\param buildOptions Various flags controlling build process.\n \\param attributeOutputs Describes additional values written into vidmem.\n \\param attributeOutputCount Number of additional attributes, can be 0.\n \\param temporaryBuffer Temporary buffer for build operation.\n \\param stream to run acceleration structure build command.\n \\param outGeometry Resulting geometry.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildGeometry(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: *const hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        outGeometry: hiprtGeometry,
    ) -> hiprtError {
        (self
            .hiprtBuildGeometry
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            buildInput,
            buildOptions,
            temporaryBuffer,
            stream,
            outGeometry,
        )
    }
    #[must_use]
    #[doc = " \\brief Get temporary storage requirements for geometry build.\n\n \\param context HIPRT API context.\n \\param buildInput Describes input primitive to build geometry from.\n \\param buildOptions Various flags controlling build process.\n \\param outSize Pointer to write result to.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetGeometryBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtGeometryBuildInput,
        buildOptions: *const hiprtBuildOptions,
        outSize: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetGeometryBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, outSize
        )
    }
    #[must_use]
    #[doc = " \\brief Get temporary storage requirements for scene trace.\n\n \\param context HIPRT API context.\n \\param scene Built scene for trace.\n \\param numRays Rays to be issued.\n \\param outSize Pointer to write result to.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetGeometryTraceTemporaryBufferSize(
        &self,
        context: hiprtContext,
        scene: hiprtGeometry,
        numRays: u32,
        outSize: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetGeometryTraceTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(context, scene, numRays, outSize)
    }
    #[must_use]
    #[doc = " \\brief Create a scene.\n\n This function creates\n hiprtScene representing acceleration structure topology.\n\n \\param context HIPRT API context.\n \\param buildInput Decribes input geometires to build scene for.\n \\param buildOptions Various flags controlling build process.\n \\param outScene Resulting scene.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateScene(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: *const hiprtBuildOptions,
        outScene: *mut hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtCreateScene
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, outScene
        )
    }
    #[must_use]
    #[doc = " \\brief Destroy a scene.\n\n This function destroys\n hiprtScene representing acceleration structure topology.\n\n \\param context HIPRT API context.\n \\param outScene Resulting scene.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyScene(
        &self,
        context: hiprtContext,
        outScene: hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtDestroyScene
            .as_ref()
            .expect("Expected function, got error."))(context, outScene)
    }
    #[must_use]
    #[doc = " \\brief Build or update a scene.\n\n Given a number of hiprtGeometries from the client, this function builds\n hiprtScene representing top level acceleration structure topology (in case of\n a build) or updates acceleration structure keeping topology intact (update).\n\n \\param context HIPRT API context.\n \\param buildOperation Type of build operation.\n \\param buildInput Decribes input geometires to build scene for.\n \\param buildOptions Various flags controlling build process.\n \\param temporaryBuffer Temporary buffer for build operation.\n \\param stream to run acceleration structure build command.\n \\param outScene Resulting scene.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildScene(
        &self,
        context: hiprtContext,
        buildOperation: hiprtBuildOperation,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: *const hiprtBuildOptions,
        temporaryBuffer: hiprtDevicePtr,
        stream: hiprtApiStream,
        outScene: hiprtScene,
    ) -> hiprtError {
        (self
            .hiprtBuildScene
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            buildOperation,
            buildInput,
            buildOptions,
            temporaryBuffer,
            stream,
            outScene,
        )
    }
    #[must_use]
    #[doc = " \\brief Get temporary storage requirements for scene build.\n\n \\param context HIPRT API context.\n \\param buildInput Decribes input geometires to build scene for.\n \\param buildOptions Various flags controlling build process.\n \\param outSize Pointer to write result to.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetSceneBuildTemporaryBufferSize(
        &self,
        context: hiprtContext,
        buildInput: *const hiprtSceneBuildInput,
        buildOptions: *const hiprtBuildOptions,
        outSize: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetSceneBuildTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(
            context, buildInput, buildOptions, outSize
        )
    }
    #[must_use]
    #[doc = " \\brief Get temporary storage requirements for scene trace.\n\n \\param context HIPRT API context.\n \\param scene Built scene for trace.\n \\param numRays Rays to be issued.\n \\param outSize Pointer to write result to.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtGetSceneTraceTemporaryBufferSize(
        &self,
        context: hiprtContext,
        scene: hiprtScene,
        numRays: u32,
        outSize: *mut usize,
    ) -> hiprtError {
        (self
            .hiprtGetSceneTraceTemporaryBufferSize
            .as_ref()
            .expect("Expected function, got error."))(context, scene, numRays, outSize)
    }
    #[must_use]
    #[doc = " \\brief Creates a custom function table (for custom geometry).\n\n \\param context HIPRT API context.\n \\param outFuncTable Resulting table.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtCreateCustomFuncTable(
        &self,
        context: hiprtContext,
        outFuncTable: *mut hiprtCustomFuncTable,
    ) -> hiprtError {
        (self
            .hiprtCreateCustomFuncTable
            .as_ref()
            .expect("Expected function, got error."))(context, outFuncTable)
    }
    #[must_use]
    #[doc = " \\brief Sets a custom function table.\n\n \\param context HIPRT API context.\n \\param outFuncTable Resulting table.\n \\param index Index of the set in the table.\n \\param set Function set to be set.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSetCustomFuncTable(
        &self,
        context: hiprtContext,
        outFuncTable: hiprtCustomFuncTable,
        index: u32,
        set: hiprtCustomFuncSet,
    ) -> hiprtError {
        (self
            .hiprtSetCustomFuncTable
            .as_ref()
            .expect("Expected function, got error."))(context, outFuncTable, index, set)
    }
    #[must_use]
    #[doc = " \\brief Destroys a custom function table.\n\n \\param context HIPRT API context.\n \\param outFuncTable Resulting table.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtDestroyCustomFuncTable(
        &self,
        context: hiprtContext,
        outFuncTable: hiprtCustomFuncTable,
    ) -> hiprtError {
        (self
            .hiprtDestroyCustomFuncTable
            .as_ref()
            .expect("Expected function, got error."))(context, outFuncTable)
    }
    #[must_use]
    #[doc = " \\brief Saves hiprtGeometry to a binary file.\n\n \\param context HIPRT API context.\n \\param inGeometry Geometry to be saved.\n \\param filename File name with full path.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSaveGeometry(
        &self,
        context: hiprtContext,
        inGeometry: hiprtGeometry,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtSaveGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, inGeometry, filename)
    }
    #[must_use]
    #[doc = " \\brief Loads hiprtGeometry to a binary file.\n\n \\param context HIPRT API context.\n \\param outGeometry Geometry to be loaded.\n \\param filename File name with full path.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtLoadGeometry(
        &self,
        context: hiprtContext,
        outGeometry: *mut hiprtGeometry,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtLoadGeometry
            .as_ref()
            .expect("Expected function, got error."))(context, outGeometry, filename)
    }
    #[must_use]
    #[doc = " \\brief Saves hiprtScene to a binary file.\n\n \\param context HIPRT API context.\n \\param inScene Scene to be saved.\n \\param filename File name with full path.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtSaveScene(
        &self,
        context: hiprtContext,
        inScene: hiprtScene,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtSaveScene
            .as_ref()
            .expect("Expected function, got error."))(context, inScene, filename)
    }
    #[must_use]
    #[doc = " \\brief Loads hiprtScene to a binary file.\n\n \\param context HIPRT API context.\n \\param outScene Scene to be loaded.\n \\param filename File name with full path.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtLoadScene(
        &self,
        context: hiprtContext,
        outScene: *mut hiprtScene,
        filename: *const ::std::os::raw::c_char,
    ) -> hiprtError {
        (self
            .hiprtLoadScene
            .as_ref()
            .expect("Expected function, got error."))(context, outScene, filename)
    }
    #[must_use]
    #[doc = " \\brief Output scene's AABB.\n\n \\param context HIPRT API context.\n \\param inGeometry Geometry to be queried.\n \\param outAabbMin The bounding box min. bound.\n \\param outAabbMax The bounding box max. bound.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtExportGeometryAabb(
        &self,
        context: hiprtContext,
        inGeometry: hiprtGeometry,
        outAabbMin: *mut hiprtFloat3,
        outAabbMax: *mut hiprtFloat3,
    ) -> hiprtError {
        (self
            .hiprtExportGeometryAabb
            .as_ref()
            .expect("Expected function, got error."))(
            context, inGeometry, outAabbMin, outAabbMax
        )
    }
    #[must_use]
    #[doc = " \\brief Output scene's AABB.\n\n \\param context HIPRT API context.\n \\param inScene Scene to be queried.\n \\param outAabbMin The bounding box min. bound.\n \\param outAabbMax The bounding box max. bound.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtExportSceneAabb(
        &self,
        context: hiprtContext,
        inScene: hiprtScene,
        outAabbMin: *mut hiprtFloat3,
        outAabbMax: *mut hiprtFloat3,
    ) -> hiprtError {
        (self
            .hiprtExportSceneAabb
            .as_ref()
            .expect("Expected function, got error."))(
            context, inScene, outAabbMin, outAabbMax
        )
    }
    #[must_use]
    #[doc = " \\brief Get Program instance with HIPRT routines.\n \\param functionName function to which handle will be returned, cannot be NULL.\n \\param context HIPRT API context.\n \\param src HIP program source.\n \\param name Program source filename.\n \\param numHeaders Number of headers, numHeaders must be greater than or equal to 0.\n \\param headers Sources of the headers, headers can be NULL when numHeaders is 0.\n \\param includeNames Name of each header by which they can be included in the HIP program source, includeNames can be NULL\n when numHeaders is 0.\n \\param options Compiler options, can be NULL.\n \\param progOut Output build program instance.\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildTraceProgram(
        &self,
        context: hiprtContext,
        functionName: *const ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        numHeaders: ::std::os::raw::c_int,
        headers: *mut *const ::std::os::raw::c_char,
        includeNames: *mut *const ::std::os::raw::c_char,
        options: *mut *const ::std::os::raw::c_char,
        nOptions: ::std::os::raw::c_int,
        progOut: *mut ::std::os::raw::c_void,
    ) -> hiprtError {
        (self
            .hiprtBuildTraceProgram
            .as_ref()
            .expect("Expected function, got error."))(
            context,
            functionName,
            src,
            name,
            numHeaders,
            headers,
            includeNames,
            options,
            nOptions,
            progOut,
        )
    }
    #[must_use]
    #[doc = " \\brief Get binary with HIPRT routines.\n\n \\param prog program instance.\n \\param size Output size of binary .\n \\param binary Output if NULL function returns size of parameter else returned binary(application should allocate for binary)..\n \\return HIPRT error in case of a failure, hiprtSuccess otherwise."]
    pub unsafe fn hiprtBuildTraceGetBinary(
        &self,
        prog: *mut ::std::os::raw::c_void,
        size: *mut usize,
        binary: *mut ::std::os::raw::c_void,
    ) -> hiprtError {
        (self
            .hiprtBuildTraceGetBinary
            .as_ref()
            .expect("Expected function, got error."))(prog, size, binary)
    }
    #[doc = " \\brief Setting log level.\n\n \\param path user defined path to cache kernels."]
    pub unsafe fn hiprtSetCacheDirPath(&self, path: *const ::std::os::raw::c_char) {
        (self
            .hiprtSetCacheDirPath
            .as_ref()
            .expect("Expected function, got error."))(path)
    }
    #[doc = " \\brief Setting log level.\n\n \\param level Desired log level."]
    pub unsafe fn hiprtSetLogLevel(&self, level: ::std::os::raw::c_int) {
        (self
            .hiprtSetLogLevel
            .as_ref()
            .expect("Expected function, got error."))(level)
    }
}
