/* automatically generated by rust-bindgen 0.58.1 */

#[doc = ""]
#[doc = " @brief compiler-independent type"]
pub type ze_bool_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of a driver instance"]
pub type ze_driver_handle_t = *mut _ze_driver_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's device object"]
pub type ze_device_handle_t = *mut _ze_device_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's context object"]
pub type ze_context_handle_t = *mut _ze_context_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command queue object"]
pub type ze_command_queue_handle_t = *mut _ze_command_queue_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command list object"]
pub type ze_command_list_handle_t = *mut _ze_command_list_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's fence object"]
pub type ze_fence_handle_t = *mut _ze_fence_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event pool object"]
pub type ze_event_pool_handle_t = *mut _ze_event_pool_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event object"]
pub type ze_event_handle_t = *mut _ze_event_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's image object"]
pub type ze_image_handle_t = *mut _ze_image_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's module object"]
pub type ze_module_handle_t = *mut _ze_module_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_build_log_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of module's build log object"]
pub type ze_module_build_log_handle_t = *mut _ze_module_build_log_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's kernel object"]
pub type ze_kernel_handle_t = *mut _ze_kernel_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's sampler object"]
pub type ze_sampler_handle_t = *mut _ze_sampler_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of physical memory object"]
pub type ze_physical_mem_handle_t = *mut _ze_physical_mem_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_mem_handle_t {
    #[doc = "< [out] Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_mem_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_mem_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_mem_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_ipc_mem_handle_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_mem_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
pub type ze_ipc_mem_handle_t = _ze_ipc_mem_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_event_pool_handle_t {
    #[doc = "< [out] Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_event_pool_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_event_pool_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_event_pool_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_ipc_event_pool_handle_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_event_pool_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
pub type ze_ipc_event_pool_handle_t = _ze_ipc_event_pool_handle_t;
impl _ze_result_t {
    #[doc = "< [Core] success"]
    pub const ZE_RESULT_SUCCESS: _ze_result_t = _ze_result_t(0);
}
impl _ze_result_t {
    #[doc = "< [Core] synchronization primitive not signaled"]
    pub const ZE_RESULT_NOT_READY: _ze_result_t = _ze_result_t(1);
}
impl _ze_result_t {
    #[doc = "< [Core] device hung, reset, was removed, or driver update occurred"]
    pub const ZE_RESULT_ERROR_DEVICE_LOST: _ze_result_t = _ze_result_t(1879048193);
}
impl _ze_result_t {
    #[doc = "< [Core] insufficient host memory to satisfy call"]
    pub const ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY: _ze_result_t = _ze_result_t(1879048194);
}
impl _ze_result_t {
    #[doc = "< [Core] insufficient device memory to satisfy call"]
    pub const ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY: _ze_result_t = _ze_result_t(1879048195);
}
impl _ze_result_t {
    #[doc = "< [Core] error occurred when building module, see build log for details"]
    pub const ZE_RESULT_ERROR_MODULE_BUILD_FAILURE: _ze_result_t = _ze_result_t(1879048196);
}
impl _ze_result_t {
    #[doc = "< [Core] error occurred when linking modules, see build log for details"]
    pub const ZE_RESULT_ERROR_MODULE_LINK_FAILURE: _ze_result_t = _ze_result_t(1879048197);
}
impl _ze_result_t {
    #[doc = "< [Sysman] access denied due to permission level"]
    pub const ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS: _ze_result_t = _ze_result_t(1879113728);
}
impl _ze_result_t {
    #[doc = "< [Sysman] resource already in use and simultaneous access not allowed"]
    #[doc = "< or resource was removed"]
    pub const ZE_RESULT_ERROR_NOT_AVAILABLE: _ze_result_t = _ze_result_t(1879113729);
}
impl _ze_result_t {
    #[doc = "< [Tools] external required dependency is unavailable or missing"]
    pub const ZE_RESULT_ERROR_DEPENDENCY_UNAVAILABLE: _ze_result_t = _ze_result_t(1879179264);
}
impl _ze_result_t {
    #[doc = "< [Validation] driver is not initialized"]
    pub const ZE_RESULT_ERROR_UNINITIALIZED: _ze_result_t = _ze_result_t(2013265921);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for unsupported versions"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_VERSION: _ze_result_t = _ze_result_t(2013265922);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for unsupported features"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_FEATURE: _ze_result_t = _ze_result_t(2013265923);
}
impl _ze_result_t {
    #[doc = "< [Validation] generic error code for invalid arguments"]
    pub const ZE_RESULT_ERROR_INVALID_ARGUMENT: _ze_result_t = _ze_result_t(2013265924);
}
impl _ze_result_t {
    #[doc = "< [Validation] handle argument is not valid"]
    pub const ZE_RESULT_ERROR_INVALID_NULL_HANDLE: _ze_result_t = _ze_result_t(2013265925);
}
impl _ze_result_t {
    #[doc = "< [Validation] object pointed to by handle still in-use by device"]
    pub const ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE: _ze_result_t = _ze_result_t(2013265926);
}
impl _ze_result_t {
    #[doc = "< [Validation] pointer argument may not be nullptr"]
    pub const ZE_RESULT_ERROR_INVALID_NULL_POINTER: _ze_result_t = _ze_result_t(2013265927);
}
impl _ze_result_t {
    #[doc = "< [Validation] size argument is invalid (e.g., must not be zero)"]
    pub const ZE_RESULT_ERROR_INVALID_SIZE: _ze_result_t = _ze_result_t(2013265928);
}
impl _ze_result_t {
    #[doc = "< [Validation] size argument is not supported by the device (e.g., too"]
    #[doc = "< large)"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_SIZE: _ze_result_t = _ze_result_t(2013265929);
}
impl _ze_result_t {
    #[doc = "< [Validation] alignment argument is not supported by the device (e.g.,"]
    #[doc = "< too small)"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT: _ze_result_t = _ze_result_t(2013265930);
}
impl _ze_result_t {
    #[doc = "< [Validation] synchronization object in invalid state"]
    pub const ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT: _ze_result_t =
        _ze_result_t(2013265931);
}
impl _ze_result_t {
    #[doc = "< [Validation] enumerator argument is not valid"]
    pub const ZE_RESULT_ERROR_INVALID_ENUMERATION: _ze_result_t = _ze_result_t(2013265932);
}
impl _ze_result_t {
    #[doc = "< [Validation] enumerator argument is not supported by the device"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_ENUMERATION: _ze_result_t = _ze_result_t(2013265933);
}
impl _ze_result_t {
    #[doc = "< [Validation] image format is not supported by the device"]
    pub const ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT: _ze_result_t = _ze_result_t(2013265934);
}
impl _ze_result_t {
    #[doc = "< [Validation] native binary is not supported by the device"]
    pub const ZE_RESULT_ERROR_INVALID_NATIVE_BINARY: _ze_result_t = _ze_result_t(2013265935);
}
impl _ze_result_t {
    #[doc = "< [Validation] global variable is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_GLOBAL_NAME: _ze_result_t = _ze_result_t(2013265936);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel name is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_NAME: _ze_result_t = _ze_result_t(2013265937);
}
impl _ze_result_t {
    #[doc = "< [Validation] function name is not found in the module"]
    pub const ZE_RESULT_ERROR_INVALID_FUNCTION_NAME: _ze_result_t = _ze_result_t(2013265938);
}
impl _ze_result_t {
    #[doc = "< [Validation] group size dimension is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION: _ze_result_t = _ze_result_t(2013265939);
}
impl _ze_result_t {
    #[doc = "< [Validation] global width dimension is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION: _ze_result_t =
        _ze_result_t(2013265940);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel argument index is not valid for kernel"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX: _ze_result_t =
        _ze_result_t(2013265941);
}
impl _ze_result_t {
    #[doc = "< [Validation] kernel argument size does not match kernel"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE: _ze_result_t = _ze_result_t(2013265942);
}
impl _ze_result_t {
    #[doc = "< [Validation] value of kernel attribute is not valid for the kernel or"]
    #[doc = "< device"]
    pub const ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE: _ze_result_t =
        _ze_result_t(2013265943);
}
impl _ze_result_t {
    #[doc = "< [Validation] module with imports needs to be linked before kernels can"]
    #[doc = "< be created from it."]
    pub const ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED: _ze_result_t = _ze_result_t(2013265944);
}
impl _ze_result_t {
    #[doc = "< [Validation] command list type does not match command queue type"]
    pub const ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE: _ze_result_t = _ze_result_t(2013265945);
}
impl _ze_result_t {
    #[doc = "< [Validation] copy operations do not support overlapping regions of"]
    #[doc = "< memory"]
    pub const ZE_RESULT_ERROR_OVERLAPPING_REGIONS: _ze_result_t = _ze_result_t(2013265946);
}
impl _ze_result_t {
    #[doc = "< [Core] unknown or internal error"]
    pub const ZE_RESULT_ERROR_UNKNOWN: _ze_result_t = _ze_result_t(2147483646);
}
impl _ze_result_t {
    pub const ZE_RESULT_FORCE_UINT32: _ze_result_t = _ze_result_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
#[must_use]
pub struct _ze_result_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
pub use self::_ze_result_t as ze_result_t;
impl _ze_structure_type_t {
    #[doc = "< ::ze_driver_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DRIVER_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(1);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_driver_ipc_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DRIVER_IPC_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(2);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(3);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_compute_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_COMPUTE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(4);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_module_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MODULE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(5);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_queue_group_properties_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_QUEUE_GROUP_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(6);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_memory_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEMORY_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(7);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_memory_access_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEMORY_ACCESS_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(8);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_cache_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_CACHE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(9);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_image_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_IMAGE_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(10);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_p2p_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_P2P_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(11);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_external_memory_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_EXTERNAL_MEMORY_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(12);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_context_desc_t"]
    pub const ZE_STRUCTURE_TYPE_CONTEXT_DESC: _ze_structure_type_t = _ze_structure_type_t(13);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_queue_desc_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_QUEUE_DESC: _ze_structure_type_t = _ze_structure_type_t(14);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_command_list_desc_t"]
    pub const ZE_STRUCTURE_TYPE_COMMAND_LIST_DESC: _ze_structure_type_t = _ze_structure_type_t(15);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_event_pool_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EVENT_POOL_DESC: _ze_structure_type_t = _ze_structure_type_t(16);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_event_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EVENT_DESC: _ze_structure_type_t = _ze_structure_type_t(17);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_fence_desc_t"]
    pub const ZE_STRUCTURE_TYPE_FENCE_DESC: _ze_structure_type_t = _ze_structure_type_t(18);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_image_desc_t"]
    pub const ZE_STRUCTURE_TYPE_IMAGE_DESC: _ze_structure_type_t = _ze_structure_type_t(19);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_image_properties_t"]
    pub const ZE_STRUCTURE_TYPE_IMAGE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(20);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_mem_alloc_desc_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_MEM_ALLOC_DESC: _ze_structure_type_t =
        _ze_structure_type_t(21);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_host_mem_alloc_desc_t"]
    pub const ZE_STRUCTURE_TYPE_HOST_MEM_ALLOC_DESC: _ze_structure_type_t =
        _ze_structure_type_t(22);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_memory_allocation_properties_t"]
    pub const ZE_STRUCTURE_TYPE_MEMORY_ALLOCATION_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(23);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_export_desc_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_DESC: _ze_structure_type_t =
        _ze_structure_type_t(24);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_import_fd_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMPORT_FD: _ze_structure_type_t =
        _ze_structure_type_t(25);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_external_memory_export_fd_t"]
    pub const ZE_STRUCTURE_TYPE_EXTERNAL_MEMORY_EXPORT_FD: _ze_structure_type_t =
        _ze_structure_type_t(26);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_desc_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_DESC: _ze_structure_type_t = _ze_structure_type_t(27);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_properties_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(28);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_kernel_desc_t"]
    pub const ZE_STRUCTURE_TYPE_KERNEL_DESC: _ze_structure_type_t = _ze_structure_type_t(29);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_kernel_properties_t"]
    pub const ZE_STRUCTURE_TYPE_KERNEL_PROPERTIES: _ze_structure_type_t = _ze_structure_type_t(30);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_sampler_desc_t"]
    pub const ZE_STRUCTURE_TYPE_SAMPLER_DESC: _ze_structure_type_t = _ze_structure_type_t(31);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_physical_mem_desc_t"]
    pub const ZE_STRUCTURE_TYPE_PHYSICAL_MEM_DESC: _ze_structure_type_t = _ze_structure_type_t(32);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_device_raytracing_ext_properties_t"]
    pub const ZE_STRUCTURE_TYPE_DEVICE_RAYTRACING_EXT_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(65537);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_raytracing_mem_alloc_ext_desc_t"]
    pub const ZE_STRUCTURE_TYPE_RAYTRACING_MEM_ALLOC_EXT_DESC: _ze_structure_type_t =
        _ze_structure_type_t(65538);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_float_atomic_ext_properties_t"]
    pub const ZE_STRUCTURE_TYPE_FLOAT_ATOMIC_EXT_PROPERTIES: _ze_structure_type_t =
        _ze_structure_type_t(65539);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_relaxed_allocation_limits_exp_desc_t"]
    pub const ZE_STRUCTURE_TYPE_RELAXED_ALLOCATION_LIMITS_EXP_DESC: _ze_structure_type_t =
        _ze_structure_type_t(131073);
}
impl _ze_structure_type_t {
    #[doc = "< ::ze_module_program_exp_desc_t"]
    pub const ZE_STRUCTURE_TYPE_MODULE_PROGRAM_EXP_DESC: _ze_structure_type_t =
        _ze_structure_type_t(131074);
}
impl _ze_structure_type_t {
    pub const ZE_STRUCTURE_TYPE_FORCE_UINT32: _ze_structure_type_t =
        _ze_structure_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Defines structure types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_structure_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Defines structure types"]
pub use self::_ze_structure_type_t as ze_structure_type_t;
impl _ze_external_memory_type_flags_t {
    #[doc = "< an opaque POSIX file descriptor handle"]
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_OPAQUE_FD: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(1);
}
impl _ze_external_memory_type_flags_t {
    #[doc = "< a file descriptor handle for a Linux dma_buf"]
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_DMA_BUF: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(2);
}
impl _ze_external_memory_type_flags_t {
    pub const ZE_EXTERNAL_MEMORY_TYPE_FLAG_FORCE_UINT32: _ze_external_memory_type_flags_t =
        _ze_external_memory_type_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_external_memory_type_flags_t> for _ze_external_memory_type_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_external_memory_type_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_external_memory_type_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_external_memory_type_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_external_memory_type_flags_t> for _ze_external_memory_type_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_external_memory_type_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_external_memory_type_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_external_memory_type_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief External memory type flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_external_memory_type_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief External memory type flags"]
pub use self::_ze_external_memory_type_flags_t as ze_external_memory_type_flags_t;
#[doc = ""]
#[doc = " @brief Base for all properties types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_base_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_base_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_base_properties_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_base_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_base_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_base_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_base_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_base_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_base_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_base_properties_t),
            "::",
            stringify!(pNext)
        )
    );
}
impl Default for _ze_base_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = ""]
#[doc = " @brief Base for all properties types"]
pub type ze_base_properties_t = _ze_base_properties_t;
#[doc = ""]
#[doc = " @brief Base for all descriptor types"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_base_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_base_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_base_desc_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_base_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_base_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_base_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_base_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_base_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_base_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_base_desc_t),
            "::",
            stringify!(pNext)
        )
    );
}
#[doc = ""]
#[doc = " @brief Base for all descriptor types"]
pub type ze_base_desc_t = _ze_base_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_uuid_t"]
pub type ze_driver_uuid_t = _ze_driver_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_properties_t"]
pub type ze_driver_properties_t = _ze_driver_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_ipc_properties_t"]
pub type ze_driver_ipc_properties_t = _ze_driver_ipc_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_extension_properties_t"]
pub type ze_driver_extension_properties_t = _ze_driver_extension_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_uuid_t"]
pub type ze_device_uuid_t = _ze_device_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_properties_t"]
pub type ze_device_properties_t = _ze_device_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_thread_t"]
pub type ze_device_thread_t = _ze_device_thread_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_compute_properties_t"]
pub type ze_device_compute_properties_t = _ze_device_compute_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_native_kernel_uuid_t"]
pub type ze_native_kernel_uuid_t = _ze_native_kernel_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_module_properties_t"]
pub type ze_device_module_properties_t = _ze_device_module_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_queue_group_properties_t"]
pub type ze_command_queue_group_properties_t = _ze_command_queue_group_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_properties_t"]
pub type ze_device_memory_properties_t = _ze_device_memory_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_access_properties_t"]
pub type ze_device_memory_access_properties_t = _ze_device_memory_access_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_cache_properties_t"]
pub type ze_device_cache_properties_t = _ze_device_cache_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_image_properties_t"]
pub type ze_device_image_properties_t = _ze_device_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_external_memory_properties_t"]
pub type ze_device_external_memory_properties_t = _ze_device_external_memory_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_p2p_properties_t"]
pub type ze_device_p2p_properties_t = _ze_device_p2p_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_context_desc_t"]
pub type ze_context_desc_t = _ze_context_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_queue_desc_t"]
pub type ze_command_queue_desc_t = _ze_command_queue_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_list_desc_t"]
pub type ze_command_list_desc_t = _ze_command_list_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_copy_region_t"]
pub type ze_copy_region_t = _ze_copy_region_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_region_t"]
pub type ze_image_region_t = _ze_image_region_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_pool_desc_t"]
pub type ze_event_pool_desc_t = _ze_event_pool_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_desc_t"]
pub type ze_event_desc_t = _ze_event_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_timestamp_data_t"]
pub type ze_kernel_timestamp_data_t = _ze_kernel_timestamp_data_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_timestamp_result_t"]
pub type ze_kernel_timestamp_result_t = _ze_kernel_timestamp_result_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_fence_desc_t"]
pub type ze_fence_desc_t = _ze_fence_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_format_t"]
pub type ze_image_format_t = _ze_image_format_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_desc_t"]
pub type ze_image_desc_t = _ze_image_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_properties_t"]
pub type ze_image_properties_t = _ze_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_mem_alloc_desc_t"]
pub type ze_device_mem_alloc_desc_t = _ze_device_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_host_mem_alloc_desc_t"]
pub type ze_host_mem_alloc_desc_t = _ze_host_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_memory_allocation_properties_t"]
pub type ze_memory_allocation_properties_t = _ze_memory_allocation_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_external_memory_export_desc_t"]
pub type ze_external_memory_export_desc_t = _ze_external_memory_export_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_external_memory_import_fd_t"]
pub type ze_external_memory_import_fd_t = _ze_external_memory_import_fd_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_external_memory_export_fd_t"]
pub type ze_external_memory_export_fd_t = _ze_external_memory_export_fd_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_constants_t"]
pub type ze_module_constants_t = _ze_module_constants_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_desc_t"]
pub type ze_module_desc_t = _ze_module_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_properties_t"]
pub type ze_module_properties_t = _ze_module_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_desc_t"]
pub type ze_kernel_desc_t = _ze_kernel_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_uuid_t"]
pub type ze_kernel_uuid_t = _ze_kernel_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_properties_t"]
pub type ze_kernel_properties_t = _ze_kernel_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_group_count_t"]
pub type ze_group_count_t = _ze_group_count_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_program_exp_desc_t"]
pub type ze_module_program_exp_desc_t = _ze_module_program_exp_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_raytracing_ext_properties_t"]
pub type ze_device_raytracing_ext_properties_t = _ze_device_raytracing_ext_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_raytracing_mem_alloc_ext_desc_t"]
pub type ze_raytracing_mem_alloc_ext_desc_t = _ze_raytracing_mem_alloc_ext_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_sampler_desc_t"]
pub type ze_sampler_desc_t = _ze_sampler_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_physical_mem_desc_t"]
pub type ze_physical_mem_desc_t = _ze_physical_mem_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_float_atomic_ext_properties_t"]
pub type ze_float_atomic_ext_properties_t = _ze_float_atomic_ext_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_relaxed_allocation_limits_exp_desc_t"]
pub type ze_relaxed_allocation_limits_exp_desc_t = _ze_relaxed_allocation_limits_exp_desc_t;
impl _ze_init_flags_t {
    #[doc = "< only initialize GPU drivers"]
    pub const ZE_INIT_FLAG_GPU_ONLY: _ze_init_flags_t = _ze_init_flags_t(1);
}
impl _ze_init_flags_t {
    pub const ZE_INIT_FLAG_FORCE_UINT32: _ze_init_flags_t = _ze_init_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_init_flags_t> for _ze_init_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_init_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_init_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_init_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_init_flags_t> for _ze_init_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_init_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_init_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_init_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_init_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
pub use self::_ze_init_flags_t as ze_init_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initialize the 'oneAPI' driver(s)"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must call this function before calling any other"]
    #[doc = "       function."]
    #[doc = "     - If this function is not called then all other functions will return"]
    #[doc = "       ::ZE_RESULT_ERROR_UNINITIALIZED."]
    #[doc = "     - Only one instance of each driver will be initialized per process."]
    #[doc = "     - The application may call this function multiple times with different"]
    #[doc = "       flags or environment variables enabled."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe for scenarios"]
    #[doc = "       where multiple libraries may initialize the driver(s) simultaneously."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeInit(flags: ze_init_flags_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves driver instances"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A driver represents a collection of physical devices."]
    #[doc = "     - Multiple calls to this function will return identical driver handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The application may pass nullptr for pDrivers when only querying the"]
    #[doc = "       number of drivers."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetPlatformIDs"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDriverGet(pCount: *mut u32, phDrivers: *mut ze_driver_handle_t) -> ze_result_t;
}
impl _ze_api_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_API_VERSION_1_0: _ze_api_version_t = _ze_api_version_t(65536);
}
impl _ze_api_version_t {
    #[doc = "< version 1.1"]
    pub const ZE_API_VERSION_1_1: _ze_api_version_t = _ze_api_version_t(65537);
}
impl _ze_api_version_t {
    #[doc = "< latest known version"]
    pub const ZE_API_VERSION_CURRENT: _ze_api_version_t = _ze_api_version_t(65537);
}
impl _ze_api_version_t {
    pub const ZE_API_VERSION_FORCE_UINT32: _ze_api_version_t = _ze_api_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_api_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
pub use self::_ze_api_version_t as ze_api_version_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns the API version supported by the specified driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == version`"]
    pub fn zeDriverGetApiVersion(
        hDriver: ze_driver_handle_t,
        version: *mut ze_api_version_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Driver universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_driver_uuid_t {
    #[doc = "< [out] opaque data representing a driver UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_driver_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
#[doc = ""]
#[doc = " @brief Driver properties queried using ::zeDriverGetProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_driver_uuid_t,
    #[doc = "< [out] driver version"]
    #[doc = "< The driver version is a non-zero, monotonically increasing value where"]
    #[doc = "< higher values always indicate a more recent version."]
    pub driverVersion: u32,
}
#[test]
fn bindgen_test_layout__ze_driver_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_properties_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).uuid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_properties_t>())).driverVersion as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(driverVersion)
        )
    );
}
impl Default for _ze_driver_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetPlatformInfo**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDriverProperties`"]
    pub fn zeDriverGetProperties(
        hDriver: ze_driver_handle_t,
        pDriverProperties: *mut ze_driver_properties_t,
    ) -> ze_result_t;
}
impl _ze_ipc_property_flags_t {
    #[doc = "< Supports passing memory allocations between processes. See"]
    #[doc = "< ::zeMemGetIpcHandle."]
    pub const ZE_IPC_PROPERTY_FLAG_MEMORY: _ze_ipc_property_flags_t = _ze_ipc_property_flags_t(1);
}
impl _ze_ipc_property_flags_t {
    #[doc = "< Supports passing event pools between processes. See"]
    #[doc = "< ::zeEventPoolGetIpcHandle."]
    pub const ZE_IPC_PROPERTY_FLAG_EVENT_POOL: _ze_ipc_property_flags_t =
        _ze_ipc_property_flags_t(2);
}
impl _ze_ipc_property_flags_t {
    pub const ZE_IPC_PROPERTY_FLAG_FORCE_UINT32: _ze_ipc_property_flags_t =
        _ze_ipc_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_ipc_property_flags_t> for _ze_ipc_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_ipc_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_ipc_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_ipc_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_ipc_property_flags_t> for _ze_ipc_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_ipc_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_ipc_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_ipc_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported IPC property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_ipc_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported IPC property flags"]
pub use self::_ze_ipc_property_flags_t as ze_ipc_property_flags_t;
#[doc = ""]
#[doc = " @brief IPC properties queried using ::zeDriverGetIpcProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_ipc_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_ipc_property_flags_t"]
    pub flags: ze_ipc_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_driver_ipc_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_ipc_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_ipc_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for _ze_driver_ipc_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves IPC attributes of the driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pIpcProperties`"]
    pub fn zeDriverGetIpcProperties(
        hDriver: ze_driver_handle_t,
        pIpcProperties: *mut ze_driver_ipc_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Extension properties queried using ::zeDriverGetExtensionProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_driver_extension_properties_t {
    #[doc = "< [out] extension name"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< [out] extension version using ::ZE_MAKE_VERSION"]
    pub version: u32,
}
#[test]
fn bindgen_test_layout__ze_driver_extension_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_extension_properties_t>(),
        260usize,
        concat!("Size of: ", stringify!(_ze_driver_extension_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_extension_properties_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_extension_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_extension_properties_t>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_extension_properties_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_extension_properties_t>())).version as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_extension_properties_t),
            "::",
            stringify!(version)
        )
    );
}
impl Default for _ze_driver_extension_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves extension properties"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkEnumerateInstanceExtensionProperties**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDriverGetExtensionProperties(
        hDriver: ze_driver_handle_t,
        pCount: *mut u32,
        pExtensionProperties: *mut ze_driver_extension_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves function pointer for vendor-specific or experimental"]
    #[doc = "        extensions"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == name`"]
    #[doc = "         + `nullptr == ppFunctionAddress`"]
    pub fn zeDriverGetExtensionFunctionAddress(
        hDriver: ze_driver_handle_t,
        name: *const ::std::os::raw::c_char,
        ppFunctionAddress: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves devices within a driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function will return identical device handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The number and order of handles returned from this function is"]
    #[doc = "       affected by the ::ZE_AFFINITY_MASK and ::ZE_ENABLE_PCI_ID_DEVICE_ORDER"]
    #[doc = "       environment variables."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGet(
        hDriver: ze_driver_handle_t,
        pCount: *mut u32,
        phDevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves a sub-device from a device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function will return identical device handles,"]
    #[doc = "       in the same order."]
    #[doc = "     - The number of handles returned from this function is affected by the"]
    #[doc = "       ::ZE_AFFINITY_MASK environment variable."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateSubDevices"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetSubDevices(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        phSubdevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
impl _ze_device_type_t {
    #[doc = "< Graphics Processing Unit"]
    pub const ZE_DEVICE_TYPE_GPU: _ze_device_type_t = _ze_device_type_t(1);
}
impl _ze_device_type_t {
    #[doc = "< Central Processing Unit"]
    pub const ZE_DEVICE_TYPE_CPU: _ze_device_type_t = _ze_device_type_t(2);
}
impl _ze_device_type_t {
    #[doc = "< Field Programmable Gate Array"]
    pub const ZE_DEVICE_TYPE_FPGA: _ze_device_type_t = _ze_device_type_t(3);
}
impl _ze_device_type_t {
    #[doc = "< Memory Copy Accelerator"]
    pub const ZE_DEVICE_TYPE_MCA: _ze_device_type_t = _ze_device_type_t(4);
}
impl _ze_device_type_t {
    pub const ZE_DEVICE_TYPE_FORCE_UINT32: _ze_device_type_t = _ze_device_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device types"]
pub use self::_ze_device_type_t as ze_device_type_t;
#[doc = ""]
#[doc = " @brief Device universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_device_uuid_t {
    #[doc = "< [out] opaque data representing a device UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_device_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
impl _ze_device_property_flags_t {
    #[doc = "< Device is integrated with the Host."]
    pub const ZE_DEVICE_PROPERTY_FLAG_INTEGRATED: _ze_device_property_flags_t =
        _ze_device_property_flags_t(1);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device handle used for query represents a sub-device."]
    pub const ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE: _ze_device_property_flags_t =
        _ze_device_property_flags_t(2);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device supports error correction memory access."]
    pub const ZE_DEVICE_PROPERTY_FLAG_ECC: _ze_device_property_flags_t =
        _ze_device_property_flags_t(4);
}
impl _ze_device_property_flags_t {
    #[doc = "< Device supports on-demand page-faulting."]
    pub const ZE_DEVICE_PROPERTY_FLAG_ONDEMANDPAGING: _ze_device_property_flags_t =
        _ze_device_property_flags_t(8);
}
impl _ze_device_property_flags_t {
    pub const ZE_DEVICE_PROPERTY_FLAG_FORCE_UINT32: _ze_device_property_flags_t =
        _ze_device_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_property_flags_t> for _ze_device_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_property_flags_t> for _ze_device_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device property flags"]
pub use self::_ze_device_property_flags_t as ze_device_property_flags_t;
#[doc = ""]
#[doc = " @brief Device properties queried using ::zeDeviceGetProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_device_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] generic device type"]
    pub type_: ze_device_type_t,
    #[doc = "< [out] vendor id from PCI configuration"]
    pub vendorId: u32,
    #[doc = "< [out] device id from PCI configuration"]
    pub deviceId: u32,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_device_property_flags_t"]
    pub flags: ze_device_property_flags_t,
    #[doc = "< [out] sub-device id. Only valid if ::ZE_DEVICE_PROPERTY_FLAG_SUBDEVICE"]
    #[doc = "< is set."]
    pub subdeviceId: u32,
    #[doc = "< [out] Clock rate for device core."]
    pub coreClockRate: u32,
    #[doc = "< [out] Maximum memory allocation size."]
    pub maxMemAllocSize: u64,
    #[doc = "< [out] Maximum number of logical hardware contexts."]
    pub maxHardwareContexts: u32,
    #[doc = "< [out] Maximum priority for command queues. Higher value is higher"]
    #[doc = "< priority."]
    pub maxCommandQueuePriority: u32,
    #[doc = "< [out] Number of threads per EU."]
    pub numThreadsPerEU: u32,
    #[doc = "< [out] The physical EU simd width."]
    pub physicalEUSimdWidth: u32,
    #[doc = "< [out] Number of EUs per sub-slice."]
    pub numEUsPerSubslice: u32,
    #[doc = "< [out] Number of sub-slices per slice."]
    pub numSubslicesPerSlice: u32,
    #[doc = "< [out] Number of slices."]
    pub numSlices: u32,
    #[doc = "< [out] Returns the resolution of device timer in cycles per second used"]
    #[doc = "< for profiling, timestamps, etc."]
    pub timerResolution: u64,
    #[doc = "< [out] Returns the number of valid bits in the timestamp value."]
    pub timestampValidBits: u32,
    #[doc = "< [out] Returns the number of valid bits in the kernel timestamp values"]
    pub kernelTimestampValidBits: u32,
    #[doc = "< [out] universal unique identifier. Note: Subdevices will have their"]
    #[doc = "< own uuid."]
    pub uuid: ze_device_uuid_t,
    #[doc = "< [out] Device name"]
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout__ze_device_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_properties_t>(),
        368usize,
        concat!("Size of: ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).vendorId as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).deviceId as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).subdeviceId as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(subdeviceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).coreClockRate as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(coreClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxMemAllocSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxMemAllocSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxHardwareContexts as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxHardwareContexts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxCommandQueuePriority as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxCommandQueuePriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numThreadsPerEU as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numThreadsPerEU)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).physicalEUSimdWidth as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(physicalEUSimdWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numEUsPerSubslice as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numEUsPerSubslice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSubslicesPerSlice as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSubslicesPerSlice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSlices as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).timerResolution as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(timerResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).timestampValidBits as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(timestampValidBits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).kernelTimestampValidBits as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(kernelTimestampValidBits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).uuid as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).name as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(name)
        )
    );
}
impl Default for _ze_device_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[doc = ""]
#[doc = " @brief Device thread identifier."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_device_thread_t {
    #[doc = "< [in,out] the slice number."]
    #[doc = "< Must be UINT32_MAX (all) or less than ::ze_device_properties_t.numSlices."]
    pub slice: u32,
    #[doc = "< [in,out] the sub-slice number within its slice."]
    #[doc = "< Must be UINT32_MAX (all) or less than ::ze_device_properties_t.numSubslicesPerSlice."]
    pub subslice: u32,
    #[doc = "< [in,out] the EU number within its sub-slice."]
    #[doc = "< Must be UINT32_MAX (all) or less than ::ze_device_properties_t.numEUsPerSubslice."]
    pub eu: u32,
    #[doc = "< [in,out] the thread number within its EU."]
    #[doc = "< Must be UINT32_MAX (all) or less than ::ze_device_properties_t.numThreadsPerEU."]
    pub thread: u32,
}
#[test]
fn bindgen_test_layout__ze_device_thread_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_thread_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_device_thread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_thread_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_device_thread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_thread_t>())).slice as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_thread_t),
            "::",
            stringify!(slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_thread_t>())).subslice as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_thread_t),
            "::",
            stringify!(subslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_thread_t>())).eu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_thread_t),
            "::",
            stringify!(eu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_thread_t>())).thread as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_thread_t),
            "::",
            stringify!(thread)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDeviceProperties`"]
    pub fn zeDeviceGetProperties(
        hDevice: ze_device_handle_t,
        pDeviceProperties: *mut ze_device_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device compute properties queried using ::zeDeviceGetComputeProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_compute_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum items per compute group. (groupSizeX * groupSizeY *"]
    #[doc = "< groupSizeZ) <= maxTotalGroupSize"]
    pub maxTotalGroupSize: u32,
    #[doc = "< [out] Maximum items for X dimension in group"]
    pub maxGroupSizeX: u32,
    #[doc = "< [out] Maximum items for Y dimension in group"]
    pub maxGroupSizeY: u32,
    #[doc = "< [out] Maximum items for Z dimension in group"]
    pub maxGroupSizeZ: u32,
    #[doc = "< [out] Maximum groups that can be launched for x dimension"]
    pub maxGroupCountX: u32,
    #[doc = "< [out] Maximum groups that can be launched for y dimension"]
    pub maxGroupCountY: u32,
    #[doc = "< [out] Maximum groups that can be launched for z dimension"]
    pub maxGroupCountZ: u32,
    #[doc = "< [out] Maximum shared local memory per group."]
    pub maxSharedLocalMemory: u32,
    #[doc = "< [out] Number of subgroup sizes supported. This indicates number of"]
    #[doc = "< entries in subGroupSizes."]
    pub numSubGroupSizes: u32,
    #[doc = "< [out] Size group sizes supported."]
    pub subGroupSizes: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__ze_device_compute_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_compute_properties_t>(),
        88usize,
        concat!("Size of: ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_compute_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxTotalGroupSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxTotalGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeZ as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountX as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountY as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountZ as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxSharedLocalMemory
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxSharedLocalMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).numSubGroupSizes as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(numSubGroupSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).subGroupSizes as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(subGroupSizes)
        )
    );
}
impl Default for _ze_device_compute_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves compute properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pComputeProperties`"]
    pub fn zeDeviceGetComputeProperties(
        hDevice: ze_device_handle_t,
        pComputeProperties: *mut ze_device_compute_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Native kernel universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_native_kernel_uuid_t {
    #[doc = "< [out] opaque data representing a native kernel UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_native_kernel_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_native_kernel_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_native_kernel_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_native_kernel_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_native_kernel_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 16-bit floating-point operations"]
    pub const ZE_DEVICE_MODULE_FLAG_FP16: _ze_device_module_flags_t = _ze_device_module_flags_t(1);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 64-bit floating-point operations"]
    pub const ZE_DEVICE_MODULE_FLAG_FP64: _ze_device_module_flags_t = _ze_device_module_flags_t(2);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports 64-bit atomic operations"]
    pub const ZE_DEVICE_MODULE_FLAG_INT64_ATOMICS: _ze_device_module_flags_t =
        _ze_device_module_flags_t(4);
}
impl _ze_device_module_flags_t {
    #[doc = "< Device supports four component dot product and accumulate operations"]
    pub const ZE_DEVICE_MODULE_FLAG_DP4A: _ze_device_module_flags_t = _ze_device_module_flags_t(8);
}
impl _ze_device_module_flags_t {
    pub const ZE_DEVICE_MODULE_FLAG_FORCE_UINT32: _ze_device_module_flags_t =
        _ze_device_module_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_module_flags_t> for _ze_device_module_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_module_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_module_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_module_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_module_flags_t> for _ze_device_module_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_module_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_module_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_module_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device module flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_module_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device module flags"]
pub use self::_ze_device_module_flags_t as ze_device_module_flags_t;
impl _ze_device_fp_flags_t {
    #[doc = "< Supports denorms"]
    pub const ZE_DEVICE_FP_FLAG_DENORM: _ze_device_fp_flags_t = _ze_device_fp_flags_t(1);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports INF and quiet NaNs"]
    pub const ZE_DEVICE_FP_FLAG_INF_NAN: _ze_device_fp_flags_t = _ze_device_fp_flags_t(2);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to nearest even rounding mode"]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_NEAREST: _ze_device_fp_flags_t = _ze_device_fp_flags_t(4);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to zero."]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_ZERO: _ze_device_fp_flags_t = _ze_device_fp_flags_t(8);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding to both positive and negative INF."]
    pub const ZE_DEVICE_FP_FLAG_ROUND_TO_INF: _ze_device_fp_flags_t = _ze_device_fp_flags_t(16);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports IEEE754-2008 fused multiply-add."]
    pub const ZE_DEVICE_FP_FLAG_FMA: _ze_device_fp_flags_t = _ze_device_fp_flags_t(32);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Supports rounding as defined by IEEE754 for divide and sqrt"]
    #[doc = "< operations."]
    pub const ZE_DEVICE_FP_FLAG_ROUNDED_DIVIDE_SQRT: _ze_device_fp_flags_t =
        _ze_device_fp_flags_t(64);
}
impl _ze_device_fp_flags_t {
    #[doc = "< Uses software implementation for basic floating-point operations."]
    pub const ZE_DEVICE_FP_FLAG_SOFT_FLOAT: _ze_device_fp_flags_t = _ze_device_fp_flags_t(128);
}
impl _ze_device_fp_flags_t {
    pub const ZE_DEVICE_FP_FLAG_FORCE_UINT32: _ze_device_fp_flags_t =
        _ze_device_fp_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_fp_flags_t> for _ze_device_fp_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_fp_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_fp_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_fp_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_fp_flags_t> for _ze_device_fp_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_fp_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_fp_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_fp_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported floating-Point capability flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_fp_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported floating-Point capability flags"]
pub use self::_ze_device_fp_flags_t as ze_device_fp_flags_t;
#[doc = ""]
#[doc = " @brief Device module properties queried using ::zeDeviceGetModuleProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_module_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum supported SPIR-V version."]
    #[doc = "< Returns zero if SPIR-V is not supported."]
    #[doc = "< Contains major and minor attributes, use ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION."]
    pub spirvVersionSupported: u32,
    #[doc = "< [out] 0 or a valid combination of ::ze_device_module_flags_t"]
    pub flags: ze_device_module_flags_t,
    #[doc = "< [out] Capabilities for half-precision floating-point operations."]
    #[doc = "< returns 0 (if ::ZE_DEVICE_MODULE_FLAG_FP16 is not set) or a"]
    #[doc = "< combination of ::ze_device_fp_flags_t."]
    pub fp16flags: ze_device_fp_flags_t,
    #[doc = "< [out] Capabilities for single-precision floating-point operations."]
    #[doc = "< returns a combination of ::ze_device_fp_flags_t."]
    pub fp32flags: ze_device_fp_flags_t,
    #[doc = "< [out] Capabilities for double-precision floating-point operations."]
    #[doc = "< returns 0 (if ::ZE_DEVICE_MODULE_FLAG_FP64 is not set) or a"]
    #[doc = "< combination of ::ze_device_fp_flags_t."]
    pub fp64flags: ze_device_fp_flags_t,
    #[doc = "< [out] Maximum kernel argument size that is supported."]
    pub maxArgumentsSize: u32,
    #[doc = "< [out] Maximum size of internal buffer that holds output of printf"]
    #[doc = "< calls from kernel."]
    pub printfBufferSize: u32,
    #[doc = "< [out] Compatibility UUID of supported native kernel."]
    #[doc = "< UUID may or may not be the same across driver release, devices, or"]
    #[doc = "< operating systems."]
    #[doc = "< Application is responsible for ensuring UUID matches before creating"]
    #[doc = "< module using"]
    #[doc = "< previously created native kernel."]
    pub nativeKernelSupported: ze_native_kernel_uuid_t,
}
#[test]
fn bindgen_test_layout__ze_device_module_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_module_properties_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_device_module_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_module_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_module_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).spirvVersionSupported
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(spirvVersionSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).flags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp16flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp16flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp32flags as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp32flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).fp64flags as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(fp64flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).maxArgumentsSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(maxArgumentsSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).printfBufferSize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(printfBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_module_properties_t>())).nativeKernelSupported
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_module_properties_t),
            "::",
            stringify!(nativeKernelSupported)
        )
    );
}
impl Default for _ze_device_module_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves module properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pModuleProperties`"]
    pub fn zeDeviceGetModuleProperties(
        hDevice: ze_device_handle_t,
        pModuleProperties: *mut ze_device_module_properties_t,
    ) -> ze_result_t;
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports enqueing compute commands."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COMPUTE:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(1);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports enqueing copy commands."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COPY: _ze_command_queue_group_property_flags_t =
        _ze_command_queue_group_property_flags_t(2);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue group supports cooperative kernels."]
    #[doc = "< See ::zeCommandListAppendLaunchCooperativeKernel for more details."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_COOPERATIVE_KERNELS:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(4);
}
impl _ze_command_queue_group_property_flags_t {
    #[doc = "< Command queue groups supports metric queries."]
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_METRICS:
        _ze_command_queue_group_property_flags_t = _ze_command_queue_group_property_flags_t(8);
}
impl _ze_command_queue_group_property_flags_t {
    pub const ZE_COMMAND_QUEUE_GROUP_PROPERTY_FLAG_FORCE_UINT32:
        _ze_command_queue_group_property_flags_t =
        _ze_command_queue_group_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_queue_group_property_flags_t>
    for _ze_command_queue_group_property_flags_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_queue_group_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_queue_group_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_queue_group_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_queue_group_property_flags_t>
    for _ze_command_queue_group_property_flags_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_queue_group_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_queue_group_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_queue_group_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue group property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_group_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue group property flags"]
pub use self::_ze_command_queue_group_property_flags_t as ze_command_queue_group_property_flags_t;
#[doc = ""]
#[doc = " @brief Command queue group properties queried using"]
#[doc = "        ::zeDeviceGetCommandQueueGroupProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_group_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_command_queue_group_property_flags_t"]
    pub flags: ze_command_queue_group_property_flags_t,
    #[doc = "< [out] maximum `pattern_size` supported by command queue group."]
    #[doc = "< See ::zeCommandListAppendMemoryFill for more details."]
    pub maxMemoryFillPatternSize: usize,
    #[doc = "< [out] the number of physical engines within the group."]
    pub numQueues: u32,
}
#[test]
fn bindgen_test_layout__ze_command_queue_group_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_group_properties_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_queue_group_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_group_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_group_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>()))
                .maxMemoryFillPatternSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(maxMemoryFillPatternSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_group_properties_t>())).numQueues as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_group_properties_t),
            "::",
            stringify!(numQueues)
        )
    );
}
impl Default for _ze_command_queue_group_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves command queue group properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Properties are reported for each physical command queue type supported"]
    #[doc = "       by the device."]
    #[doc = "     - Multiple calls to this function will return properties in the same"]
    #[doc = "       order."]
    #[doc = "     - The order in which the properties are returned defines the command"]
    #[doc = "       queue group's ordinal."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkGetPhysicalDeviceQueueFamilyProperties**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetCommandQueueGroupProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pCommandQueueGroupProperties: *mut ze_command_queue_group_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_memory_property_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_DEVICE_MEMORY_PROPERTY_FLAG_TBD: _ze_device_memory_property_flags_t =
        _ze_device_memory_property_flags_t(1);
}
impl _ze_device_memory_property_flags_t {
    pub const ZE_DEVICE_MEMORY_PROPERTY_FLAG_FORCE_UINT32: _ze_device_memory_property_flags_t =
        _ze_device_memory_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_memory_property_flags_t> for _ze_device_memory_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_memory_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_memory_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_memory_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_memory_property_flags_t> for _ze_device_memory_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_memory_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_memory_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_memory_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device memory property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_memory_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device memory property flags"]
pub use self::_ze_device_memory_property_flags_t as ze_device_memory_property_flags_t;
#[doc = ""]
#[doc = " @brief Device local memory properties queried using"]
#[doc = "        ::zeDeviceGetMemoryProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_device_memory_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_memory_property_flags_t"]
    pub flags: ze_device_memory_property_flags_t,
    #[doc = "< [out] Maximum clock rate for device memory."]
    pub maxClockRate: u32,
    #[doc = "< [out] Maximum bus width between device and memory."]
    pub maxBusWidth: u32,
    #[doc = "< [out] Total memory size in bytes that is available to the device."]
    pub totalSize: u64,
    #[doc = "< [out] Memory name"]
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout__ze_device_memory_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_properties_t>(),
        296usize,
        concat!("Size of: ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxClockRate as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxBusWidth as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxBusWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).totalSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(totalSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).name as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(name)
        )
    );
}
impl Default for _ze_device_memory_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves local memory properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Properties are reported for each physical memory type supported by the"]
    #[doc = "       device."]
    #[doc = "     - Multiple calls to this function will return properties in the same"]
    #[doc = "       order."]
    #[doc = "     - The order in which the properties are returned defines the device's"]
    #[doc = "       local memory ordinal."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetMemoryProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pMemProperties: *mut ze_device_memory_properties_t,
    ) -> ze_result_t;
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports load/store access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_RW: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(1);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports atomic access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_ATOMIC: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(2);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports concurrent access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(4);
}
impl _ze_memory_access_cap_flags_t {
    #[doc = "< Supports concurrent atomic access"]
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_CONCURRENT_ATOMIC: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(8);
}
impl _ze_memory_access_cap_flags_t {
    pub const ZE_MEMORY_ACCESS_CAP_FLAG_FORCE_UINT32: _ze_memory_access_cap_flags_t =
        _ze_memory_access_cap_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_memory_access_cap_flags_t> for _ze_memory_access_cap_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_memory_access_cap_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_memory_access_cap_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_memory_access_cap_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_memory_access_cap_flags_t> for _ze_memory_access_cap_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_memory_access_cap_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_memory_access_cap_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_memory_access_cap_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Memory access capability flags"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_access_cap_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Memory access capability flags"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
pub use self::_ze_memory_access_cap_flags_t as ze_memory_access_cap_flags_t;
#[doc = ""]
#[doc = " @brief Device memory access properties queried using"]
#[doc = "        ::zeDeviceGetMemoryAccessProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_memory_access_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] host memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub hostAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub deviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, single-device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedSingleDeviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, cross-device memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedCrossDeviceAllocCapabilities: ze_memory_access_cap_flags_t,
    #[doc = "< [out] shared, system memory capabilities."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_memory_access_cap_flags_t."]
    pub sharedSystemAllocCapabilities: ze_memory_access_cap_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_memory_access_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_access_properties_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_access_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).hostAllocCapabilities
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(hostAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .deviceAllocCapabilities as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(deviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSingleDeviceAllocCapabilities as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSingleDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedCrossDeviceAllocCapabilities as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedCrossDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSystemAllocCapabilities as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSystemAllocCapabilities)
        )
    );
}
impl Default for _ze_device_memory_access_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves memory access properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pMemAccessProperties`"]
    pub fn zeDeviceGetMemoryAccessProperties(
        hDevice: ze_device_handle_t,
        pMemAccessProperties: *mut ze_device_memory_access_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_cache_property_flags_t {
    #[doc = "< Device support User Cache Control (i.e. SLM section vs Generic Cache)"]
    pub const ZE_DEVICE_CACHE_PROPERTY_FLAG_USER_CONTROL: _ze_device_cache_property_flags_t =
        _ze_device_cache_property_flags_t(1);
}
impl _ze_device_cache_property_flags_t {
    pub const ZE_DEVICE_CACHE_PROPERTY_FLAG_FORCE_UINT32: _ze_device_cache_property_flags_t =
        _ze_device_cache_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_cache_property_flags_t> for _ze_device_cache_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_cache_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_cache_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_cache_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_cache_property_flags_t> for _ze_device_cache_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_cache_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_cache_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_cache_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported cache control property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_cache_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported cache control property flags"]
pub use self::_ze_device_cache_property_flags_t as ze_device_cache_property_flags_t;
#[doc = ""]
#[doc = " @brief Device cache properties queried using ::zeDeviceGetCacheProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_cache_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_cache_property_flags_t"]
    pub flags: ze_device_cache_property_flags_t,
    #[doc = "< [out] Per-cache size, in bytes"]
    pub cacheSize: usize,
}
#[test]
fn bindgen_test_layout__ze_device_cache_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_cache_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_cache_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).cacheSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(cacheSize)
        )
    );
}
impl Default for _ze_device_cache_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves cache properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetCacheProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pCacheProperties: *mut ze_device_cache_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device image properties queried using ::zeDeviceGetImageProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_image_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Maximum image dimensions for 1D resources. if 0, then 1D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims1D: u32,
    #[doc = "< [out] Maximum image dimensions for 2D resources. if 0, then 2D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims2D: u32,
    #[doc = "< [out] Maximum image dimensions for 3D resources. if 0, then 3D images"]
    #[doc = "< are unsupported."]
    pub maxImageDims3D: u32,
    #[doc = "< [out] Maximum image buffer size in bytes. if 0, then buffer images are"]
    #[doc = "< unsupported."]
    pub maxImageBufferSize: u64,
    #[doc = "< [out] Maximum image array slices. if 0, then image arrays are"]
    #[doc = "< unsupported."]
    pub maxImageArraySlices: u32,
    #[doc = "< [out] Max samplers that can be used in kernel. if 0, then sampling is"]
    #[doc = "< unsupported."]
    pub maxSamplers: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be read from by a kernel. if 0, then reading images is"]
    #[doc = "< unsupported."]
    pub maxReadImageArgs: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be written to by a kernel. if 0, then writing images is"]
    #[doc = "< unsupported."]
    pub maxWriteImageArgs: u32,
}
#[test]
fn bindgen_test_layout__ze_device_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_image_properties_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_image_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims1D as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims2D as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims3D as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageBufferSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageArraySlices
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageArraySlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxSamplers as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxReadImageArgs as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxReadImageArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxWriteImageArgs as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxWriteImageArgs)
        )
    );
}
impl Default for _ze_device_image_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves image properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - See ::zeImageGetProperties for format-specific capabilities."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pImageProperties`"]
    pub fn zeDeviceGetImageProperties(
        hDevice: ze_device_handle_t,
        pImageProperties: *mut ze_device_image_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Device external memory import and export properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_external_memory_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Supported external memory import types for memory allocations."]
    pub memoryAllocationImportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory export types for memory allocations."]
    pub memoryAllocationExportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory import types for images."]
    pub imageImportTypes: ze_external_memory_type_flags_t,
    #[doc = "< [out] Supported external memory export types for images."]
    pub imageExportTypes: ze_external_memory_type_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_external_memory_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_external_memory_properties_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_external_memory_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_external_memory_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_external_memory_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>()))
                .memoryAllocationImportTypes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(memoryAllocationImportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>()))
                .memoryAllocationExportTypes as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(memoryAllocationExportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).imageImportTypes
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(imageImportTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_external_memory_properties_t>())).imageExportTypes
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_external_memory_properties_t),
            "::",
            stringify!(imageExportTypes)
        )
    );
}
impl Default for _ze_device_external_memory_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves external memory import and export of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pExternalMemoryProperties`"]
    pub fn zeDeviceGetExternalMemoryProperties(
        hDevice: ze_device_handle_t,
        pExternalMemoryProperties: *mut ze_device_external_memory_properties_t,
    ) -> ze_result_t;
}
impl _ze_device_p2p_property_flags_t {
    #[doc = "< Device supports access between peer devices."]
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_ACCESS: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(1);
}
impl _ze_device_p2p_property_flags_t {
    #[doc = "< Device supports atomics between peer devices."]
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_ATOMICS: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(2);
}
impl _ze_device_p2p_property_flags_t {
    pub const ZE_DEVICE_P2P_PROPERTY_FLAG_FORCE_UINT32: _ze_device_p2p_property_flags_t =
        _ze_device_p2p_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_p2p_property_flags_t> for _ze_device_p2p_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_p2p_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_p2p_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_p2p_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_p2p_property_flags_t> for _ze_device_p2p_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_p2p_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_p2p_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_p2p_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported device peer-to-peer property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_p2p_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported device peer-to-peer property flags"]
pub use self::_ze_device_p2p_property_flags_t as ze_device_p2p_property_flags_t;
#[doc = ""]
#[doc = " @brief Device peer-to-peer properties queried using"]
#[doc = "        ::zeDeviceGetP2PProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_p2p_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of"]
    #[doc = "< ::ze_device_p2p_property_flags_t"]
    pub flags: ze_device_p2p_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_device_p2p_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_p2p_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_p2p_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for _ze_device_p2p_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves peer-to-peer properties between one device and a peer"]
    #[doc = "        devices"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pP2PProperties`"]
    pub fn zeDeviceGetP2PProperties(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        pP2PProperties: *mut ze_device_p2p_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries if one device can directly access peer device allocations"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Any device can access any other device within a node through a"]
    #[doc = "       scale-up fabric."]
    #[doc = "     - The following are conditions for CanAccessPeer query."]
    #[doc = "         + If both device and peer device are the same then return true."]
    #[doc = "         + If both sub-device and peer sub-device are the same then return"]
    #[doc = "           true."]
    #[doc = "         + If both are sub-devices and share the same parent device then"]
    #[doc = "           return true."]
    #[doc = "         + If both device and remote device are connected by a direct or"]
    #[doc = "           indirect scale-up fabric or over PCIe (same root complex or shared"]
    #[doc = "           PCIe switch) then true."]
    #[doc = "         + If both sub-device and remote parent device (and vice-versa) are"]
    #[doc = "           connected by a direct or indirect scale-up fabric or over PCIe"]
    #[doc = "           (same root complex or shared PCIe switch) then true."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == value`"]
    pub fn zeDeviceCanAccessPeer(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        value: *mut ze_bool_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns current status of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Once a device is reset, this call will update the OS handle attached"]
    #[doc = "       to the device handle."]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same device handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "         + Device is available for use."]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "         + Device is lost; must be reset for use."]
    pub fn zeDeviceGetStatus(hDevice: ze_device_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns synchronized Host and device global timestamps."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same device handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == hostTimestamp`"]
    #[doc = "         + `nullptr == deviceTimestamp`"]
    pub fn zeDeviceGetGlobalTimestamps(
        hDevice: ze_device_handle_t,
        hostTimestamp: *mut u64,
        deviceTimestamp: *mut u64,
    ) -> ze_result_t;
}
impl _ze_context_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_CONTEXT_FLAG_TBD: _ze_context_flags_t = _ze_context_flags_t(1);
}
impl _ze_context_flags_t {
    pub const ZE_CONTEXT_FLAG_FORCE_UINT32: _ze_context_flags_t = _ze_context_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_context_flags_t> for _ze_context_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_context_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_context_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_context_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_context_flags_t> for _ze_context_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_context_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_context_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_context_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported context creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_context_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported context creation flags"]
pub use self::_ze_context_flags_t as ze_context_flags_t;
#[doc = ""]
#[doc = " @brief Context descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_context_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_context_flags_t,
}
#[test]
fn bindgen_test_layout__ze_context_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_context_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_context_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a context for the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the context for the driver which was"]
    #[doc = "       provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextCreate(
        hDriver: ze_driver_handle_t,
        desc: *const ze_context_desc_t,
        phContext: *mut ze_context_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a context for the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the context for the driver which was"]
    #[doc = "       provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phDevices) && (0 < numDevices)`"]
    pub fn zeContextCreateEx(
        hDriver: ze_driver_handle_t,
        desc: *const ze_context_desc_t,
        numDevices: u32,
        phDevices: *mut ze_device_handle_t,
        phContext: *mut ze_context_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the context before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same context handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeContextDestroy(hContext: ze_context_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns current status of the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads with"]
    #[doc = "       the same context handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "         + Context is available for use."]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "         + Context is invalid; due to device lost or reset."]
    pub fn zeContextGetStatus(hContext: ze_context_handle_t) -> ze_result_t;
}
impl _ze_command_queue_flags_t {
    #[doc = "< command queue should be optimized for submission to a single device engine."]
    #[doc = "< driver **must** disable any implicit optimizations for distributing"]
    #[doc = "< work across multiple engines."]
    #[doc = "< this flag should be used when applications want full control over"]
    #[doc = "< multi-engine submission and scheduling."]
    pub const ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY: _ze_command_queue_flags_t =
        _ze_command_queue_flags_t(1);
}
impl _ze_command_queue_flags_t {
    pub const ZE_COMMAND_QUEUE_FLAG_FORCE_UINT32: _ze_command_queue_flags_t =
        _ze_command_queue_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_queue_flags_t> for _ze_command_queue_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_queue_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_queue_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_queue_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_queue_flags_t> for _ze_command_queue_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_queue_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_queue_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_queue_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
pub use self::_ze_command_queue_flags_t as ze_command_queue_flags_t;
impl _ze_command_queue_mode_t {
    #[doc = "< implicit default behavior; uses driver-based heuristics"]
    pub const ZE_COMMAND_QUEUE_MODE_DEFAULT: _ze_command_queue_mode_t = _ze_command_queue_mode_t(0);
}
impl _ze_command_queue_mode_t {
    #[doc = "< Device execution always completes immediately on execute;"]
    #[doc = "< Host thread is blocked using wait on implicit synchronization object"]
    pub const ZE_COMMAND_QUEUE_MODE_SYNCHRONOUS: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(1);
}
impl _ze_command_queue_mode_t {
    #[doc = "< Device execution is scheduled and will complete in future;"]
    #[doc = "< explicit synchronization object must be used to determine completeness"]
    pub const ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(2);
}
impl _ze_command_queue_mode_t {
    pub const ZE_COMMAND_QUEUE_MODE_FORCE_UINT32: _ze_command_queue_mode_t =
        _ze_command_queue_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
pub use self::_ze_command_queue_mode_t as ze_command_queue_mode_t;
impl _ze_command_queue_priority_t {
    #[doc = "< [default] normal priority"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_NORMAL: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(0);
}
impl _ze_command_queue_priority_t {
    #[doc = "< lower priority than normal"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_LOW: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(1);
}
impl _ze_command_queue_priority_t {
    #[doc = "< higher priority than normal"]
    pub const ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(2);
}
impl _ze_command_queue_priority_t {
    pub const ZE_COMMAND_QUEUE_PRIORITY_FORCE_UINT32: _ze_command_queue_priority_t =
        _ze_command_queue_priority_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_queue_priority_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
pub use self::_ze_command_queue_priority_t as ze_command_queue_priority_t;
#[doc = ""]
#[doc = " @brief Command Queue descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] command queue group ordinal"]
    pub ordinal: u32,
    #[doc = "< [in] command queue index within the group;"]
    #[doc = "< must be zero if ::ZE_COMMAND_QUEUE_FLAG_EXPLICIT_ONLY is not set"]
    pub index: u32,
    #[doc = "< [in] usage flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_command_queue_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics to balance"]
    #[doc = "< latency and throughput."]
    pub flags: ze_command_queue_flags_t,
    #[doc = "< [in] operation mode"]
    pub mode: ze_command_queue_mode_t,
    #[doc = "< [in] priority"]
    pub priority: ze_command_queue_priority_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_desc_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).ordinal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).index as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).priority as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(priority)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command queue on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A command queue represents a logical input stream to the device, tied"]
    #[doc = "       to a physical input stream."]
    #[doc = "     - The application must only use the command queue for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS < desc->mode`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < desc->priority`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandQueueCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_command_queue_desc_t,
        phCommandQueue: *mut ze_command_queue_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all fence handles created from the"]
    #[doc = "       command queue before destroying the command queue itself"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command queue before it is deleted"]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this command queue"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command queue handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandQueueDestroy(hCommandQueue: ze_command_queue_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Executes a command list in a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The command lists are submitted to the device in the order they are"]
    #[doc = "       received, whether from multiple calls (on the same or different"]
    #[doc = "       threads) or a single call with multiple command lists."]
    #[doc = "     - The application must ensure the command lists are accessible by the"]
    #[doc = "       device on which the command queue was created."]
    #[doc = "     - The application must ensure the command lists are not currently"]
    #[doc = "       referencing the command list since the implementation is allowed to"]
    #[doc = "       modify the contents of the command list for submission."]
    #[doc = "     - The application must only execute command lists created with an"]
    #[doc = "       identical command queue group ordinal to the command queue."]
    #[doc = "     - The application must use a fence created using the same command queue."]
    #[doc = "     - The application must ensure the command queue, command list and fence"]
    #[doc = "       were created on the same context."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkQueueSubmit"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == numCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandQueueExecuteCommandLists(
        hCommandQueue: ze_command_queue_handle_t,
        numCommandLists: u32,
        phCommandLists: *mut ze_command_list_handle_t,
        hFence: ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Synchronizes a command queue by waiting on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeCommandQueueSynchronize(
        hCommandQueue: ze_command_queue_handle_t,
        timeout: u64,
    ) -> ze_result_t;
}
impl _ze_command_list_flags_t {
    #[doc = "< driver may reorder commands (e.g., kernels, copies) between barriers"]
    #[doc = "< and synchronization primitives."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    pub const ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING: _ze_command_list_flags_t =
        _ze_command_list_flags_t(1);
}
impl _ze_command_list_flags_t {
    #[doc = "< driver may perform additional optimizations that increase execution"]
    #[doc = "< throughput."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose and ::zeCommandQueueExecuteCommandLists."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    pub const ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT: _ze_command_list_flags_t =
        _ze_command_list_flags_t(2);
}
impl _ze_command_list_flags_t {
    #[doc = "< command list should be optimized for submission to a single command"]
    #[doc = "< queue and device engine."]
    #[doc = "< driver **must** disable any implicit optimizations for distributing"]
    #[doc = "< work across multiple engines."]
    #[doc = "< this flag should be used when applications want full control over"]
    #[doc = "< multi-engine submission and scheduling."]
    pub const ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY: _ze_command_list_flags_t =
        _ze_command_list_flags_t(4);
}
impl _ze_command_list_flags_t {
    pub const ZE_COMMAND_LIST_FLAG_FORCE_UINT32: _ze_command_list_flags_t =
        _ze_command_list_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_command_list_flags_t> for _ze_command_list_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_command_list_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_command_list_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_command_list_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_command_list_flags_t> for _ze_command_list_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_command_list_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_command_list_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_command_list_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_command_list_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
pub use self::_ze_command_list_flags_t as ze_command_list_flags_t;
#[doc = ""]
#[doc = " @brief Command List descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] command queue group ordinal to which this command list will be"]
    #[doc = "< submitted"]
    pub commandQueueGroupOrdinal: u32,
    #[doc = "< [in] usage flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_command_list_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics to balance"]
    #[doc = "< latency and throughput."]
    pub flags: ze_command_list_flags_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_desc_t>())).commandQueueGroupOrdinal as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(commandQueueGroupOrdinal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command list on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A command list represents a sequence of commands for execution on a"]
    #[doc = "       command queue."]
    #[doc = "     - The command list is created in the 'open' state."]
    #[doc = "     - The application must only use the command list for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_command_list_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an immediate command list on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - An immediate command list is used for low-latency submission of"]
    #[doc = "       commands."]
    #[doc = "     - An immediate command list creates an implicit command queue."]
    #[doc = "     - The command list is created in the 'open' state and never needs to be"]
    #[doc = "       closed."]
    #[doc = "     - The application must only use the command list for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == altdesc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < altdesc->flags`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS < altdesc->mode`"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_PRIORITY_PRIORITY_HIGH < altdesc->priority`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreateImmediate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        altdesc: *const ze_command_queue_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command list before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this command list."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandListDestroy(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes a command list; ready to be executed by a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListClose(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a command list to initial (empty) state; ready for appending"]
    #[doc = "        commands."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the command list before it is reset"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListReset(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a memory write of the device's global timestamp value into a"]
    #[doc = "        command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The timestamp frequency can be queried from"]
    #[doc = "       ::ze_device_properties_t.timerResolution."]
    #[doc = "     - The number of valid bits in the timestamp value can be queried from"]
    #[doc = "       ::ze_device_properties_t.timestampValidBits."]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendWriteGlobalTimestamp(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut u64,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends an execution and global memory barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCmdPipelineBarrier**"]
    #[doc = "     - clEnqueueBarrierWithWaitList"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendBarrier(
        hCommandList: ze_command_list_handle_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a global memory ranges barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pRangeSizes`"]
    #[doc = "         + `nullptr == pRanges`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryRangesBarrier(
        hCommandList: ze_command_list_handle_t,
        numRanges: u32,
        pRangeSizes: *const usize,
        pRanges: *mut *const ::std::os::raw::c_void,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Ensures in-bound writes to the device are globally observable."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a special-case system level barrier that can be used to ensure"]
    #[doc = "       global observability of writes;"]
    #[doc = "       typically needed after a producer (e.g., NIC) performs direct writes"]
    #[doc = "       to the device's memory (e.g., Direct RDMA writes)."]
    #[doc = "       This is typically required when the memory corresponding to the writes"]
    #[doc = "       is subsequently accessed from a remote device."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    pub fn zeContextSystemBarrier(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyBuffer**"]
    #[doc = "     - **clEnqueueReadBuffer**"]
    #[doc = "     - **clEnqueueWriteBuffer**"]
    #[doc = "     - **clEnqueueSVMMemcpy**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopy(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        srcptr: *const ::std::os::raw::c_void,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initializes host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The value to initialize memory to is described by the pattern and the"]
    #[doc = "       pattern size."]
    #[doc = "     - The pattern size must be a power-of-two and less than"]
    #[doc = "       ::ze_command_queue_group_properties_t.maxMemoryFillPatternSize."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must enusre the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueFillBuffer**"]
    #[doc = "     - **clEnqueueSVMMemFill**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pattern`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryFill(
        hCommandList: ze_command_list_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_void,
        pattern_size: usize,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Copy region descriptor"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_copy_region_t {
    #[doc = "< [in] The origin x offset for region in bytes"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in rows"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in slices"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in bytes"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in rows"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin in slices. Set this to 0 for"]
    #[doc = "< 2D copy."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_copy_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_copy_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_copy_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region from a 2D or 3D array of host, device, or shared"]
    #[doc = "        memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The region width, height, and depth for both src and dst must be same."]
    #[doc = "       The origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == dstRegion`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "         + `nullptr == srcRegion`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopyRegion(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        dstRegion: *const ze_copy_region_t,
        dstPitch: u32,
        dstSlicePitch: u32,
        srcptr: *const ::std::os::raw::c_void,
        srcRegion: *const ze_copy_region_t,
        srcPitch: u32,
        srcSlicePitch: u32,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies host, device, or shared memory from another context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The current active and source context must be from the same driver."]
    #[doc = "     - The application must ensure the memory pointed to by dstptr and srcptr"]
    #[doc = "       is accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr and"]
    #[doc = "       srcptr as they are free to be modified by either the Host or device up"]
    #[doc = "       until execution."]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hContextSrc`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendMemoryCopyFromContext(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        hContextSrc: ze_context_handle_t,
        srcptr: *const ::std::os::raw::c_void,
        size: usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies an image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptors for both"]
    #[doc = "       source and destination images are the same."]
    #[doc = "     - The application must ensure the command list, images and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyImage**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopy(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Region descriptor"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_image_region_t {
    #[doc = "< [in] The origin x offset for region in pixels"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in pixels"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in pixels"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in pixels"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in pixels"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin. For 1D or 2D images, set"]
    #[doc = "< this to 1."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_image_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region of an image to another image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The region width and height for both src and dst must be same. The"]
    #[doc = "       origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application must ensure the image format descriptors for both"]
    #[doc = "       source and destination images are the same."]
    #[doc = "     - The application must ensure the command list, images and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyRegion(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        pDstRegion: *const ze_image_region_t,
        pSrcRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies from an image to device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by dstptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by dstptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptor for the source"]
    #[doc = "       image is not a media format."]
    #[doc = "     - The application must ensure the command list, image and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueReadImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyToMemory(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        hSrcImage: ze_image_handle_t,
        pSrcRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies to an image from device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory pointed to by srcptr is"]
    #[doc = "       accessible by the device on which the command list was created."]
    #[doc = "     - The implementation must not access the memory pointed to by srcptr as"]
    #[doc = "       it is free to be modified by either the Host or device up until"]
    #[doc = "       execution."]
    #[doc = "     - The application must ensure the image and events are accessible by the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The application must ensure the image format descriptor for the"]
    #[doc = "       destination image is not a media format."]
    #[doc = "     - The application must ensure the command list, image and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueWriteImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendImageCopyFromMemory(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        srcptr: *const ::std::os::raw::c_void,
        pDstRegion: *const ze_image_region_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Asynchronously prefetches shared memory to the device associated with"]
    #[doc = "        the specified command list"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a hint to improve performance only and is not required for"]
    #[doc = "       correctness."]
    #[doc = "     - Only prefetching to the device associated with the specified command"]
    #[doc = "       list is supported."]
    #[doc = "       Prefetching to the host or to a peer device is not supported."]
    #[doc = "     - Prefetching may not be supported for all allocation types for all devices."]
    #[doc = "       If memory prefetching is not supported for the specified memory range"]
    #[doc = "       the prefetch hint may be ignored."]
    #[doc = "     - Prefetching may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application must ensure the memory pointed to by ptr is accessible"]
    #[doc = "       by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list was created, and the"]
    #[doc = "       memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueSVMMigrateMem"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeCommandListAppendMemoryPrefetch(
        hCommandList: ze_command_list_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
impl _ze_memory_advice_t {
    #[doc = "< hint that memory will be read from frequently and written to rarely"]
    pub const ZE_MEMORY_ADVICE_SET_READ_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(0);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_READ_MOSTLY"]
    pub const ZE_MEMORY_ADVICE_CLEAR_READ_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(1);
}
impl _ze_memory_advice_t {
    #[doc = "< hint that the preferred memory location is the specified device"]
    pub const ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION: _ze_memory_advice_t = _ze_memory_advice_t(2);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION"]
    pub const ZE_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION: _ze_memory_advice_t =
        _ze_memory_advice_t(3);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory will mostly be accessed non-atomically"]
    pub const ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY: _ze_memory_advice_t = _ze_memory_advice_t(4);
}
impl _ze_memory_advice_t {
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY"]
    pub const ZE_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY: _ze_memory_advice_t =
        _ze_memory_advice_t(5);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory should be cached"]
    pub const ZE_MEMORY_ADVICE_BIAS_CACHED: _ze_memory_advice_t = _ze_memory_advice_t(6);
}
impl _ze_memory_advice_t {
    #[doc = "< hints that memory should be not be cached"]
    pub const ZE_MEMORY_ADVICE_BIAS_UNCACHED: _ze_memory_advice_t = _ze_memory_advice_t(7);
}
impl _ze_memory_advice_t {
    pub const ZE_MEMORY_ADVICE_FORCE_UINT32: _ze_memory_advice_t = _ze_memory_advice_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_advice_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
pub use self::_ze_memory_advice_t as ze_memory_advice_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Provides advice about the use of a shared memory range"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Memory advice is a performance hint only and is not required for"]
    #[doc = "       functional correctness."]
    #[doc = "     - Memory advice can be used to override driver heuristics to explicitly"]
    #[doc = "       control shared memory behavior."]
    #[doc = "     - Not all memory advice hints may be supported for all allocation types"]
    #[doc = "       for all devices."]
    #[doc = "       If a memory advice hint is not supported by the device it will be ignored."]
    #[doc = "     - Memory advice may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application must ensure the memory pointed to by ptr is accessible"]
    #[doc = "       by the device on which the command list was created."]
    #[doc = "     - The application must ensure the command list was created, and memory"]
    #[doc = "       was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle, and the memory was"]
    #[doc = "       allocated."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ADVICE_BIAS_UNCACHED < advice`"]
    pub fn zeCommandListAppendMemAdvise(
        hCommandList: ze_command_list_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        advice: ze_memory_advice_t,
    ) -> ze_result_t;
}
impl _ze_event_pool_flags_t {
    #[doc = "< signals and waits are also visible to host"]
    pub const ZE_EVENT_POOL_FLAG_HOST_VISIBLE: _ze_event_pool_flags_t = _ze_event_pool_flags_t(1);
}
impl _ze_event_pool_flags_t {
    #[doc = "< signals and waits may be shared across processes"]
    pub const ZE_EVENT_POOL_FLAG_IPC: _ze_event_pool_flags_t = _ze_event_pool_flags_t(2);
}
impl _ze_event_pool_flags_t {
    #[doc = "< Indicates all events in pool will contain kernel timestamps; cannot be"]
    #[doc = "< combined with ::ZE_EVENT_POOL_FLAG_IPC"]
    pub const ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP: _ze_event_pool_flags_t =
        _ze_event_pool_flags_t(4);
}
impl _ze_event_pool_flags_t {
    pub const ZE_EVENT_POOL_FLAG_FORCE_UINT32: _ze_event_pool_flags_t =
        _ze_event_pool_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_event_pool_flags_t> for _ze_event_pool_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_event_pool_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_event_pool_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_event_pool_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_event_pool_flags_t> for _ze_event_pool_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_event_pool_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_event_pool_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_event_pool_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_event_pool_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
pub use self::_ze_event_pool_flags_t as ze_event_pool_flags_t;
#[doc = ""]
#[doc = " @brief Event pool descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_pool_flags_t;"]
    #[doc = "< default behavior is signals and waits are visible to the entire device"]
    #[doc = "< and peer devices."]
    pub flags: ze_event_pool_flags_t,
    #[doc = "< [in] number of events within the pool; must be greater than 0"]
    pub count: u32,
}
#[test]
fn bindgen_test_layout__ze_event_pool_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).count as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a pool of events on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use events within the pool for the"]
    #[doc = "       device(s), or their sub-devices, which were provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == desc->count`"]
    #[doc = "         + `(nullptr == phDevices) && (0 < numDevices)`"]
    pub fn zeEventPoolCreate(
        hContext: ze_context_handle_t,
        desc: *const ze_event_pool_desc_t,
        numDevices: u32,
        phDevices: *mut ze_device_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event pool object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all event handles created from the pool"]
    #[doc = "       before destroying the pool itself."]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the any event within the pool before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this event pool."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventPoolDestroy(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for local"]
    #[doc = "< sub-device access"]
    pub const ZE_EVENT_SCOPE_FLAG_SUBDEVICE: _ze_event_scope_flags_t = _ze_event_scope_flags_t(1);
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for global"]
    #[doc = "< device access and peer device access"]
    pub const ZE_EVENT_SCOPE_FLAG_DEVICE: _ze_event_scope_flags_t = _ze_event_scope_flags_t(2);
}
impl _ze_event_scope_flags_t {
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for device and"]
    #[doc = "< host access"]
    pub const ZE_EVENT_SCOPE_FLAG_HOST: _ze_event_scope_flags_t = _ze_event_scope_flags_t(4);
}
impl _ze_event_scope_flags_t {
    pub const ZE_EVENT_SCOPE_FLAG_FORCE_UINT32: _ze_event_scope_flags_t =
        _ze_event_scope_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_event_scope_flags_t> for _ze_event_scope_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_event_scope_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_event_scope_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_event_scope_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_event_scope_flags_t> for _ze_event_scope_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_event_scope_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_event_scope_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_event_scope_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_event_scope_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
pub use self::_ze_event_scope_flags_t as ze_event_scope_flags_t;
#[doc = ""]
#[doc = " @brief Event descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] index of the event within the pool; must be less-than the count"]
    #[doc = "< specified during pool creation"]
    pub index: u32,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to flush on a"]
    #[doc = "< signal action before the event is triggered."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_scope_flags_t;"]
    #[doc = "< default behavior is synchronization within the command list only, no"]
    #[doc = "< additional cache hierarchies are flushed."]
    pub signal: ze_event_scope_flags_t,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to invalidate on"]
    #[doc = "< a wait action after the event is complete."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_event_scope_flags_t;"]
    #[doc = "< default behavior is synchronization within the command list only, no"]
    #[doc = "< additional cache hierarchies are invalidated."]
    pub wait: ze_event_scope_flags_t,
}
#[test]
fn bindgen_test_layout__ze_event_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).signal as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).wait as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an event from the pool."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - An event is used to communicate fine-grain host-to-device,"]
    #[doc = "       device-to-host or device-to-device dependencies have completed."]
    #[doc = "     - The application must ensure the location in the pool is not being used"]
    #[doc = "       by another event."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateUserEvent**"]
    #[doc = "     - vkCreateEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < desc->signal`"]
    #[doc = "         + `0x7 < desc->wait`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeEventCreate(
        hEventPool: ze_event_pool_handle_t,
        desc: *const ze_event_desc_t,
        phEvent: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the event before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this event."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseEvent**"]
    #[doc = "     - vkDestroyEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventDestroy(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Gets an IPC event pool handle for the specified event handle that can"]
    #[doc = "        be shared with another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Event pool must have been created with ::ZE_EVENT_POOL_FLAG_IPC."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phIpc`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventPoolGetIpcHandle(
        hEventPool: ze_event_pool_handle_t,
        phIpc: *mut ze_ipc_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC event pool handle to retrieve an event pool handle from"]
    #[doc = "        another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple calls to this function with the same IPC handle will return"]
    #[doc = "       unique event pool handles."]
    #[doc = "     - The event handle in this process should not be freed with"]
    #[doc = "       ::zeEventPoolDestroy, but rather with ::zeEventPoolCloseIpcHandle."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEventPool`"]
    pub fn zeEventPoolOpenIpcHandle(
        hContext: ze_context_handle_t,
        hIpc: ze_ipc_event_pool_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC event handle in the current process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC event handle by destroying events that were opened in"]
    #[doc = "       this process using ::zeEventPoolOpenIpcHandle."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    pub fn zeEventPoolCloseIpcHandle(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a signal of the event from the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The duration of an event created from an event pool that was created"]
    #[doc = "       using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined."]
    #[doc = "       However, for consistency and orthogonality the event will report"]
    #[doc = "       correctly as signaled when used by other event API functionality."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clSetUserEventStatus**"]
    #[doc = "     - vkCmdSetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendSignalEvent(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends wait on event(s) on the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEvents`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendWaitOnEvents(
        hCommandList: ze_command_list_handle_t,
        numEvents: u32,
        phEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Signals a event from host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The duration of an event created from an event pool that was created"]
    #[doc = "       using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag is undefined."]
    #[doc = "       However, for consistency and orthogonality the event will report"]
    #[doc = "       correctly as signaled when used by other event API functionality."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clSetUserEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostSignal(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on an event to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clWaitForEvents"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeEventHostSynchronize(hEvent: ze_event_handle_t, timeout: u64) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries an event object's status on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetEventInfo**"]
    #[doc = "     - vkGetEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeEventQueryStatus(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a reset of an event back to not signaled state into a command"]
    #[doc = "        list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the command list and events were created"]
    #[doc = "       on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendEventReset(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread resets an event back to not signaled state."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostReset(hEvent: ze_event_handle_t) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel timestamp clock data"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - The timestamp frequency can be queried from"]
#[doc = "       ::ze_device_properties_t.timerResolution."]
#[doc = "     - The number of valid bits in the timestamp value can be queried from"]
#[doc = "       ::ze_device_properties_t.kernelTimestampValidBits."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_kernel_timestamp_data_t {
    #[doc = "< [out] device clock at start of kernel execution"]
    pub kernelStart: u64,
    #[doc = "< [out] device clock at end of kernel execution"]
    pub kernelEnd: u64,
}
#[test]
fn bindgen_test_layout__ze_kernel_timestamp_data_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_timestamp_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_kernel_timestamp_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_timestamp_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_timestamp_data_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_data_t>())).kernelStart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_data_t),
            "::",
            stringify!(kernelStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_data_t>())).kernelEnd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_data_t),
            "::",
            stringify!(kernelEnd)
        )
    );
}
#[doc = ""]
#[doc = " @brief Kernel timestamp result"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_kernel_timestamp_result_t {
    #[doc = "< [out] wall-clock data"]
    pub global: ze_kernel_timestamp_data_t,
    #[doc = "< [out] context-active data; only includes clocks while device context"]
    #[doc = "< was actively executing."]
    pub context: ze_kernel_timestamp_data_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_timestamp_result_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_timestamp_result_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_timestamp_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_timestamp_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_timestamp_result_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_result_t>())).global as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_result_t),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_timestamp_result_t>())).context as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_timestamp_result_t),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries an event's timestamp value on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the event was created from an event pool"]
    #[doc = "       that was created using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag."]
    #[doc = "     - The destination memory will be unmodified if the event has not been"]
    #[doc = "       signaled."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeEventQueryKernelTimestamp(
        hEvent: ze_event_handle_t,
        dstptr: *mut ze_kernel_timestamp_result_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a query of an events' timestamp value(s) into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the events are accessible by the device on"]
    #[doc = "       which the command list was created."]
    #[doc = "     - The application must ensure the events were created from an event pool"]
    #[doc = "       that was created using ::ZE_EVENT_POOL_FLAG_KERNEL_TIMESTAMP flag."]
    #[doc = "     - The application must ensure the memory pointed to by both dstptr and"]
    #[doc = "       pOffsets is accessible by the device on which the command list was"]
    #[doc = "       created."]
    #[doc = "     - The value(s) written to the destination buffer are undefined if any"]
    #[doc = "       timestamp event has not been signaled."]
    #[doc = "     - If pOffsets is nullptr, then multiple results will be appended"]
    #[doc = "       sequentially into memory in the same order as phEvents."]
    #[doc = "     - The application must ensure the command list and events were created,"]
    #[doc = "       and the memory was allocated, on the same context."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEvents`"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendQueryKernelTimestamps(
        hCommandList: ze_command_list_handle_t,
        numEvents: u32,
        phEvents: *mut ze_event_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        pOffsets: *const usize,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
impl _ze_fence_flags_t {
    #[doc = "< fence is created in the signaled state, otherwise not signaled."]
    pub const ZE_FENCE_FLAG_SIGNALED: _ze_fence_flags_t = _ze_fence_flags_t(1);
}
impl _ze_fence_flags_t {
    pub const ZE_FENCE_FLAG_FORCE_UINT32: _ze_fence_flags_t = _ze_fence_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_fence_flags_t> for _ze_fence_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_fence_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_fence_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_fence_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_fence_flags_t> for _ze_fence_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_fence_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_fence_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_fence_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_fence_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
pub use self::_ze_fence_flags_t as ze_fence_flags_t;
#[doc = ""]
#[doc = " @brief Fence descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_fence_flags_t."]
    pub flags: ze_fence_flags_t,
}
#[test]
fn bindgen_test_layout__ze_fence_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a fence for the command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A fence is a heavyweight synchronization primitive used to communicate"]
    #[doc = "       to the host that command list execution has completed."]
    #[doc = "     - The application must only use the fence for the command queue which"]
    #[doc = "       was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCreateFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeFenceCreate(
        hCommandQueue: ze_command_queue_handle_t,
        desc: *const ze_fence_desc_t,
        phFence: *mut ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes a fence object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the fence before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this fence."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same fence handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkDestroyFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeFenceDestroy(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on a fence to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkWaitForFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeFenceHostSynchronize(hFence: ze_fence_handle_t, timeout: u64) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries a fence object's status."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkGetFenceStatus**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeFenceQueryStatus(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a fence back to the not signaled state."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkResetFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    pub fn zeFenceReset(hFence: ze_fence_handle_t) -> ze_result_t;
}
impl _ze_image_flags_t {
    #[doc = "< kernels will write contents"]
    pub const ZE_IMAGE_FLAG_KERNEL_WRITE: _ze_image_flags_t = _ze_image_flags_t(1);
}
impl _ze_image_flags_t {
    #[doc = "< device should not cache contents"]
    pub const ZE_IMAGE_FLAG_BIAS_UNCACHED: _ze_image_flags_t = _ze_image_flags_t(2);
}
impl _ze_image_flags_t {
    pub const ZE_IMAGE_FLAG_FORCE_UINT32: _ze_image_flags_t = _ze_image_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_image_flags_t> for _ze_image_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_image_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_image_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_image_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_image_flags_t> for _ze_image_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_image_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_image_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_image_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
pub use self::_ze_image_flags_t as ze_image_flags_t;
impl _ze_image_type_t {
    #[doc = "< 1D"]
    pub const ZE_IMAGE_TYPE_1D: _ze_image_type_t = _ze_image_type_t(0);
}
impl _ze_image_type_t {
    #[doc = "< 1D array"]
    pub const ZE_IMAGE_TYPE_1DARRAY: _ze_image_type_t = _ze_image_type_t(1);
}
impl _ze_image_type_t {
    #[doc = "< 2D"]
    pub const ZE_IMAGE_TYPE_2D: _ze_image_type_t = _ze_image_type_t(2);
}
impl _ze_image_type_t {
    #[doc = "< 2D array"]
    pub const ZE_IMAGE_TYPE_2DARRAY: _ze_image_type_t = _ze_image_type_t(3);
}
impl _ze_image_type_t {
    #[doc = "< 3D"]
    pub const ZE_IMAGE_TYPE_3D: _ze_image_type_t = _ze_image_type_t(4);
}
impl _ze_image_type_t {
    #[doc = "< Buffer"]
    pub const ZE_IMAGE_TYPE_BUFFER: _ze_image_type_t = _ze_image_type_t(5);
}
impl _ze_image_type_t {
    pub const ZE_IMAGE_TYPE_FORCE_UINT32: _ze_image_type_t = _ze_image_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image types"]
pub use self::_ze_image_type_t as ze_image_type_t;
impl _ze_image_format_layout_t {
    #[doc = "< 8-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8: _ze_image_format_layout_t = _ze_image_format_layout_t(0);
}
impl _ze_image_format_layout_t {
    #[doc = "< 16-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16: _ze_image_format_layout_t = _ze_image_format_layout_t(1);
}
impl _ze_image_format_layout_t {
    #[doc = "< 32-bit single component layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32: _ze_image_format_layout_t = _ze_image_format_layout_t(2);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 8-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8_8: _ze_image_format_layout_t = _ze_image_format_layout_t(3);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 8-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_8_8_8_8: _ze_image_format_layout_t =
        _ze_image_format_layout_t(4);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 16-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16_16: _ze_image_format_layout_t =
        _ze_image_format_layout_t(5);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 16-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_16_16_16_16: _ze_image_format_layout_t =
        _ze_image_format_layout_t(6);
}
impl _ze_image_format_layout_t {
    #[doc = "< 2-component 32-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32_32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(7);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 32-bit layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_32_32_32_32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(8);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 10_10_10_2 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_10_10_10_2: _ze_image_format_layout_t =
        _ze_image_format_layout_t(9);
}
impl _ze_image_format_layout_t {
    #[doc = "< 3-component 11_11_10 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_11_11_10: _ze_image_format_layout_t =
        _ze_image_format_layout_t(10);
}
impl _ze_image_format_layout_t {
    #[doc = "< 3-component 5_6_5 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_5_6_5: _ze_image_format_layout_t =
        _ze_image_format_layout_t(11);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 5_5_5_1 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_5_5_5_1: _ze_image_format_layout_t =
        _ze_image_format_layout_t(12);
}
impl _ze_image_format_layout_t {
    #[doc = "< 4-component 4_4_4_4 layout"]
    pub const ZE_IMAGE_FORMAT_LAYOUT_4_4_4_4: _ze_image_format_layout_t =
        _ze_image_format_layout_t(13);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y8: _ze_image_format_layout_t = _ze_image_format_layout_t(14);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: NV12. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_NV12: _ze_image_format_layout_t =
        _ze_image_format_layout_t(15);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YUYV. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YUYV: _ze_image_format_layout_t =
        _ze_image_format_layout_t(16);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: VYUY. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_VYUY: _ze_image_format_layout_t =
        _ze_image_format_layout_t(17);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YVYU. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YVYU: _ze_image_format_layout_t =
        _ze_image_format_layout_t(18);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: UYVY. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_UYVY: _ze_image_format_layout_t =
        _ze_image_format_layout_t(19);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: AYUV. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_AYUV: _ze_image_format_layout_t =
        _ze_image_format_layout_t(20);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P010. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P010: _ze_image_format_layout_t =
        _ze_image_format_layout_t(21);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y410. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y410: _ze_image_format_layout_t =
        _ze_image_format_layout_t(22);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P012. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P012: _ze_image_format_layout_t =
        _ze_image_format_layout_t(23);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y16. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y16: _ze_image_format_layout_t = _ze_image_format_layout_t(24);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P016. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P016: _ze_image_format_layout_t =
        _ze_image_format_layout_t(25);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y216. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y216: _ze_image_format_layout_t =
        _ze_image_format_layout_t(26);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P216. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P216: _ze_image_format_layout_t =
        _ze_image_format_layout_t(27);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: P8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_P8: _ze_image_format_layout_t = _ze_image_format_layout_t(28);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YUY2. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YUY2: _ze_image_format_layout_t =
        _ze_image_format_layout_t(29);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: A8P8. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_A8P8: _ze_image_format_layout_t =
        _ze_image_format_layout_t(30);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: IA44. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_IA44: _ze_image_format_layout_t =
        _ze_image_format_layout_t(31);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: AI44. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_AI44: _ze_image_format_layout_t =
        _ze_image_format_layout_t(32);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y416. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y416: _ze_image_format_layout_t =
        _ze_image_format_layout_t(33);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: Y210. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_Y210: _ze_image_format_layout_t =
        _ze_image_format_layout_t(34);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: I420. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_I420: _ze_image_format_layout_t =
        _ze_image_format_layout_t(35);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: YV12. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_YV12: _ze_image_format_layout_t =
        _ze_image_format_layout_t(36);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 400P. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_400P: _ze_image_format_layout_t =
        _ze_image_format_layout_t(37);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 422H. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_422H: _ze_image_format_layout_t =
        _ze_image_format_layout_t(38);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 422V. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_422V: _ze_image_format_layout_t =
        _ze_image_format_layout_t(39);
}
impl _ze_image_format_layout_t {
    #[doc = "< Media Format: 444P. Format type and swizzle is ignored for this."]
    pub const ZE_IMAGE_FORMAT_LAYOUT_444P: _ze_image_format_layout_t =
        _ze_image_format_layout_t(40);
}
impl _ze_image_format_layout_t {
    pub const ZE_IMAGE_FORMAT_LAYOUT_FORCE_UINT32: _ze_image_format_layout_t =
        _ze_image_format_layout_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_layout_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
pub use self::_ze_image_format_layout_t as ze_image_format_layout_t;
impl _ze_image_format_type_t {
    #[doc = "< Unsigned integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_UINT: _ze_image_format_type_t = _ze_image_format_type_t(0);
}
impl _ze_image_format_type_t {
    #[doc = "< Signed integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_SINT: _ze_image_format_type_t = _ze_image_format_type_t(1);
}
impl _ze_image_format_type_t {
    #[doc = "< Unsigned normalized integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_UNORM: _ze_image_format_type_t = _ze_image_format_type_t(2);
}
impl _ze_image_format_type_t {
    #[doc = "< Signed normalized integer"]
    pub const ZE_IMAGE_FORMAT_TYPE_SNORM: _ze_image_format_type_t = _ze_image_format_type_t(3);
}
impl _ze_image_format_type_t {
    #[doc = "< Float"]
    pub const ZE_IMAGE_FORMAT_TYPE_FLOAT: _ze_image_format_type_t = _ze_image_format_type_t(4);
}
impl _ze_image_format_type_t {
    pub const ZE_IMAGE_FORMAT_TYPE_FORCE_UINT32: _ze_image_format_type_t =
        _ze_image_format_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format types"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format types"]
pub use self::_ze_image_format_type_t as ze_image_format_type_t;
impl _ze_image_format_swizzle_t {
    #[doc = "< Red component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_R: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(0);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Green component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_G: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(1);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Blue component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_B: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(2);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Alpha component"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_A: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(3);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Zero"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_0: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(4);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< One"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_1: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(5);
}
impl _ze_image_format_swizzle_t {
    #[doc = "< Don't care"]
    pub const ZE_IMAGE_FORMAT_SWIZZLE_X: _ze_image_format_swizzle_t = _ze_image_format_swizzle_t(6);
}
impl _ze_image_format_swizzle_t {
    pub const ZE_IMAGE_FORMAT_SWIZZLE_FORCE_UINT32: _ze_image_format_swizzle_t =
        _ze_image_format_swizzle_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_format_swizzle_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
pub use self::_ze_image_format_swizzle_t as ze_image_format_swizzle_t;
#[doc = ""]
#[doc = " @brief Image format"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_format_t {
    #[doc = "< [in] image format component layout"]
    pub layout: ze_image_format_layout_t,
    #[doc = "< [in] image format type. Media formats can't be used for"]
    #[doc = "< ::ZE_IMAGE_TYPE_BUFFER."]
    pub type_: ze_image_format_type_t,
    #[doc = "< [in] image component swizzle into channel x"]
    pub x: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel y"]
    pub y: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel z"]
    pub z: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel w"]
    pub w: ze_image_format_swizzle_t,
}
#[test]
fn bindgen_test_layout__ze_image_format_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_format_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_format_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_format_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_format_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).layout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_t>())).w as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_t),
            "::",
            stringify!(w)
        )
    );
}
#[doc = ""]
#[doc = " @brief Image descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_image_flags_t;"]
    #[doc = "< default is read-only, cached access."]
    pub flags: ze_image_flags_t,
    #[doc = "< [in] image type"]
    pub type_: ze_image_type_t,
    #[doc = "< [in] image format"]
    pub format: ze_image_format_t,
    #[doc = "< [in] width dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_BUFFER: size in bytes; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageBufferSize for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_1D, ::ZE_IMAGE_TYPE_1DARRAY: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims1D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_2D, ::ZE_IMAGE_TYPE_2DARRAY: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims2D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: width in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    pub width: u64,
    #[doc = "< [in] height dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_2D, ::ZE_IMAGE_TYPE_2DARRAY: height in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims2D for limits."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: height in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    #[doc = "< other: ignored."]
    pub height: u32,
    #[doc = "< [in] depth dimension."]
    #[doc = "< ::ZE_IMAGE_TYPE_3D: depth in pixels; see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageDims3D for limits."]
    #[doc = "< other: ignored."]
    pub depth: u32,
    #[doc = "< [in] array levels."]
    #[doc = "< ::ZE_IMAGE_TYPE_1DARRAY, ::ZE_IMAGE_TYPE_2DARRAY: see"]
    #[doc = "< ::ze_device_image_properties_t.maxImageArraySlices for limits."]
    #[doc = "< other: ignored."]
    pub arraylevels: u32,
    #[doc = "< [in] mipmap levels (must be 0)"]
    pub miplevels: u32,
}
#[test]
fn bindgen_test_layout__ze_image_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_desc_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).format as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).width as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).height as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).depth as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).arraylevels as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(arraylevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).miplevels as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(miplevels)
        )
    );
}
impl _ze_image_sampler_filter_flags_t {
    #[doc = "< device supports point filtering"]
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_POINT: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(1);
}
impl _ze_image_sampler_filter_flags_t {
    #[doc = "< device supports linear filtering"]
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_LINEAR: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(2);
}
impl _ze_image_sampler_filter_flags_t {
    pub const ZE_IMAGE_SAMPLER_FILTER_FLAG_FORCE_UINT32: _ze_image_sampler_filter_flags_t =
        _ze_image_sampler_filter_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_image_sampler_filter_flags_t> for _ze_image_sampler_filter_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_image_sampler_filter_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_image_sampler_filter_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_image_sampler_filter_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_image_sampler_filter_flags_t> for _ze_image_sampler_filter_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_image_sampler_filter_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_image_sampler_filter_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_image_sampler_filter_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_image_sampler_filter_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
pub use self::_ze_image_sampler_filter_flags_t as ze_image_sampler_filter_flags_t;
#[doc = ""]
#[doc = " @brief Image properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] supported sampler filtering."]
    #[doc = "< returns 0 (unsupported) or a combination of ::ze_image_sampler_filter_flags_t."]
    pub samplerFilterFlags: ze_image_sampler_filter_flags_t,
}
#[test]
fn bindgen_test_layout__ze_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_properties_t>())).samplerFilterFlags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(samplerFilterFlags)
        )
    );
}
impl Default for _ze_image_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves supported properties of an image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == pImageProperties`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "         + `::ZE_IMAGE_TYPE_BUFFER < desc->type`"]
    pub fn zeImageGetProperties(
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        pImageProperties: *mut ze_image_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an image on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the image for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "         + `::ZE_IMAGE_TYPE_BUFFER < desc->type`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeImageCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        phImage: *mut ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an image object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the image before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this image."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same image handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeImageDestroy(hImage: ze_image_handle_t) -> ze_result_t;
}
impl _ze_device_mem_alloc_flags_t {
    #[doc = "< device should cache allocation"]
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(1);
}
impl _ze_device_mem_alloc_flags_t {
    #[doc = "< device should not cache allocation (UC)"]
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(2);
}
impl _ze_device_mem_alloc_flags_t {
    pub const ZE_DEVICE_MEM_ALLOC_FLAG_FORCE_UINT32: _ze_device_mem_alloc_flags_t =
        _ze_device_mem_alloc_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_mem_alloc_flags_t> for _ze_device_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_mem_alloc_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_mem_alloc_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_mem_alloc_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_mem_alloc_flags_t> for _ze_device_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_mem_alloc_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_mem_alloc_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_mem_alloc_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_mem_alloc_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
pub use self::_ze_device_mem_alloc_flags_t as ze_device_mem_alloc_flags_t;
#[doc = ""]
#[doc = " @brief Device memory allocation descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_mem_alloc_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying additional allocation controls."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_device_mem_alloc_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_device_mem_alloc_flags_t,
    #[doc = "< [in] ordinal of the device's local memory to allocate from."]
    #[doc = "< must be less than the count returned from ::zeDeviceGetMemoryProperties."]
    pub ordinal: u32,
}
#[test]
fn bindgen_test_layout__ze_device_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_mem_alloc_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_mem_alloc_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).ordinal as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host should cache allocation"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_CACHED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(1);
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host should not cache allocation (UC)"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(2);
}
impl _ze_host_mem_alloc_flags_t {
    #[doc = "< host memory should be allocated write-combined (WC)"]
    pub const ZE_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(4);
}
impl _ze_host_mem_alloc_flags_t {
    pub const ZE_HOST_MEM_ALLOC_FLAG_FORCE_UINT32: _ze_host_mem_alloc_flags_t =
        _ze_host_mem_alloc_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_host_mem_alloc_flags_t> for _ze_host_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_host_mem_alloc_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_host_mem_alloc_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_host_mem_alloc_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_host_mem_alloc_flags_t> for _ze_host_mem_alloc_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_host_mem_alloc_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_host_mem_alloc_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_host_mem_alloc_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_host_mem_alloc_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
pub use self::_ze_host_mem_alloc_flags_t as ze_host_mem_alloc_flags_t;
#[doc = ""]
#[doc = " @brief Host memory allocation descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_host_mem_alloc_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying additional allocation controls."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_host_mem_alloc_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_host_mem_alloc_flags_t,
}
#[test]
fn bindgen_test_layout__ze_host_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_host_mem_alloc_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_host_mem_alloc_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates shared memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Shared allocations share ownership between the host and one or more"]
    #[doc = "       devices."]
    #[doc = "     - Shared allocations may optionally be associated with a device by"]
    #[doc = "       passing a handle to the device."]
    #[doc = "     - Devices supporting only single-device shared access capabilities may"]
    #[doc = "       access shared memory associated with the device."]
    #[doc = "       For these devices, ownership of the allocation is shared between the"]
    #[doc = "       host and the associated device only."]
    #[doc = "     - Passing nullptr as the device handle does not associate the shared"]
    #[doc = "       allocation with any device."]
    #[doc = "       For allocations with no associated device, ownership of the allocation"]
    #[doc = "       is shared between the host and all devices supporting cross-device"]
    #[doc = "       shared access capabilities."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       and device, or its sub-devices, which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < device_desc->flags`"]
    #[doc = "         + `0x7 < host_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocShared(
        hContext: ze_context_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates device memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Device allocations are owned by a specific device."]
    #[doc = "     - In general, a device allocation may only be accessed by the device"]
    #[doc = "       that owns it."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       and device, or its sub-devices, which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < device_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocDevice(
        hContext: ze_context_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates host memory on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Host allocations are owned by the host process."]
    #[doc = "     - Host allocations are accessible by the host and all devices within the"]
    #[doc = "       driver's context."]
    #[doc = "     - Host allocations are frequently used as staging areas to transfer data"]
    #[doc = "       to or from devices."]
    #[doc = "     - The application must only use the memory allocation for the context"]
    #[doc = "       which was provided during allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < host_desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "         + Must be zero or a power-of-two"]
    #[doc = "         + `0 != (alignment & (alignment - 1))`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeMemAllocHost(
        hContext: ze_context_handle_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Frees allocated host memory, device memory, or shared memory on the"]
    #[doc = "        context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the memory before it is freed"]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this memory"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemFree(
        hContext: ze_context_handle_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is of unknown type"]
    pub const ZE_MEMORY_TYPE_UNKNOWN: _ze_memory_type_t = _ze_memory_type_t(0);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a host allocation"]
    pub const ZE_MEMORY_TYPE_HOST: _ze_memory_type_t = _ze_memory_type_t(1);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a device allocation"]
    pub const ZE_MEMORY_TYPE_DEVICE: _ze_memory_type_t = _ze_memory_type_t(2);
}
impl _ze_memory_type_t {
    #[doc = "< the memory pointed to is a shared ownership allocation"]
    pub const ZE_MEMORY_TYPE_SHARED: _ze_memory_type_t = _ze_memory_type_t(3);
}
impl _ze_memory_type_t {
    pub const ZE_MEMORY_TYPE_FORCE_UINT32: _ze_memory_type_t = _ze_memory_type_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Memory allocation type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_type_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Memory allocation type"]
pub use self::_ze_memory_type_t as ze_memory_type_t;
#[doc = ""]
#[doc = " @brief Memory allocation properties queried using ::zeMemGetAllocProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_memory_allocation_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] type of allocated memory"]
    pub type_: ze_memory_type_t,
    #[doc = "< [out] identifier for this allocation"]
    pub id: u64,
    #[doc = "< [out] page size used for allocation"]
    pub pageSize: u64,
}
#[test]
fn bindgen_test_layout__ze_memory_allocation_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_memory_allocation_properties_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_memory_allocation_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_memory_allocation_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_memory_allocation_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).type_ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).id as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).pageSize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(pageSize)
        )
    );
}
impl Default for _ze_memory_allocation_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves attributes of a memory allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The application may query attributes of a memory allocation unrelated"]
    #[doc = "       to the context."]
    #[doc = "       When this occurs, the returned allocation type will be"]
    #[doc = "       ::ZE_MEMORY_TYPE_UNKNOWN, and the returned identifier and associated"]
    #[doc = "       device is unspecified."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pMemAllocProperties`"]
    pub fn zeMemGetAllocProperties(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pMemAllocProperties: *mut ze_memory_allocation_properties_t,
        phDevice: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves the base address and/or size of an allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemGetAddressRange(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pBase: *mut *mut ::std::os::raw::c_void,
        pSize: *mut usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an IPC memory handle for the specified allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes a pointer to a device memory allocation and creates an IPC"]
    #[doc = "       memory handle for exporting it for use in another process."]
    #[doc = "     - The pointer must be base pointer of the device memory allocation; i.e."]
    #[doc = "       the value returned from ::zeMemAllocDevice."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pIpcHandle`"]
    pub fn zeMemGetIpcHandle(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pIpcHandle: *mut ze_ipc_mem_handle_t,
    ) -> ze_result_t;
}
impl _ze_ipc_memory_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_IPC_MEMORY_FLAG_TBD: _ze_ipc_memory_flags_t = _ze_ipc_memory_flags_t(1);
}
impl _ze_ipc_memory_flags_t {
    pub const ZE_IPC_MEMORY_FLAG_FORCE_UINT32: _ze_ipc_memory_flags_t =
        _ze_ipc_memory_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_ipc_memory_flags_t> for _ze_ipc_memory_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_ipc_memory_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_ipc_memory_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_ipc_memory_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_ipc_memory_flags_t> for _ze_ipc_memory_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_ipc_memory_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_ipc_memory_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_ipc_memory_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_ipc_memory_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
pub use self::_ze_ipc_memory_flags_t as ze_ipc_memory_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC memory handle to retrieve a device pointer on the"]
    #[doc = "        context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes an IPC memory handle from a remote process and associates it"]
    #[doc = "       with a device pointer usable in this process."]
    #[doc = "     - The device pointer in this process should not be freed with"]
    #[doc = "       ::zeMemFree, but rather with ::zeMemCloseIpcHandle."]
    #[doc = "     - Multiple calls to this function with the same IPC handle will return"]
    #[doc = "       unique pointers."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pptr`"]
    pub fn zeMemOpenIpcHandle(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        handle: ze_ipc_mem_handle_t,
        flags: ze_ipc_memory_flags_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC memory handle"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC memory handle by unmapping memory that was opened in"]
    #[doc = "       this process using ::zeMemOpenIpcHandle."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeMemCloseIpcHandle(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Additional allocation descriptor for exporting external memory"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be passed to ::zeMemAllocDevice, via the `pNext`"]
#[doc = "       member of ::ze_device_mem_alloc_desc_t, to indicate an exportable"]
#[doc = "       memory allocation."]
#[doc = "     - This structure may be passed to ::zeImageCreate, via the `pNext`"]
#[doc = "       member of ::ze_image_desc_t, to indicate an exportable image."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_external_memory_export_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying memory export types for this allocation."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_external_memory_type_flags_t"]
    pub flags: ze_external_memory_type_flags_t,
}
#[test]
fn bindgen_test_layout__ze_external_memory_export_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_external_memory_export_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_external_memory_export_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_external_memory_export_desc_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_external_memory_export_desc_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_desc_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_desc_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_desc_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Additional allocation descriptor for importing external memory as a"]
#[doc = "        file descriptor"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be passed to ::zeMemAllocDevice, via the `pNext`"]
#[doc = "       member of ::ze_device_mem_alloc_desc_t, to import memory from a file"]
#[doc = "       descriptor."]
#[doc = "     - This structure may be passed to ::zeImageCreate, via the `pNext`"]
#[doc = "       member of ::ze_image_desc_t, to import memory from a file descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_external_memory_import_fd_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying the memory import type for the file descriptor."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_external_memory_type_flags_t"]
    pub flags: ze_external_memory_type_flags_t,
    #[doc = "< [in] the file descriptor handle to import"]
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__ze_external_memory_import_fd_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_external_memory_import_fd_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_external_memory_import_fd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_external_memory_import_fd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_external_memory_import_fd_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_import_fd_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_import_fd_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_import_fd_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_import_fd_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_import_fd_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_import_fd_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_import_fd_t>())).fd as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_import_fd_t),
            "::",
            stringify!(fd)
        )
    );
}
#[doc = ""]
#[doc = " @brief Exports an allocation as a file descriptor"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be passed to ::zeMemGetAllocProperties, via the"]
#[doc = "       `pNext` member of ::ze_memory_allocation_properties_t, to export a"]
#[doc = "       memory allocation as a file descriptor."]
#[doc = "     - This structure may be passed to ::zeImageGetProperties, via the"]
#[doc = "       `pNext` member of ::ze_image_properties_t, to export an image as a"]
#[doc = "       file descriptor."]
#[doc = "     - The requested memory export type must have been specified when the"]
#[doc = "       allocation was made."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_external_memory_export_fd_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying the memory export type for the file descriptor."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_external_memory_type_flags_t"]
    pub flags: ze_external_memory_type_flags_t,
    #[doc = "< [out] the exported file descriptor handle representing the allocation."]
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__ze_external_memory_export_fd_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_external_memory_export_fd_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_external_memory_export_fd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_external_memory_export_fd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_external_memory_export_fd_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_fd_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_fd_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_fd_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_fd_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_fd_t>())).flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_fd_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_external_memory_export_fd_t>())).fd as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_external_memory_export_fd_t),
            "::",
            stringify!(fd)
        )
    );
}
impl _ze_module_format_t {
    #[doc = "< Format is SPIRV IL format"]
    pub const ZE_MODULE_FORMAT_IL_SPIRV: _ze_module_format_t = _ze_module_format_t(0);
}
impl _ze_module_format_t {
    #[doc = "< Format is device native format"]
    pub const ZE_MODULE_FORMAT_NATIVE: _ze_module_format_t = _ze_module_format_t(1);
}
impl _ze_module_format_t {
    pub const ZE_MODULE_FORMAT_FORCE_UINT32: _ze_module_format_t = _ze_module_format_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_module_format_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
pub use self::_ze_module_format_t as ze_module_format_t;
#[doc = ""]
#[doc = " @brief Specialization constants - User defined constants"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_constants_t {
    #[doc = "< [in] Number of specialization constants."]
    pub numConstants: u32,
    #[doc = "< [in][range(0, numConstants)] Array of IDs that is sized to"]
    #[doc = "< numConstants."]
    pub pConstantIds: *const u32,
    #[doc = "< [in][range(0, numConstants)] Array of pointers to values that is sized"]
    #[doc = "< to numConstants."]
    pub pConstantValues: *mut *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_module_constants_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_constants_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_constants_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).numConstants as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(numConstants)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantIds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantValues as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantValues)
        )
    );
}
#[doc = ""]
#[doc = " @brief Module descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] Module format passed in with pInputModule"]
    pub format: ze_module_format_t,
    #[doc = "< [in] size of input IL or ISA from pInputModule."]
    pub inputSize: usize,
    #[doc = "< [in] pointer to IL or ISA"]
    pub pInputModule: *const u8,
    #[doc = "< [in][optional] string containing compiler flags. Following options are supported."]
    #[doc = "<  - \"-ze-opt-disable\""]
    #[doc = "<       - Disable optimizations"]
    #[doc = "<  - \"-ze-opt-greater-than-4GB-buffer-required\""]
    #[doc = "<       - Use 64-bit offset calculations for buffers."]
    #[doc = "<  - \"-ze-opt-large-register-file\""]
    #[doc = "<       - Increase number of registers available to threads."]
    #[doc = "<  - \"-ze-opt-has-buffer-offset-arg\""]
    #[doc = "<       - Extend stateless to stateful optimization to more"]
    #[doc = "<         cases with the use of additional offset (e.g. 64-bit"]
    #[doc = "<         pointer to binding table with 32-bit offset)."]
    #[doc = "<  - \"-g\""]
    #[doc = "<       - Include debugging information."]
    pub pBuildFlags: *const ::std::os::raw::c_char,
    #[doc = "< [in][optional] pointer to specialization constants. Valid only for"]
    #[doc = "< SPIR-V input. This must be set to nullptr if no specialization"]
    #[doc = "< constants are provided."]
    pub pConstants: *const ze_module_constants_t,
}
#[test]
fn bindgen_test_layout__ze_module_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_desc_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).format as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).inputSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(inputSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pInputModule as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pInputModule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pBuildFlags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pBuildFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pConstants as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pConstants)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a module on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Compiles the module for execution on the device."]
    #[doc = "     - The application must only use the module for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The module can be copied to other devices and contexts within the same"]
    #[doc = "       driver instance by using ::zeModuleGetNativeBinary."]
    #[doc = "     - A build log can optionally be returned to the caller. The caller is"]
    #[doc = "       responsible for destroying build log using ::zeModuleBuildLogDestroy."]
    #[doc = "     - The module descriptor constants are only supported for SPIR-V"]
    #[doc = "       specialization constants."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pInputModule`"]
    #[doc = "         + `nullptr == phModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MODULE_FORMAT_NATIVE < desc->format`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NATIVE_BINARY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == desc->inputSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_MODULE_BUILD_FAILURE"]
    pub fn zeModuleCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_module_desc_t,
        phModule: *mut ze_module_handle_t,
        phBuildLog: *mut ze_module_build_log_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must destroy all kernel and build log handles created"]
    #[doc = "       from the module before destroying the module itself."]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the module before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this module."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same module handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleDestroy(hModule: ze_module_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Dynamically link modules together that share import/export linkage"]
    #[doc = "        dependencies."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Modules support import and export linkage for functions and global"]
    #[doc = "       variables."]
    #[doc = "     - Modules that have imports can be dynamically linked to export modules"]
    #[doc = "       that satisfy those import requirements."]
    #[doc = "     - Modules can have both import and export linkages."]
    #[doc = "     - Modules that do not have any imports or exports do not need to be"]
    #[doc = "       linked."]
    #[doc = "     - Modules cannot be partially linked. All modules needed to satisfy all"]
    #[doc = "       import dependencies for a module must be passed in or"]
    #[doc = "       ::ZE_RESULT_ERROR_MODULE_LINK_FAILURE will returned."]
    #[doc = "     - Modules with imports need to be linked before kernel objects can be"]
    #[doc = "       created from them."]
    #[doc = "     - Modules will only be linked once. A module can be used in multiple"]
    #[doc = "       link calls if it has exports but it's imports will not be re-linked."]
    #[doc = "     - Ambiguous dependencies, where multiple modules satisfy the import"]
    #[doc = "       dependencies for another module, is not allowed."]
    #[doc = "     - ModuleGetNativeBinary can be called on any module regardless of"]
    #[doc = "       whether it is linked or not."]
    #[doc = "     - A link log can optionally be returned to the caller. The caller is"]
    #[doc = "       responsible for destroying build log using ::zeModuleBuildLogDestroy."]
    #[doc = "     - See SPIR-V specification for linkage details."]
    #[doc = "     - The application must ensure the modules being linked were created on"]
    #[doc = "       the same context."]
    #[doc = "     - The application may call this function from simultaneous threads as"]
    #[doc = "       long as the import modules being linked are not the same."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phModules`"]
    #[doc = "     - ::ZE_RESULT_ERROR_MODULE_LINK_FAILURE"]
    pub fn zeModuleDynamicLink(
        numModules: u32,
        phModules: *mut ze_module_handle_t,
        phLinkLog: *mut ze_module_build_log_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module build log object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The implementation of this function may immediately free all Host"]
    #[doc = "       allocations associated with this object."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same build log handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - This function can be called before or after ::zeModuleDestroy for the"]
    #[doc = "       associated module."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleBuildLogDestroy(hModuleBuildLog: ze_module_build_log_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves text string for build log."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The caller can pass nullptr for pBuildLog when querying only for size."]
    #[doc = "     - The caller must provide memory for build log."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleBuildLogGetString(
        hModuleBuildLog: ze_module_build_log_handle_t,
        pSize: *mut usize,
        pBuildLog: *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve native binary from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The native binary output can be cached to disk and new modules can be"]
    #[doc = "       later constructed from the cached copy."]
    #[doc = "     - The native binary will retain debugging information that is associated"]
    #[doc = "       with a module."]
    #[doc = "     - The caller can pass nullptr for pModuleNativeBinary when querying only"]
    #[doc = "       for size."]
    #[doc = "     - The implementation will copy the native binary into a buffer supplied"]
    #[doc = "       by the caller."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleGetNativeBinary(
        hModule: ze_module_handle_t,
        pSize: *mut usize,
        pModuleNativeBinary: *mut u8,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve global variable pointer from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may query global pointer from any module that either"]
    #[doc = "       exports or imports it."]
    #[doc = "     - The application must dynamically link a module that imports a global"]
    #[doc = "       before the global pointer can be queried from it."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pGlobalName`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_NAME"]
    pub fn zeModuleGetGlobalPointer(
        hModule: ze_module_handle_t,
        pGlobalName: *const ::std::os::raw::c_char,
        pSize: *mut usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve all kernel names in the module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeModuleGetKernelNames(
        hModule: ze_module_handle_t,
        pCount: *mut u32,
        pNames: *mut *const ::std::os::raw::c_char,
    ) -> ze_result_t;
}
impl _ze_module_property_flags_t {
    #[doc = "< Module has imports (i.e. imported global variables and/or kernels)."]
    #[doc = "< See ::zeModuleDynamicLink."]
    pub const ZE_MODULE_PROPERTY_FLAG_IMPORTS: _ze_module_property_flags_t =
        _ze_module_property_flags_t(1);
}
impl _ze_module_property_flags_t {
    pub const ZE_MODULE_PROPERTY_FLAG_FORCE_UINT32: _ze_module_property_flags_t =
        _ze_module_property_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_module_property_flags_t> for _ze_module_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_module_property_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_module_property_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_module_property_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_module_property_flags_t> for _ze_module_property_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_module_property_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_module_property_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_module_property_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported module property flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_module_property_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported module property flags"]
pub use self::_ze_module_property_flags_t as ze_module_property_flags_t;
#[doc = ""]
#[doc = " @brief Module properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 (none) or a valid combination of ::ze_module_property_flags_t"]
    pub flags: ze_module_property_flags_t,
}
#[test]
fn bindgen_test_layout__ze_module_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_properties_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_properties_t),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for _ze_module_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve module properties."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pModuleProperties`"]
    pub fn zeModuleGetProperties(
        hModule: ze_module_handle_t,
        pModuleProperties: *mut ze_module_properties_t,
    ) -> ze_result_t;
}
impl _ze_kernel_flags_t {
    #[doc = "< force all device allocations to be resident during execution"]
    pub const ZE_KERNEL_FLAG_FORCE_RESIDENCY: _ze_kernel_flags_t = _ze_kernel_flags_t(1);
}
impl _ze_kernel_flags_t {
    #[doc = "< application is responsible for all residency of device allocations."]
    #[doc = "< driver may disable implicit residency management."]
    pub const ZE_KERNEL_FLAG_EXPLICIT_RESIDENCY: _ze_kernel_flags_t = _ze_kernel_flags_t(2);
}
impl _ze_kernel_flags_t {
    pub const ZE_KERNEL_FLAG_FORCE_UINT32: _ze_kernel_flags_t = _ze_kernel_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_kernel_flags_t> for _ze_kernel_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_kernel_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_kernel_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_kernel_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_kernel_flags_t> for _ze_kernel_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_kernel_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_kernel_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_kernel_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_kernel_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
pub use self::_ze_kernel_flags_t as ze_kernel_flags_t;
#[doc = ""]
#[doc = " @brief Kernel descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_kernel_flags_t;"]
    #[doc = "< default behavior may use driver-based residency."]
    pub flags: ze_kernel_flags_t,
    #[doc = "< [in] null-terminated name of kernel in module"]
    pub pKernelName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_kernel_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).pKernelName as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(pKernelName)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Create a kernel from the module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Modules that have unresolved imports need to be dynamically linked"]
    #[doc = "       before a kernel can be created from them. (See ::zeModuleDynamicLink)"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pKernelName`"]
    #[doc = "         + `nullptr == phKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_NAME"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_MODULE_UNLINKED"]
    pub fn zeKernelCreate(
        hModule: ze_module_handle_t,
        desc: *const ze_kernel_desc_t,
        phKernel: *mut ze_kernel_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a kernel object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the kernel before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this kernel."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeKernelDestroy(hKernel: ze_kernel_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve a function pointer from a module by name"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The function pointer is unique for the device on which the module was"]
    #[doc = "       created."]
    #[doc = "     - The function pointer is no longer valid if module is destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFunctionName`"]
    #[doc = "         + `nullptr == pfnFunction`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_FUNCTION_NAME"]
    pub fn zeModuleGetFunctionPointer(
        hModule: ze_module_handle_t,
        pFunctionName: *const ::std::os::raw::c_char,
        pfnFunction: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set group size for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The group size will be used when a ::zeCommandListAppendLaunchKernel"]
    #[doc = "       variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION"]
    pub fn zeKernelSetGroupSize(
        hKernel: ze_kernel_handle_t,
        groupSizeX: u32,
        groupSizeY: u32,
        groupSizeZ: u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested group size for a kernel given a global size for each"]
    #[doc = "        dimension."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function ignores the group size that is set using"]
    #[doc = "       ::zeKernelSetGroupSize."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == groupSizeX`"]
    #[doc = "         + `nullptr == groupSizeY`"]
    #[doc = "         + `nullptr == groupSizeZ`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION"]
    pub fn zeKernelSuggestGroupSize(
        hKernel: ze_kernel_handle_t,
        globalSizeX: u32,
        globalSizeY: u32,
        globalSizeZ: u32,
        groupSizeX: *mut u32,
        groupSizeY: *mut u32,
        groupSizeZ: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested max group count for a cooperative kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == totalGroupCount`"]
    pub fn zeKernelSuggestMaxCooperativeGroupCount(
        hKernel: ze_kernel_handle_t,
        totalGroupCount: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set kernel argument for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The argument values will be used when a"]
    #[doc = "       ::zeCommandListAppendLaunchKernel variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE"]
    pub fn zeKernelSetArgumentValue(
        hKernel: ze_kernel_handle_t,
        argIndex: u32,
        argSize: usize,
        pArgValue: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses host allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_HOST: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(1);
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses device allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_DEVICE: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(2);
}
impl _ze_kernel_indirect_access_flags_t {
    #[doc = "< Indicates that the kernel accesses shared allocations indirectly."]
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_SHARED: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(4);
}
impl _ze_kernel_indirect_access_flags_t {
    pub const ZE_KERNEL_INDIRECT_ACCESS_FLAG_FORCE_UINT32: _ze_kernel_indirect_access_flags_t =
        _ze_kernel_indirect_access_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_kernel_indirect_access_flags_t> for _ze_kernel_indirect_access_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_kernel_indirect_access_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_kernel_indirect_access_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_kernel_indirect_access_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_kernel_indirect_access_flags_t> for _ze_kernel_indirect_access_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_kernel_indirect_access_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_kernel_indirect_access_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_kernel_indirect_access_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Kernel indirect access flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_kernel_indirect_access_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Kernel indirect access flags"]
pub use self::_ze_kernel_indirect_access_flags_t as ze_kernel_indirect_access_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets kernel indirect access flags."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application should specify which allocations will be indirectly"]
    #[doc = "       accessed by the kernel to allow driver to optimize which allocations"]
    #[doc = "       are made resident"]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x7 < flags`"]
    pub fn zeKernelSetIndirectAccess(
        hKernel: ze_kernel_handle_t,
        flags: ze_kernel_indirect_access_flags_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel indirect access flags."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFlags`"]
    pub fn zeKernelGetIndirectAccess(
        hKernel: ze_kernel_handle_t,
        pFlags: *mut ze_kernel_indirect_access_flags_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve all declared kernel attributes (i.e. can be specified with"]
    #[doc = "        __attribute__ in runtime language)."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       Kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    #[doc = "         + `nullptr == pString`"]
    pub fn zeKernelGetSourceAttributes(
        hKernel: ze_kernel_handle_t,
        pSize: *mut u32,
        pString: *mut *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
impl _ze_cache_config_flags_t {
    #[doc = "< Large SLM size"]
    pub const ZE_CACHE_CONFIG_FLAG_LARGE_SLM: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(1);
}
impl _ze_cache_config_flags_t {
    #[doc = "< Large General Data size"]
    pub const ZE_CACHE_CONFIG_FLAG_LARGE_DATA: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(2);
}
impl _ze_cache_config_flags_t {
    pub const ZE_CACHE_CONFIG_FLAG_FORCE_UINT32: _ze_cache_config_flags_t =
        _ze_cache_config_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_cache_config_flags_t> for _ze_cache_config_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_cache_config_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_cache_config_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_cache_config_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_cache_config_flags_t> for _ze_cache_config_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_cache_config_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_cache_config_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_cache_config_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported Cache Config flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_cache_config_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported Cache Config flags"]
pub use self::_ze_cache_config_flags_t as ze_cache_config_flags_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets the preferred cache configuration for a kernel on the current"]
    #[doc = "        Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The cache configuration will be used when a"]
    #[doc = "       ::zeCommandListAppendLaunchKernel variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x3 < flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_FEATURE"]
    pub fn zeKernelSetCacheConfig(
        hKernel: ze_kernel_handle_t,
        flags: ze_cache_config_flags_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_kernel_uuid_t {
    #[doc = "< [out] opaque data representing a kernel UUID"]
    pub kid: [u8; 16usize],
    #[doc = "< [out] opaque data representing the kernel's module UUID"]
    pub mid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_kernel_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_uuid_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_kernel_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_uuid_t>())).kid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_uuid_t),
            "::",
            stringify!(kid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_uuid_t>())).mid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_uuid_t),
            "::",
            stringify!(mid)
        )
    );
}
#[doc = ""]
#[doc = " @brief Kernel properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] number of kernel arguments."]
    pub numKernelArgs: u32,
    #[doc = "< [out] required group size in the X dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeX: u32,
    #[doc = "< [out] required group size in the Y dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeY: u32,
    #[doc = "< [out] required group size in the Z dimension,"]
    #[doc = "< or zero if there is no required group size"]
    pub requiredGroupSizeZ: u32,
    #[doc = "< [out] required number of subgroups per thread group,"]
    #[doc = "< or zero if there is no required number of subgroups"]
    pub requiredNumSubGroups: u32,
    #[doc = "< [out] required subgroup size,"]
    #[doc = "< or zero if there is no required subgroup size"]
    pub requiredSubgroupSize: u32,
    #[doc = "< [out] maximum subgroup size"]
    pub maxSubgroupSize: u32,
    #[doc = "< [out] maximum number of subgroups per thread group"]
    pub maxNumSubgroups: u32,
    #[doc = "< [out] local memory size used by each thread group"]
    pub localMemSize: u32,
    #[doc = "< [out] private memory size allocated by compiler used by each thread"]
    pub privateMemSize: u32,
    #[doc = "< [out] spill memory size allocated by compiler"]
    pub spillMemSize: u32,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_kernel_uuid_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_properties_t>(),
        96usize,
        concat!("Size of: ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).numKernelArgs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(numKernelArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeZ as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredNumSubGroups as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredNumSubGroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredSubgroupSize as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).maxSubgroupSize as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(maxSubgroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).maxNumSubgroups as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(maxNumSubgroups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).localMemSize as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(localMemSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).privateMemSize as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(privateMemSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).spillMemSize as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(spillMemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).uuid as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(uuid)
        )
    );
}
impl Default for _ze_kernel_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel properties."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pKernelProperties`"]
    pub fn zeKernelGetProperties(
        hKernel: ze_kernel_handle_t,
        pKernelProperties: *mut ze_kernel_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel name from Kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The caller can pass nullptr for pName when querying only for size."]
    #[doc = "     - The implementation will copy the kernel name into a buffer supplied by"]
    #[doc = "       the caller."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeKernelGetName(
        hKernel: ze_kernel_handle_t,
        pSize: *mut usize,
        pName: *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel dispatch group count."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_group_count_t {
    #[doc = "< [in] number of thread groups in X dimension"]
    pub groupCountX: u32,
    #[doc = "< [in] number of thread groups in Y dimension"]
    pub groupCountY: u32,
    #[doc = "< [in] number of thread groups in Z dimension"]
    pub groupCountZ: u32,
}
#[test]
fn bindgen_test_layout__ze_group_count_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_group_count_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_group_count_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountZ)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel cooperatively over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This may only be used for a command list that are submitted to command"]
    #[doc = "       queue with cooperative flag set."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - Use ::zeKernelSuggestMaxCooperativeGroupCount to recommend max group"]
    #[doc = "       count for device for cooperative functions that device supports."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchCooperativeKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups using indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - The application must ensure the launch arguments are visible to the"]
    #[doc = "       device on which the command list was created."]
    #[doc = "     - The implementation must not access the contents of the launch"]
    #[doc = "       arguments as they are free to be modified by either the Host or device"]
    #[doc = "       up until execution."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must ensure the command list, kernel and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchKernelIndirect(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch multiple kernels over one or more work groups using an array of"]
    #[doc = "        indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the kernel and events are accessible by"]
    #[doc = "       the device on which the command list was created."]
    #[doc = "     - The application must ensure the array of launch arguments and count"]
    #[doc = "       buffer are visible to the device on which the command list was"]
    #[doc = "       created."]
    #[doc = "     - The implementation must not access the contents of the array of launch"]
    #[doc = "       arguments or count buffer as they are free to be modified by either"]
    #[doc = "       the Host or device up until execution."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - The application must enusre the command list, kernel and events were"]
    #[doc = "       created, and the memory was allocated, on the same context."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phKernels`"]
    #[doc = "         + `nullptr == pCountBuffer`"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `(nullptr == phWaitEvents) && (0 < numWaitEvents)`"]
    pub fn zeCommandListAppendLaunchMultipleKernelsIndirect(
        hCommandList: ze_command_list_handle_t,
        numKernels: u32,
        phKernels: *mut ze_kernel_handle_t,
        pCountBuffer: *const u32,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
impl _ze_module_program_exp_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_MODULE_PROGRAM_EXP_VERSION_1_0: _ze_module_program_exp_version_t =
        _ze_module_program_exp_version_t(65536);
}
impl _ze_module_program_exp_version_t {
    #[doc = "< latest known version"]
    pub const ZE_MODULE_PROGRAM_EXP_VERSION_CURRENT: _ze_module_program_exp_version_t =
        _ze_module_program_exp_version_t(65536);
}
impl _ze_module_program_exp_version_t {
    pub const ZE_MODULE_PROGRAM_EXP_VERSION_FORCE_UINT32: _ze_module_program_exp_version_t =
        _ze_module_program_exp_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Module Program Extension Version(s)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_module_program_exp_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Module Program Extension Version(s)"]
pub use self::_ze_module_program_exp_version_t as ze_module_program_exp_version_t;
#[doc = ""]
#[doc = " @brief Module extended descriptor to support multiple input modules."]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Implementation must support ::ZE_experimental_module_program extension"]
#[doc = "     - pInputModules, pBuildFlags, and pConstants from ::ze_module_desc_t is"]
#[doc = "       ignored."]
#[doc = "     - Format in ::ze_module_desc_t needs to be set to"]
#[doc = "       ::ZE_MODULE_FORMAT_IL_SPIRV."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_program_exp_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] Count of input modules"]
    pub count: u32,
    #[doc = "< [in][range(0, count)] sizes of each input IL module in pInputModules."]
    pub inputSizes: *const usize,
    #[doc = "< [in][range(0, count)] pointer to an array of IL (e.g. SPIR-V modules)."]
    #[doc = "< Valid only for SPIR-V input."]
    pub pInputModules: *mut *const u8,
    #[doc = "< [in][optional][range(0, count)] array of strings containing build"]
    #[doc = "< flags. See pBuildFlags in ::ze_module_desc_t."]
    pub pBuildFlags: *mut *const ::std::os::raw::c_char,
    #[doc = "< [in][optional][range(0, count)] pointer to array of specialization"]
    #[doc = "< constant strings. Valid only for SPIR-V input. This must be set to"]
    #[doc = "< nullptr if no specialization constants are provided."]
    pub pConstants: *mut *const ze_module_constants_t,
}
#[test]
fn bindgen_test_layout__ze_module_program_exp_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_program_exp_desc_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_module_program_exp_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_program_exp_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_program_exp_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).inputSizes as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(inputSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).pInputModules as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(pInputModules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).pBuildFlags as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(pBuildFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_program_exp_desc_t>())).pConstants as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_program_exp_desc_t),
            "::",
            stringify!(pConstants)
        )
    );
}
impl _ze_raytracing_ext_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_RAYTRACING_EXT_VERSION_1_0: _ze_raytracing_ext_version_t =
        _ze_raytracing_ext_version_t(65536);
}
impl _ze_raytracing_ext_version_t {
    #[doc = "< latest known version"]
    pub const ZE_RAYTRACING_EXT_VERSION_CURRENT: _ze_raytracing_ext_version_t =
        _ze_raytracing_ext_version_t(65536);
}
impl _ze_raytracing_ext_version_t {
    pub const ZE_RAYTRACING_EXT_VERSION_FORCE_UINT32: _ze_raytracing_ext_version_t =
        _ze_raytracing_ext_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Raytracing Extension Version(s)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_raytracing_ext_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Raytracing Extension Version(s)"]
pub use self::_ze_raytracing_ext_version_t as ze_raytracing_ext_version_t;
impl _ze_device_raytracing_ext_flags_t {
    #[doc = "< Supports rayquery"]
    pub const ZE_DEVICE_RAYTRACING_EXT_FLAG_RAYQUERY: _ze_device_raytracing_ext_flags_t =
        _ze_device_raytracing_ext_flags_t(1);
}
impl _ze_device_raytracing_ext_flags_t {
    pub const ZE_DEVICE_RAYTRACING_EXT_FLAG_FORCE_UINT32: _ze_device_raytracing_ext_flags_t =
        _ze_device_raytracing_ext_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_raytracing_ext_flags_t> for _ze_device_raytracing_ext_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_raytracing_ext_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_raytracing_ext_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_raytracing_ext_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_raytracing_ext_flags_t> for _ze_device_raytracing_ext_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_raytracing_ext_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_raytracing_ext_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_raytracing_ext_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported raytracing capability flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_raytracing_ext_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported raytracing capability flags"]
pub use self::_ze_device_raytracing_ext_flags_t as ze_device_raytracing_ext_flags_t;
#[doc = ""]
#[doc = " @brief Raytracing properties queried using ::zeDeviceGetModuleProperties"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be returned from ::zeDeviceGetModuleProperties, via"]
#[doc = "       `pNext` member of ::ze_device_module_properties_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_raytracing_ext_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] 0 or a valid combination of ::ze_device_raytracing_ext_flags_t"]
    pub flags: ze_device_raytracing_ext_flags_t,
    #[doc = "< [out] Maximum number of BVH levels supported"]
    pub maxBVHLevels: u32,
}
#[test]
fn bindgen_test_layout__ze_device_raytracing_ext_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_raytracing_ext_properties_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_raytracing_ext_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_raytracing_ext_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_raytracing_ext_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_raytracing_ext_properties_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_raytracing_ext_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_raytracing_ext_properties_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_raytracing_ext_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_raytracing_ext_properties_t>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_raytracing_ext_properties_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_raytracing_ext_properties_t>())).maxBVHLevels
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_raytracing_ext_properties_t),
            "::",
            stringify!(maxBVHLevels)
        )
    );
}
impl Default for _ze_device_raytracing_ext_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl _ze_raytracing_mem_alloc_ext_flags_t {
    #[doc = "< reserved for future use"]
    pub const ZE_RAYTRACING_MEM_ALLOC_EXT_FLAG_TBD: _ze_raytracing_mem_alloc_ext_flags_t =
        _ze_raytracing_mem_alloc_ext_flags_t(1);
}
impl _ze_raytracing_mem_alloc_ext_flags_t {
    pub const ZE_RAYTRACING_MEM_ALLOC_EXT_FLAG_FORCE_UINT32: _ze_raytracing_mem_alloc_ext_flags_t =
        _ze_raytracing_mem_alloc_ext_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_raytracing_mem_alloc_ext_flags_t>
    for _ze_raytracing_mem_alloc_ext_flags_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_raytracing_mem_alloc_ext_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_raytracing_mem_alloc_ext_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_raytracing_mem_alloc_ext_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_raytracing_mem_alloc_ext_flags_t>
    for _ze_raytracing_mem_alloc_ext_flags_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_raytracing_mem_alloc_ext_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_raytracing_mem_alloc_ext_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_raytracing_mem_alloc_ext_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported raytracing memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_raytracing_mem_alloc_ext_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported raytracing memory allocation flags"]
pub use self::_ze_raytracing_mem_alloc_ext_flags_t as ze_raytracing_mem_alloc_ext_flags_t;
#[doc = ""]
#[doc = " @brief Raytracing memory allocation descriptor"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure must be passed to ::zeMemAllocShared or"]
#[doc = "       ::zeMemAllocDevice, via `pNext` member of"]
#[doc = "       ::ze_device_mem_alloc_desc_t, for any memory allocation that is to be"]
#[doc = "       accessed by raytracing fixed-function of the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_raytracing_mem_alloc_ext_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying additional allocation controls."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_raytracing_mem_alloc_ext_flags_t;"]
    #[doc = "< default behavior may use implicit driver-based heuristics."]
    pub flags: ze_raytracing_mem_alloc_ext_flags_t,
}
#[test]
fn bindgen_test_layout__ze_raytracing_mem_alloc_ext_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_raytracing_mem_alloc_ext_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_raytracing_mem_alloc_ext_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_raytracing_mem_alloc_ext_desc_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_raytracing_mem_alloc_ext_desc_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_raytracing_mem_alloc_ext_desc_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_raytracing_mem_alloc_ext_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_raytracing_mem_alloc_ext_desc_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_raytracing_mem_alloc_ext_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_raytracing_mem_alloc_ext_desc_t>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_raytracing_mem_alloc_ext_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes memory resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the memory is resident before being"]
    #[doc = "       referenced by the device"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextMakeMemoryResident(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows memory to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the memory before it is evicted"]
    #[doc = "     - The application may free the memory without evicting; the memory is"]
    #[doc = "       implicitly evicted when freed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextEvictMemory(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes image resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the image is resident before being"]
    #[doc = "       referenced by the device"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextMakeImageResident(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows image to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the image before it is evicted"]
    #[doc = "     - The application may destroy the image without evicting; the image is"]
    #[doc = "       implicitly evicted when destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeContextEvictImage(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
impl _ze_sampler_address_mode_t {
    #[doc = "< No coordinate modifications for out-of-bounds image access."]
    pub const ZE_SAMPLER_ADDRESS_MODE_NONE: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(0);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    pub const ZE_SAMPLER_ADDRESS_MODE_REPEAT: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(1);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are clamped to edge."]
    pub const ZE_SAMPLER_ADDRESS_MODE_CLAMP: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(2);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are clamped to border color which is (0.0f,"]
    #[doc = "< 0.0f, 0.0f, 0.0f) if image format swizzle contains alpha, otherwise"]
    #[doc = "< (0.0f, 0.0f, 0.0f, 1.0f)."]
    pub const ZE_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(3);
}
impl _ze_sampler_address_mode_t {
    #[doc = "< Out-of-bounds coordinates are mirrored starting from edge."]
    pub const ZE_SAMPLER_ADDRESS_MODE_MIRROR: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(4);
}
impl _ze_sampler_address_mode_t {
    pub const ZE_SAMPLER_ADDRESS_MODE_FORCE_UINT32: _ze_sampler_address_mode_t =
        _ze_sampler_address_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_sampler_address_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
pub use self::_ze_sampler_address_mode_t as ze_sampler_address_mode_t;
impl _ze_sampler_filter_mode_t {
    #[doc = "< No coordinate modifications for out of bounds image access."]
    pub const ZE_SAMPLER_FILTER_MODE_NEAREST: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(0);
}
impl _ze_sampler_filter_mode_t {
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    pub const ZE_SAMPLER_FILTER_MODE_LINEAR: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(1);
}
impl _ze_sampler_filter_mode_t {
    pub const ZE_SAMPLER_FILTER_MODE_FORCE_UINT32: _ze_sampler_filter_mode_t =
        _ze_sampler_filter_mode_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_sampler_filter_mode_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
pub use self::_ze_sampler_filter_mode_t as ze_sampler_filter_mode_t;
#[doc = ""]
#[doc = " @brief Sampler descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] Sampler addressing mode to determine how out-of-bounds"]
    #[doc = "< coordinates are handled."]
    pub addressMode: ze_sampler_address_mode_t,
    #[doc = "< [in] Sampler filter mode to determine how samples are filtered."]
    pub filterMode: ze_sampler_filter_mode_t,
    #[doc = "< [in] Are coordinates normalized [0, 1] or not."]
    pub isNormalized: ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).addressMode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).filterMode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).isNormalized as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(isNormalized)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates sampler on the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the sampler for the device, or its"]
    #[doc = "       sub-devices, which was provided during creation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_SAMPLER_ADDRESS_MODE_MIRROR < desc->addressMode`"]
    #[doc = "         + `::ZE_SAMPLER_FILTER_MODE_LINEAR < desc->filterMode`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeSamplerCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *const ze_sampler_desc_t,
        phSampler: *mut ze_sampler_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys sampler object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the sampler before it is deleted."]
    #[doc = "     - The implementation of this function may immediately free all Host and"]
    #[doc = "       Device allocations associated with this sampler."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same sampler handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeSamplerDestroy(hSampler: ze_sampler_handle_t) -> ze_result_t;
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page is inaccessible."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_NONE: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(0);
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page supports read write access."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_READWRITE: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(1);
}
impl _ze_memory_access_attribute_t {
    #[doc = "< Indicates the memory page supports read-only access."]
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(2);
}
impl _ze_memory_access_attribute_t {
    pub const ZE_MEMORY_ACCESS_ATTRIBUTE_FORCE_UINT32: _ze_memory_access_attribute_t =
        _ze_memory_access_attribute_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Virtual memory page access attributes"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_memory_access_attribute_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Virtual memory page access attributes"]
pub use self::_ze_memory_access_attribute_t as ze_memory_access_attribute_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reserves pages in virtual address space."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the memory allocation on the context for"]
    #[doc = "       which it was created."]
    #[doc = "     - The starting address and size must be page aligned. See"]
    #[doc = "       ::zeVirtualMemQueryPageSize."]
    #[doc = "     - If pStart is not null then implementation will attempt to reserve"]
    #[doc = "       starting from that address. If not available then will find another"]
    #[doc = "       suitable starting address."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The access attributes will default to none to indicate reservation is"]
    #[doc = "       inaccessible."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pStart`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeVirtualMemReserve(
        hContext: ze_context_handle_t,
        pStart: *const ::std::os::raw::c_void,
        size: usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Free pages in a reserved virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Any existing virtual mappings for the range will be unmapped."]
    #[doc = "     - Physical allocations objects that were mapped to this range will not"]
    #[doc = "       be destroyed. These need to be destroyed explicitly."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zeVirtualMemFree(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries page size to use for aligning virtual memory reservations and"]
    #[doc = "        physical memory allocations."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pagesize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    pub fn zeVirtualMemQueryPageSize(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        size: usize,
        pagesize: *mut usize,
    ) -> ze_result_t;
}
impl _ze_physical_mem_flags_t {
    #[doc = "< reserved for future use."]
    pub const ZE_PHYSICAL_MEM_FLAG_TBD: _ze_physical_mem_flags_t = _ze_physical_mem_flags_t(1);
}
impl _ze_physical_mem_flags_t {
    pub const ZE_PHYSICAL_MEM_FLAG_FORCE_UINT32: _ze_physical_mem_flags_t =
        _ze_physical_mem_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_physical_mem_flags_t> for _ze_physical_mem_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_physical_mem_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_physical_mem_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_physical_mem_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_physical_mem_flags_t> for _ze_physical_mem_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_physical_mem_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_physical_mem_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_physical_mem_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported physical memory creation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_physical_mem_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported physical memory creation flags"]
pub use self::_ze_physical_mem_flags_t as ze_physical_mem_flags_t;
#[doc = ""]
#[doc = " @brief Physical memory descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] creation flags."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_physical_mem_flags_t."]
    pub flags: ze_physical_mem_flags_t,
    #[doc = "< [in] size in bytes to reserve; must be page aligned."]
    pub size: usize,
}
#[test]
fn bindgen_test_layout__ze_physical_mem_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_physical_mem_desc_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_physical_mem_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_physical_mem_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_physical_mem_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).stype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).pNext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_physical_mem_desc_t>())).size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_desc_t),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a physical memory object for the context."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must only use the physical memory object on the"]
    #[doc = "       context for which it was created."]
    #[doc = "     - The size must be page aligned. See ::zeVirtualMemQueryPageSize."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `0x1 < desc->flags`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == desc->size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zePhysicalMemCreate(
        hContext: ze_context_handle_t,
        hDevice: ze_device_handle_t,
        desc: *mut ze_physical_mem_desc_t,
        phPhysicalMemory: *mut ze_physical_mem_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a physical memory object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application must ensure the device is not currently referencing"]
    #[doc = "       the physical memory object before it is deleted"]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same physical memory handle."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zePhysicalMemDestroy(
        hContext: ze_context_handle_t,
        hPhysicalMemory: ze_physical_mem_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Maps pages in virtual address space to pages from physical memory"]
    #[doc = "        object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The virtual address range must have been reserved using"]
    #[doc = "       ::zeVirtualMemReserve."]
    #[doc = "     - The application must only use the mapped memory allocation on the"]
    #[doc = "       context for which it was created."]
    #[doc = "     - The virtual start address and size must be page aligned. See"]
    #[doc = "       ::zeVirtualMemQueryPageSize."]
    #[doc = "     - The application should use, for the starting address and size, the"]
    #[doc = "       same size alignment used for the physical allocation."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "         + `nullptr == hPhysicalMemory`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    pub fn zeVirtualMemMap(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        hPhysicalMemory: ze_physical_mem_handle_t,
        offset: usize,
        access: ze_memory_access_attribute_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Unmaps pages in virtual address space from pages from a physical"]
    #[doc = "        memory object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The page access attributes for virtual address range will revert back"]
    #[doc = "       to none."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function must be thread-safe."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemUnmap(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set memory access attributes for a virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + `::ZE_MEMORY_ACCESS_ATTRIBUTE_READONLY < access`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemSetAccessAttribute(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        access: ze_memory_access_attribute_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Get memory access attribute for a virtual address range."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If size and outSize are equal then the pages in the specified virtual"]
    #[doc = "       address range have the same access attributes."]
    #[doc = "     - This function may be called from simultaneous threads with the same"]
    #[doc = "       function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hContext`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == access`"]
    #[doc = "         + `nullptr == outSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT - \"Address must be page aligned\""]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "         + `0 == size`"]
    #[doc = "         + Size must be page aligned"]
    pub fn zeVirtualMemGetAccessAttribute(
        hContext: ze_context_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        access: *mut ze_memory_access_attribute_t,
        outSize: *mut usize,
    ) -> ze_result_t;
}
impl _ze_float_atomics_ext_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_FLOAT_ATOMICS_EXT_VERSION_1_0: _ze_float_atomics_ext_version_t =
        _ze_float_atomics_ext_version_t(65536);
}
impl _ze_float_atomics_ext_version_t {
    #[doc = "< latest known version"]
    pub const ZE_FLOAT_ATOMICS_EXT_VERSION_CURRENT: _ze_float_atomics_ext_version_t =
        _ze_float_atomics_ext_version_t(65536);
}
impl _ze_float_atomics_ext_version_t {
    pub const ZE_FLOAT_ATOMICS_EXT_VERSION_FORCE_UINT32: _ze_float_atomics_ext_version_t =
        _ze_float_atomics_ext_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Floating-Point Atomics Extension Version(s)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_float_atomics_ext_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Floating-Point Atomics Extension Version(s)"]
pub use self::_ze_float_atomics_ext_version_t as ze_float_atomics_ext_version_t;
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic load, store, and exchange"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_LOAD_STORE: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(1);
}
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic add and subtract"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_ADD: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(2);
}
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic min and max"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_GLOBAL_MIN_MAX: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(4);
}
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic load, store, and exchange"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_LOAD_STORE: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(65536);
}
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic add and subtract"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_ADD: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(131072);
}
impl _ze_device_fp_atomic_ext_flags_t {
    #[doc = "< Supports atomic min and max"]
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_LOCAL_MIN_MAX: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(262144);
}
impl _ze_device_fp_atomic_ext_flags_t {
    pub const ZE_DEVICE_FP_ATOMIC_EXT_FLAG_FORCE_UINT32: _ze_device_fp_atomic_ext_flags_t =
        _ze_device_fp_atomic_ext_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_device_fp_atomic_ext_flags_t> for _ze_device_fp_atomic_ext_flags_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_device_fp_atomic_ext_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_device_fp_atomic_ext_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_device_fp_atomic_ext_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_device_fp_atomic_ext_flags_t> for _ze_device_fp_atomic_ext_flags_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_device_fp_atomic_ext_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_device_fp_atomic_ext_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_device_fp_atomic_ext_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported floating-point atomic capability flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_device_fp_atomic_ext_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported floating-point atomic capability flags"]
pub use self::_ze_device_fp_atomic_ext_flags_t as ze_device_fp_atomic_ext_flags_t;
#[doc = ""]
#[doc = " @brief Device floating-point atomic properties queried using"]
#[doc = "        ::zeDeviceGetModuleProperties"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be returned from ::zeDeviceGetModuleProperties, via"]
#[doc = "       `pNext` member of ::ze_device_module_properties_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_float_atomic_ext_properties_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in,out][optional] pointer to extension-specific structure"]
    pub pNext: *mut ::std::os::raw::c_void,
    #[doc = "< [out] Capabilities for half-precision floating-point atomic operations"]
    pub fp16Flags: ze_device_fp_atomic_ext_flags_t,
    #[doc = "< [out] Capabilities for single-precision floating-point atomic"]
    #[doc = "< operations"]
    pub fp32Flags: ze_device_fp_atomic_ext_flags_t,
    #[doc = "< [out] Capabilities for double-precision floating-point atomic"]
    #[doc = "< operations"]
    pub fp64Flags: ze_device_fp_atomic_ext_flags_t,
}
#[test]
fn bindgen_test_layout__ze_float_atomic_ext_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_float_atomic_ext_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_float_atomic_ext_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_float_atomic_ext_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_float_atomic_ext_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_float_atomic_ext_properties_t>())).stype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_float_atomic_ext_properties_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_float_atomic_ext_properties_t>())).pNext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_float_atomic_ext_properties_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_float_atomic_ext_properties_t>())).fp16Flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_float_atomic_ext_properties_t),
            "::",
            stringify!(fp16Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_float_atomic_ext_properties_t>())).fp32Flags as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_float_atomic_ext_properties_t),
            "::",
            stringify!(fp32Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_float_atomic_ext_properties_t>())).fp64Flags as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_float_atomic_ext_properties_t),
            "::",
            stringify!(fp64Flags)
        )
    );
}
impl Default for _ze_float_atomic_ext_properties_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl _ze_global_offset_exp_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_GLOBAL_OFFSET_EXP_VERSION_1_0: _ze_global_offset_exp_version_t =
        _ze_global_offset_exp_version_t(65536);
}
impl _ze_global_offset_exp_version_t {
    #[doc = "< latest known version"]
    pub const ZE_GLOBAL_OFFSET_EXP_VERSION_CURRENT: _ze_global_offset_exp_version_t =
        _ze_global_offset_exp_version_t(65536);
}
impl _ze_global_offset_exp_version_t {
    pub const ZE_GLOBAL_OFFSET_EXP_VERSION_FORCE_UINT32: _ze_global_offset_exp_version_t =
        _ze_global_offset_exp_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Global Offset Extension Version(s)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_global_offset_exp_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Global Offset Extension Version(s)"]
pub use self::_ze_global_offset_exp_version_t as ze_global_offset_exp_version_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set global work offset for a kernel on the current Host thread."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The global work offset will be used when"]
    #[doc = "       a::zeCommandListAppendLaunchKernel()variant is called."]
    #[doc = "     - The application must **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    pub fn zeKernelSetGlobalOffsetExp(
        hKernel: ze_kernel_handle_t,
        offsetX: u32,
        offsetY: u32,
        offsetZ: u32,
    ) -> ze_result_t;
}
impl _ze_relaxed_allocation_limits_exp_version_t {
    #[doc = "< version 1.0"]
    pub const ZE_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_1_0:
        _ze_relaxed_allocation_limits_exp_version_t =
        _ze_relaxed_allocation_limits_exp_version_t(65536);
}
impl _ze_relaxed_allocation_limits_exp_version_t {
    #[doc = "< latest known version"]
    pub const ZE_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_CURRENT:
        _ze_relaxed_allocation_limits_exp_version_t =
        _ze_relaxed_allocation_limits_exp_version_t(65536);
}
impl _ze_relaxed_allocation_limits_exp_version_t {
    pub const ZE_RELAXED_ALLOCATION_LIMITS_EXP_VERSION_FORCE_UINT32:
        _ze_relaxed_allocation_limits_exp_version_t =
        _ze_relaxed_allocation_limits_exp_version_t(2147483647);
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Relaxed Allocation Limits Extension Version(s)"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_relaxed_allocation_limits_exp_version_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Relaxed Allocation Limits Extension Version(s)"]
pub use self::_ze_relaxed_allocation_limits_exp_version_t as ze_relaxed_allocation_limits_exp_version_t;
impl _ze_relaxed_allocation_limits_exp_flags_t {
    #[doc = "< Allocation size may exceed ::ze_device_properties_t.maxMemAllocSize"]
    pub const ZE_RELAXED_ALLOCATION_LIMITS_EXP_FLAG_MAX_SIZE:
        _ze_relaxed_allocation_limits_exp_flags_t = _ze_relaxed_allocation_limits_exp_flags_t(1);
}
impl _ze_relaxed_allocation_limits_exp_flags_t {
    pub const ZE_RELAXED_ALLOCATION_LIMITS_EXP_FLAG_FORCE_UINT32:
        _ze_relaxed_allocation_limits_exp_flags_t =
        _ze_relaxed_allocation_limits_exp_flags_t(2147483647);
}
impl ::std::ops::BitOr<_ze_relaxed_allocation_limits_exp_flags_t>
    for _ze_relaxed_allocation_limits_exp_flags_t
{
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        _ze_relaxed_allocation_limits_exp_flags_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for _ze_relaxed_allocation_limits_exp_flags_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: _ze_relaxed_allocation_limits_exp_flags_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<_ze_relaxed_allocation_limits_exp_flags_t>
    for _ze_relaxed_allocation_limits_exp_flags_t
{
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        _ze_relaxed_allocation_limits_exp_flags_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for _ze_relaxed_allocation_limits_exp_flags_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: _ze_relaxed_allocation_limits_exp_flags_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " @brief Supported relaxed memory allocation flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct _ze_relaxed_allocation_limits_exp_flags_t(pub ::std::os::raw::c_uint);
#[doc = ""]
#[doc = " @brief Supported relaxed memory allocation flags"]
pub use self::_ze_relaxed_allocation_limits_exp_flags_t as ze_relaxed_allocation_limits_exp_flags_t;
#[doc = ""]
#[doc = " @brief Relaxed limits memory allocation descriptor"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - This structure may be passed to ::zeMemAllocShared or"]
#[doc = "       ::zeMemAllocDevice, via `pNext` member of"]
#[doc = "       ::ze_device_mem_alloc_desc_t."]
#[doc = "     - This structure may also be passed to ::zeMemAllocHost, via `pNext`"]
#[doc = "       member of ::ze_host_mem_alloc_desc_t."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_relaxed_allocation_limits_exp_desc_t {
    #[doc = "< [in] type of this structure"]
    pub stype: ze_structure_type_t,
    #[doc = "< [in][optional] pointer to extension-specific structure"]
    pub pNext: *const ::std::os::raw::c_void,
    #[doc = "< [in] flags specifying allocation limits to relax."]
    #[doc = "< must be 0 (default) or a valid combination of ::ze_relaxed_allocation_limits_exp_flags_t;"]
    pub flags: ze_relaxed_allocation_limits_exp_flags_t,
}
#[test]
fn bindgen_test_layout__ze_relaxed_allocation_limits_exp_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_relaxed_allocation_limits_exp_desc_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_relaxed_allocation_limits_exp_desc_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_relaxed_allocation_limits_exp_desc_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_relaxed_allocation_limits_exp_desc_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_relaxed_allocation_limits_exp_desc_t>())).stype as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_relaxed_allocation_limits_exp_desc_t),
            "::",
            stringify!(stype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_relaxed_allocation_limits_exp_desc_t>())).pNext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_relaxed_allocation_limits_exp_desc_t),
            "::",
            stringify!(pNext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_relaxed_allocation_limits_exp_desc_t>())).flags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_relaxed_allocation_limits_exp_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeInit"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_init_params_t {
    pub pflags: *mut ze_init_flags_t,
}
#[test]
fn bindgen_test_layout__ze_init_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_init_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_init_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_init_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_init_params_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_init_params_t>())).pflags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_init_params_t),
            "::",
            stringify!(pflags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeInit"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_init_params_t = _ze_init_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeInit"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnInitCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_init_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Global callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_global_callbacks_t {
    pub pfnInitCb: ze_pfnInitCb_t,
}
#[test]
fn bindgen_test_layout__ze_global_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_global_callbacks_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_global_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_global_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_global_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_global_callbacks_t>())).pfnInitCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_global_callbacks_t),
            "::",
            stringify!(pfnInitCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Global callback functions pointers"]
pub type ze_global_callbacks_t = _ze_global_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGet"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_get_params_t {
    pub ppCount: *mut *mut u32,
    pub pphDrivers: *mut *mut ze_driver_handle_t,
}
#[test]
fn bindgen_test_layout__ze_driver_get_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_get_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_get_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_get_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_get_params_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_get_params_t>())).ppCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_params_t>())).pphDrivers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_params_t),
            "::",
            stringify!(pphDrivers)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGet"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_driver_get_params_t = _ze_driver_get_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDriverGet"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDriverGetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_driver_get_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetApiVersion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_get_api_version_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub pversion: *mut *mut ze_api_version_t,
}
#[test]
fn bindgen_test_layout__ze_driver_get_api_version_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_get_api_version_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_get_api_version_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_get_api_version_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_get_api_version_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_api_version_params_t>())).phDriver as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_api_version_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_api_version_params_t>())).pversion as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_api_version_params_t),
            "::",
            stringify!(pversion)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetApiVersion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_driver_get_api_version_params_t = _ze_driver_get_api_version_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDriverGetApiVersion"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDriverGetApiVersionCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_driver_get_api_version_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_get_properties_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub ppDriverProperties: *mut *mut ze_driver_properties_t,
}
#[test]
fn bindgen_test_layout__ze_driver_get_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_get_properties_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_get_properties_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_get_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_get_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_properties_params_t>())).phDriver as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_properties_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_properties_params_t>())).ppDriverProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_properties_params_t),
            "::",
            stringify!(ppDriverProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_driver_get_properties_params_t = _ze_driver_get_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDriverGetProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDriverGetPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_driver_get_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetIpcProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_get_ipc_properties_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub ppIpcProperties: *mut *mut ze_driver_ipc_properties_t,
}
#[test]
fn bindgen_test_layout__ze_driver_get_ipc_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_get_ipc_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_driver_get_ipc_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_get_ipc_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_get_ipc_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_ipc_properties_params_t>())).phDriver as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_ipc_properties_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_ipc_properties_params_t>())).ppIpcProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_ipc_properties_params_t),
            "::",
            stringify!(ppIpcProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetIpcProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_driver_get_ipc_properties_params_t = _ze_driver_get_ipc_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDriverGetIpcProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDriverGetIpcPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_driver_get_ipc_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetExtensionProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_get_extension_properties_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub ppCount: *mut *mut u32,
    pub ppExtensionProperties: *mut *mut ze_driver_extension_properties_t,
}
#[test]
fn bindgen_test_layout__ze_driver_get_extension_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_get_extension_properties_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_driver_get_extension_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_get_extension_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_driver_get_extension_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_extension_properties_params_t>())).phDriver
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_extension_properties_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_extension_properties_params_t>())).ppCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_extension_properties_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_get_extension_properties_params_t>()))
                .ppExtensionProperties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_get_extension_properties_params_t),
            "::",
            stringify!(ppExtensionProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDriverGetExtensionProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_driver_get_extension_properties_params_t = _ze_driver_get_extension_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDriverGetExtensionProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDriverGetExtensionPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_driver_get_extension_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Driver callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_driver_callbacks_t {
    pub pfnGetCb: ze_pfnDriverGetCb_t,
    pub pfnGetApiVersionCb: ze_pfnDriverGetApiVersionCb_t,
    pub pfnGetPropertiesCb: ze_pfnDriverGetPropertiesCb_t,
    pub pfnGetIpcPropertiesCb: ze_pfnDriverGetIpcPropertiesCb_t,
    pub pfnGetExtensionPropertiesCb: ze_pfnDriverGetExtensionPropertiesCb_t,
}
#[test]
fn bindgen_test_layout__ze_driver_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_callbacks_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_driver_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_driver_callbacks_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_callbacks_t>())).pfnGetCb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_callbacks_t),
            "::",
            stringify!(pfnGetCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_callbacks_t>())).pfnGetApiVersionCb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_callbacks_t),
            "::",
            stringify!(pfnGetApiVersionCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_callbacks_t>())).pfnGetPropertiesCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_callbacks_t),
            "::",
            stringify!(pfnGetPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_callbacks_t>())).pfnGetIpcPropertiesCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_callbacks_t),
            "::",
            stringify!(pfnGetIpcPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_callbacks_t>())).pfnGetExtensionPropertiesCb
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_callbacks_t),
            "::",
            stringify!(pfnGetExtensionPropertiesCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Driver callback functions pointers"]
pub type ze_driver_callbacks_t = _ze_driver_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGet"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub ppCount: *mut *mut u32,
    pub pphDevices: *mut *mut ze_device_handle_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_get_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_get_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_params_t>())).phDriver as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_get_params_t>())).ppCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_params_t>())).pphDevices as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_params_t),
            "::",
            stringify!(pphDevices)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGet"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_params_t = _ze_device_get_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGet"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetSubDevices"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_sub_devices_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppCount: *mut *mut u32,
    pub pphSubdevices: *mut *mut ze_device_handle_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_sub_devices_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_sub_devices_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_get_sub_devices_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_sub_devices_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_sub_devices_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_sub_devices_params_t>())).phDevice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_sub_devices_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_sub_devices_params_t>())).ppCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_sub_devices_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_sub_devices_params_t>())).pphSubdevices
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_sub_devices_params_t),
            "::",
            stringify!(pphSubdevices)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetSubDevices"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_sub_devices_params_t = _ze_device_get_sub_devices_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetSubDevices"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetSubDevicesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_sub_devices_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppDeviceProperties: *mut *mut ze_device_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_properties_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_device_get_properties_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_properties_params_t>())).phDevice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_properties_params_t>())).ppDeviceProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_properties_params_t),
            "::",
            stringify!(ppDeviceProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_properties_params_t = _ze_device_get_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetComputeProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_compute_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppComputeProperties: *mut *mut ze_device_compute_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_compute_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_compute_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_compute_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_compute_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_compute_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_compute_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_compute_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_compute_properties_params_t>()))
                .ppComputeProperties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_compute_properties_params_t),
            "::",
            stringify!(ppComputeProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetComputeProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_compute_properties_params_t = _ze_device_get_compute_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetComputeProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetComputePropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_compute_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetModuleProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_module_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppModuleProperties: *mut *mut ze_device_module_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_module_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_module_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_module_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_module_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_module_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_module_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_module_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_module_properties_params_t>())).ppModuleProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_module_properties_params_t),
            "::",
            stringify!(ppModuleProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetModuleProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_module_properties_params_t = _ze_device_get_module_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetModuleProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetModulePropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_module_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetCommandQueueGroupProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_command_queue_group_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppCount: *mut *mut u32,
    pub ppCommandQueueGroupProperties: *mut *mut ze_command_queue_group_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_command_queue_group_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_command_queue_group_properties_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_command_queue_group_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_command_queue_group_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_command_queue_group_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_command_queue_group_properties_params_t>()))
                .phDevice as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_command_queue_group_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_command_queue_group_properties_params_t>()))
                .ppCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_command_queue_group_properties_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_command_queue_group_properties_params_t>()))
                .ppCommandQueueGroupProperties as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_command_queue_group_properties_params_t),
            "::",
            stringify!(ppCommandQueueGroupProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetCommandQueueGroupProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_command_queue_group_properties_params_t =
    _ze_device_get_command_queue_group_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetCommandQueueGroupProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetCommandQueueGroupPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_command_queue_group_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetMemoryProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_memory_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppCount: *mut *mut u32,
    pub ppMemProperties: *mut *mut ze_device_memory_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_memory_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_memory_properties_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_memory_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_memory_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_memory_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_memory_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_memory_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_memory_properties_params_t>())).ppCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_memory_properties_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_memory_properties_params_t>())).ppMemProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_memory_properties_params_t),
            "::",
            stringify!(ppMemProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetMemoryProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_memory_properties_params_t = _ze_device_get_memory_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetMemoryProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetMemoryPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_memory_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetMemoryAccessProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_memory_access_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppMemAccessProperties: *mut *mut ze_device_memory_access_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_memory_access_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_memory_access_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_memory_access_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_memory_access_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_memory_access_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_memory_access_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_memory_access_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_memory_access_properties_params_t>()))
                .ppMemAccessProperties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_memory_access_properties_params_t),
            "::",
            stringify!(ppMemAccessProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetMemoryAccessProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_memory_access_properties_params_t =
    _ze_device_get_memory_access_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetMemoryAccessProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetMemoryAccessPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_memory_access_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetCacheProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_cache_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppCount: *mut *mut u32,
    pub ppCacheProperties: *mut *mut ze_device_cache_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_cache_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_cache_properties_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_cache_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_cache_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_cache_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_cache_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_cache_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_cache_properties_params_t>())).ppCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_cache_properties_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_cache_properties_params_t>())).ppCacheProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_cache_properties_params_t),
            "::",
            stringify!(ppCacheProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetCacheProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_cache_properties_params_t = _ze_device_get_cache_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetCacheProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetCachePropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_cache_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetImageProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_image_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppImageProperties: *mut *mut ze_device_image_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_image_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_image_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_image_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_image_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_image_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_image_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_image_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_image_properties_params_t>())).ppImageProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_image_properties_params_t),
            "::",
            stringify!(ppImageProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetImageProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_image_properties_params_t = _ze_device_get_image_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetImageProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetImagePropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_image_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetExternalMemoryProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_external_memory_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub ppExternalMemoryProperties: *mut *mut ze_device_external_memory_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_external_memory_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_external_memory_properties_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_external_memory_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_external_memory_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_external_memory_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_external_memory_properties_params_t>())).phDevice
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_external_memory_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_external_memory_properties_params_t>()))
                .ppExternalMemoryProperties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_external_memory_properties_params_t),
            "::",
            stringify!(ppExternalMemoryProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetExternalMemoryProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_external_memory_properties_params_t =
    _ze_device_get_external_memory_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetExternalMemoryProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetExternalMemoryPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_external_memory_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetP2PProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_p2_p_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub phPeerDevice: *mut ze_device_handle_t,
    pub ppP2PProperties: *mut *mut ze_device_p2p_properties_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_p2_p_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_p2_p_properties_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_get_p2_p_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_p2_p_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_get_p2_p_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_p2_p_properties_params_t>())).phDevice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_p2_p_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_p2_p_properties_params_t>())).phPeerDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_p2_p_properties_params_t),
            "::",
            stringify!(phPeerDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_p2_p_properties_params_t>())).ppP2PProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_p2_p_properties_params_t),
            "::",
            stringify!(ppP2PProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetP2PProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_p2_p_properties_params_t = _ze_device_get_p2_p_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetP2PProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetP2PPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_p2_p_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceCanAccessPeer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_can_access_peer_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub phPeerDevice: *mut ze_device_handle_t,
    pub pvalue: *mut *mut ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_device_can_access_peer_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_can_access_peer_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_can_access_peer_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_can_access_peer_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_can_access_peer_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_can_access_peer_params_t>())).phDevice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_can_access_peer_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_can_access_peer_params_t>())).phPeerDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_can_access_peer_params_t),
            "::",
            stringify!(phPeerDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_can_access_peer_params_t>())).pvalue as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_can_access_peer_params_t),
            "::",
            stringify!(pvalue)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceCanAccessPeer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_can_access_peer_params_t = _ze_device_can_access_peer_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceCanAccessPeer"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceCanAccessPeerCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_can_access_peer_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_get_status_params_t {
    pub phDevice: *mut ze_device_handle_t,
}
#[test]
fn bindgen_test_layout__ze_device_get_status_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_get_status_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_device_get_status_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_get_status_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_get_status_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_get_status_params_t>())).phDevice as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_get_status_params_t),
            "::",
            stringify!(phDevice)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeDeviceGetStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_device_get_status_params_t = _ze_device_get_status_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeDeviceGetStatus"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnDeviceGetStatusCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_device_get_status_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Device callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_device_callbacks_t {
    pub pfnGetCb: ze_pfnDeviceGetCb_t,
    pub pfnGetSubDevicesCb: ze_pfnDeviceGetSubDevicesCb_t,
    pub pfnGetPropertiesCb: ze_pfnDeviceGetPropertiesCb_t,
    pub pfnGetComputePropertiesCb: ze_pfnDeviceGetComputePropertiesCb_t,
    pub pfnGetModulePropertiesCb: ze_pfnDeviceGetModulePropertiesCb_t,
    pub pfnGetCommandQueueGroupPropertiesCb: ze_pfnDeviceGetCommandQueueGroupPropertiesCb_t,
    pub pfnGetMemoryPropertiesCb: ze_pfnDeviceGetMemoryPropertiesCb_t,
    pub pfnGetMemoryAccessPropertiesCb: ze_pfnDeviceGetMemoryAccessPropertiesCb_t,
    pub pfnGetCachePropertiesCb: ze_pfnDeviceGetCachePropertiesCb_t,
    pub pfnGetImagePropertiesCb: ze_pfnDeviceGetImagePropertiesCb_t,
    pub pfnGetExternalMemoryPropertiesCb: ze_pfnDeviceGetExternalMemoryPropertiesCb_t,
    pub pfnGetP2PPropertiesCb: ze_pfnDeviceGetP2PPropertiesCb_t,
    pub pfnCanAccessPeerCb: ze_pfnDeviceCanAccessPeerCb_t,
    pub pfnGetStatusCb: ze_pfnDeviceGetStatusCb_t,
}
#[test]
fn bindgen_test_layout__ze_device_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_callbacks_t>(),
        112usize,
        concat!("Size of: ", stringify!(_ze_device_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_callbacks_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetCb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetSubDevicesCb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetSubDevicesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetPropertiesCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetComputePropertiesCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetComputePropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetModulePropertiesCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetModulePropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetCommandQueueGroupPropertiesCb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetCommandQueueGroupPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetMemoryPropertiesCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetMemoryPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetMemoryAccessPropertiesCb
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetMemoryAccessPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetCachePropertiesCb as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetCachePropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetImagePropertiesCb as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetImagePropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetExternalMemoryPropertiesCb
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetExternalMemoryPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetP2PPropertiesCb as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetP2PPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnCanAccessPeerCb as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnCanAccessPeerCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_callbacks_t>())).pfnGetStatusCb as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_callbacks_t),
            "::",
            stringify!(pfnGetStatusCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Device callback functions pointers"]
pub type ze_device_callbacks_t = _ze_device_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_create_params_t {
    pub phDriver: *mut ze_driver_handle_t,
    pub pdesc: *mut *const ze_context_desc_t,
    pub pphContext: *mut *mut ze_context_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_create_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_context_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_create_params_t>())).phDriver as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_create_params_t),
            "::",
            stringify!(phDriver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_create_params_t>())).pdesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_create_params_t>())).pphContext as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_create_params_t),
            "::",
            stringify!(pphContext)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_create_params_t = _ze_context_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_destroy_params_t {
    pub phContext: *mut ze_context_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_context_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_destroy_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_destroy_params_t),
            "::",
            stringify!(phContext)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_destroy_params_t = _ze_context_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextGetStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_get_status_params_t {
    pub phContext: *mut ze_context_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_get_status_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_get_status_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_context_get_status_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_get_status_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_get_status_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_get_status_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_get_status_params_t),
            "::",
            stringify!(phContext)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextGetStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_get_status_params_t = _ze_context_get_status_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextGetStatus"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextGetStatusCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_get_status_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextSystemBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_system_barrier_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_system_barrier_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_system_barrier_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_context_system_barrier_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_system_barrier_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_context_system_barrier_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_system_barrier_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_system_barrier_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_system_barrier_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_system_barrier_params_t),
            "::",
            stringify!(phDevice)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextSystemBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_system_barrier_params_t = _ze_context_system_barrier_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextSystemBarrier"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextSystemBarrierCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_system_barrier_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextMakeMemoryResident"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_make_memory_resident_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pptr: *mut *mut ::std::os::raw::c_void,
    pub psize: *mut usize,
}
#[test]
fn bindgen_test_layout__ze_context_make_memory_resident_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_make_memory_resident_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_context_make_memory_resident_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_make_memory_resident_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_context_make_memory_resident_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_memory_resident_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_memory_resident_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_memory_resident_params_t>())).phDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_memory_resident_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_memory_resident_params_t>())).pptr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_memory_resident_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_memory_resident_params_t>())).psize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_memory_resident_params_t),
            "::",
            stringify!(psize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextMakeMemoryResident"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_make_memory_resident_params_t = _ze_context_make_memory_resident_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextMakeMemoryResident"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextMakeMemoryResidentCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_make_memory_resident_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextEvictMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_evict_memory_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pptr: *mut *mut ::std::os::raw::c_void,
    pub psize: *mut usize,
}
#[test]
fn bindgen_test_layout__ze_context_evict_memory_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_evict_memory_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_context_evict_memory_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_evict_memory_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_context_evict_memory_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_memory_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_memory_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_memory_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_memory_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_memory_params_t>())).pptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_memory_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_memory_params_t>())).psize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_memory_params_t),
            "::",
            stringify!(psize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextEvictMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_evict_memory_params_t = _ze_context_evict_memory_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextEvictMemory"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextEvictMemoryCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_evict_memory_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextMakeImageResident"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_make_image_resident_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub phImage: *mut ze_image_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_make_image_resident_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_make_image_resident_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_context_make_image_resident_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_make_image_resident_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_context_make_image_resident_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_image_resident_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_image_resident_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_image_resident_params_t>())).phDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_image_resident_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_make_image_resident_params_t>())).phImage as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_make_image_resident_params_t),
            "::",
            stringify!(phImage)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextMakeImageResident"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_make_image_resident_params_t = _ze_context_make_image_resident_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextMakeImageResident"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextMakeImageResidentCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_make_image_resident_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextEvictImage"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_context_evict_image_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub phImage: *mut ze_image_handle_t,
}
#[test]
fn bindgen_test_layout__ze_context_evict_image_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_evict_image_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_context_evict_image_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_evict_image_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_context_evict_image_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_image_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_image_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_image_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_image_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_evict_image_params_t>())).phImage as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_evict_image_params_t),
            "::",
            stringify!(phImage)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeContextEvictImage"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_context_evict_image_params_t = _ze_context_evict_image_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeContextEvictImage"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnContextEvictImageCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_context_evict_image_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Context callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_context_callbacks_t {
    pub pfnCreateCb: ze_pfnContextCreateCb_t,
    pub pfnDestroyCb: ze_pfnContextDestroyCb_t,
    pub pfnGetStatusCb: ze_pfnContextGetStatusCb_t,
    pub pfnSystemBarrierCb: ze_pfnContextSystemBarrierCb_t,
    pub pfnMakeMemoryResidentCb: ze_pfnContextMakeMemoryResidentCb_t,
    pub pfnEvictMemoryCb: ze_pfnContextEvictMemoryCb_t,
    pub pfnMakeImageResidentCb: ze_pfnContextMakeImageResidentCb_t,
    pub pfnEvictImageCb: ze_pfnContextEvictImageCb_t,
}
#[test]
fn bindgen_test_layout__ze_context_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_context_callbacks_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_context_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_context_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_context_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnGetStatusCb as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnGetStatusCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnSystemBarrierCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnSystemBarrierCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnMakeMemoryResidentCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnMakeMemoryResidentCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnEvictMemoryCb as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnEvictMemoryCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnMakeImageResidentCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnMakeImageResidentCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_context_callbacks_t>())).pfnEvictImageCb as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_context_callbacks_t),
            "::",
            stringify!(pfnEvictImageCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Context callback functions pointers"]
pub type ze_context_callbacks_t = _ze_context_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_command_queue_desc_t,
    pub pphCommandQueue: *mut *mut ze_command_queue_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_create_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_command_queue_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_create_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_create_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_create_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_create_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_create_params_t>())).pdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_create_params_t>())).pphCommandQueue
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_create_params_t),
            "::",
            stringify!(pphCommandQueue)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_queue_create_params_t = _ze_command_queue_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandQueueCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandQueueCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_queue_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_destroy_params_t {
    pub phCommandQueue: *mut ze_command_queue_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_command_queue_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_destroy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_destroy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_destroy_params_t>())).phCommandQueue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_destroy_params_t),
            "::",
            stringify!(phCommandQueue)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_queue_destroy_params_t = _ze_command_queue_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandQueueDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandQueueDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_queue_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueExecuteCommandLists"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_execute_command_lists_params_t {
    pub phCommandQueue: *mut ze_command_queue_handle_t,
    pub pnumCommandLists: *mut u32,
    pub pphCommandLists: *mut *mut ze_command_list_handle_t,
    pub phFence: *mut ze_fence_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_execute_command_lists_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_execute_command_lists_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_queue_execute_command_lists_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_execute_command_lists_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_execute_command_lists_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_execute_command_lists_params_t>()))
                .phCommandQueue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_execute_command_lists_params_t),
            "::",
            stringify!(phCommandQueue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_execute_command_lists_params_t>()))
                .pnumCommandLists as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_execute_command_lists_params_t),
            "::",
            stringify!(pnumCommandLists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_execute_command_lists_params_t>()))
                .pphCommandLists as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_execute_command_lists_params_t),
            "::",
            stringify!(pphCommandLists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_execute_command_lists_params_t>())).phFence
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_execute_command_lists_params_t),
            "::",
            stringify!(phFence)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueExecuteCommandLists"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_queue_execute_command_lists_params_t =
    _ze_command_queue_execute_command_lists_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandQueueExecuteCommandLists"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandQueueExecuteCommandListsCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_queue_execute_command_lists_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_synchronize_params_t {
    pub phCommandQueue: *mut ze_command_queue_handle_t,
    pub ptimeout: *mut u64,
}
#[test]
fn bindgen_test_layout__ze_command_queue_synchronize_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_synchronize_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_queue_synchronize_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_synchronize_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_queue_synchronize_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_synchronize_params_t>())).phCommandQueue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_synchronize_params_t),
            "::",
            stringify!(phCommandQueue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_synchronize_params_t>())).ptimeout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_synchronize_params_t),
            "::",
            stringify!(ptimeout)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandQueueSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_queue_synchronize_params_t = _ze_command_queue_synchronize_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandQueueSynchronize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandQueueSynchronizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_queue_synchronize_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of CommandQueue callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_command_queue_callbacks_t {
    pub pfnCreateCb: ze_pfnCommandQueueCreateCb_t,
    pub pfnDestroyCb: ze_pfnCommandQueueDestroyCb_t,
    pub pfnExecuteCommandListsCb: ze_pfnCommandQueueExecuteCommandListsCb_t,
    pub pfnSynchronizeCb: ze_pfnCommandQueueSynchronizeCb_t,
}
#[test]
fn bindgen_test_layout__ze_command_queue_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_callbacks_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_command_queue_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_queue_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_callbacks_t>())).pfnCreateCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_callbacks_t>())).pfnDestroyCb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_callbacks_t>())).pfnExecuteCommandListsCb
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_callbacks_t),
            "::",
            stringify!(pfnExecuteCommandListsCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_callbacks_t>())).pfnSynchronizeCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_callbacks_t),
            "::",
            stringify!(pfnSynchronizeCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of CommandQueue callback functions pointers"]
pub type ze_command_queue_callbacks_t = _ze_command_queue_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_command_list_desc_t,
    pub pphCommandList: *mut *mut ze_command_list_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_create_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_command_list_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_create_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_create_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_params_t>())).pdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_params_t>())).pphCommandList as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_params_t),
            "::",
            stringify!(pphCommandList)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_create_params_t = _ze_command_list_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListCreateImmediate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_create_immediate_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub paltdesc: *mut *const ze_command_queue_desc_t,
    pub pphCommandList: *mut *mut ze_command_list_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_create_immediate_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_create_immediate_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_create_immediate_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_create_immediate_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_create_immediate_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_immediate_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_immediate_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_immediate_params_t>())).phDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_immediate_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_immediate_params_t>())).paltdesc
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_immediate_params_t),
            "::",
            stringify!(paltdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_create_immediate_params_t>())).pphCommandList
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_create_immediate_params_t),
            "::",
            stringify!(pphCommandList)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListCreateImmediate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_create_immediate_params_t = _ze_command_list_create_immediate_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListCreateImmediate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListCreateImmediateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_create_immediate_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_destroy_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_command_list_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_destroy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_destroy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_destroy_params_t>())).phCommandList as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_destroy_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_destroy_params_t = _ze_command_list_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListClose"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_close_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_close_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_close_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_command_list_close_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_close_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_list_close_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_close_params_t>())).phCommandList as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_close_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListClose"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_close_params_t = _ze_command_list_close_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListClose"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListCloseCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_close_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_reset_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_reset_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_reset_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_command_list_reset_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_reset_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_list_reset_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_reset_params_t>())).phCommandList as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_reset_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_reset_params_t = _ze_command_list_reset_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListReset"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListResetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_reset_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendWriteGlobalTimestamp"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_write_global_timestamp_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pdstptr: *mut *mut u64,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_write_global_timestamp_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_write_global_timestamp_params_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_write_global_timestamp_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_write_global_timestamp_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_write_global_timestamp_params_t>()))
                .pdstptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_write_global_timestamp_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_write_global_timestamp_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_write_global_timestamp_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_write_global_timestamp_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendWriteGlobalTimestamp"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_write_global_timestamp_params_t =
    _ze_command_list_append_write_global_timestamp_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendWriteGlobalTimestamp"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendWriteGlobalTimestampCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_write_global_timestamp_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_barrier_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_barrier_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_barrier_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_barrier_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_barrier_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_barrier_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_barrier_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_barrier_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_barrier_params_t>())).phSignalEvent
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_barrier_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_barrier_params_t>())).pnumWaitEvents
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_barrier_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_barrier_params_t>())).pphWaitEvents
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_barrier_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_barrier_params_t = _ze_command_list_append_barrier_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendBarrier"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendBarrierCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_barrier_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryRangesBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_ranges_barrier_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pnumRanges: *mut u32,
    pub ppRangeSizes: *mut *const usize,
    pub ppRanges: *mut *mut *const ::std::os::raw::c_void,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_ranges_barrier_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_ranges_barrier_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_ranges_barrier_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .pnumRanges as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(pnumRanges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .ppRangeSizes as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(ppRangeSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .ppRanges as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(ppRanges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_ranges_barrier_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_ranges_barrier_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryRangesBarrier"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_ranges_barrier_params_t =
    _ze_command_list_append_memory_ranges_barrier_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryRangesBarrier"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryRangesBarrierCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_ranges_barrier_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_copy_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pdstptr: *mut *mut ::std::os::raw::c_void,
    pub psrcptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_copy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_copy_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_copy_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_copy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_copy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).pdstptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).psrcptr
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(psrcptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).psize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).phSignalEvent
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).pnumWaitEvents
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_params_t>())).pphWaitEvents
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_copy_params_t = _ze_command_list_append_memory_copy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryCopy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryCopyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_copy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryFill"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_fill_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pptr: *mut *mut ::std::os::raw::c_void,
    pub ppattern: *mut *const ::std::os::raw::c_void,
    pub ppattern_size: *mut usize,
    pub psize: *mut usize,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_fill_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_fill_params_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_fill_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_fill_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_fill_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).pptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).ppattern
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(ppattern)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).ppattern_size
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(ppattern_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).psize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).phSignalEvent
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).pnumWaitEvents
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_fill_params_t>())).pphWaitEvents
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_fill_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryFill"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_fill_params_t = _ze_command_list_append_memory_fill_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryFill"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryFillCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_fill_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopyRegion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_copy_region_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pdstptr: *mut *mut ::std::os::raw::c_void,
    pub pdstRegion: *mut *const ze_copy_region_t,
    pub pdstPitch: *mut u32,
    pub pdstSlicePitch: *mut u32,
    pub psrcptr: *mut *const ::std::os::raw::c_void,
    pub psrcRegion: *mut *const ze_copy_region_t,
    pub psrcPitch: *mut u32,
    pub psrcSlicePitch: *mut u32,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_copy_region_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_copy_region_params_t>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_copy_region_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>())).pdstptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .pdstRegion as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pdstRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .pdstPitch as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pdstPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .pdstSlicePitch as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pdstSlicePitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>())).psrcptr
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(psrcptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .psrcRegion as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(psrcRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .psrcPitch as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(psrcPitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .psrcSlicePitch as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(psrcSlicePitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_region_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_region_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopyRegion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_copy_region_params_t =
    _ze_command_list_append_memory_copy_region_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryCopyRegion"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryCopyRegionCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_copy_region_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopyFromContext"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_copy_from_context_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pdstptr: *mut *mut ::std::os::raw::c_void,
    pub phContextSrc: *mut ze_context_handle_t,
    pub psrcptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_copy_from_context_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_copy_from_context_params_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_copy_from_context_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .pdstptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .phContextSrc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(phContextSrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .psrcptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(psrcptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .psize as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_copy_from_context_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_copy_from_context_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryCopyFromContext"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_copy_from_context_params_t =
    _ze_command_list_append_memory_copy_from_context_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryCopyFromContext"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryCopyFromContextCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_copy_from_context_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_image_copy_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phDstImage: *mut ze_image_handle_t,
    pub phSrcImage: *mut ze_image_handle_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_image_copy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_image_copy_params_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_image_copy_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_image_copy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_image_copy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).phDstImage
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(phDstImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).phSrcImage
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(phSrcImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).phSignalEvent
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).pnumWaitEvents
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_params_t>())).pphWaitEvents
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_image_copy_params_t = _ze_command_list_append_image_copy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendImageCopy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendImageCopyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_image_copy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyRegion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_image_copy_region_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phDstImage: *mut ze_image_handle_t,
    pub phSrcImage: *mut ze_image_handle_t,
    pub ppDstRegion: *mut *const ze_image_region_t,
    pub ppSrcRegion: *mut *const ze_image_region_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_image_copy_region_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_image_copy_region_params_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_image_copy_region_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_image_copy_region_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .phDstImage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(phDstImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .phSrcImage as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(phSrcImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .ppDstRegion as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(ppDstRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .ppSrcRegion as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(ppSrcRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_region_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_region_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyRegion"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_image_copy_region_params_t =
    _ze_command_list_append_image_copy_region_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendImageCopyRegion"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendImageCopyRegionCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_image_copy_region_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyToMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_image_copy_to_memory_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pdstptr: *mut *mut ::std::os::raw::c_void,
    pub phSrcImage: *mut ze_image_handle_t,
    pub ppSrcRegion: *mut *const ze_image_region_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_image_copy_to_memory_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_image_copy_to_memory_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_image_copy_to_memory_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .pdstptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .phSrcImage as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(phSrcImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .ppSrcRegion as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(ppSrcRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_to_memory_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_to_memory_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyToMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_image_copy_to_memory_params_t =
    _ze_command_list_append_image_copy_to_memory_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendImageCopyToMemory"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendImageCopyToMemoryCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_image_copy_to_memory_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyFromMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_image_copy_from_memory_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phDstImage: *mut ze_image_handle_t,
    pub psrcptr: *mut *const ::std::os::raw::c_void,
    pub ppDstRegion: *mut *const ze_image_region_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_image_copy_from_memory_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_image_copy_from_memory_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_image_copy_from_memory_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .phDstImage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(phDstImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .psrcptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(psrcptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .ppDstRegion as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(ppDstRegion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_image_copy_from_memory_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_image_copy_from_memory_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendImageCopyFromMemory"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_image_copy_from_memory_params_t =
    _ze_command_list_append_image_copy_from_memory_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendImageCopyFromMemory"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendImageCopyFromMemoryCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_image_copy_from_memory_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryPrefetch"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_memory_prefetch_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_memory_prefetch_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_memory_prefetch_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_memory_prefetch_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_memory_prefetch_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_memory_prefetch_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_prefetch_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_prefetch_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_prefetch_params_t>())).pptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_prefetch_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_memory_prefetch_params_t>())).psize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_memory_prefetch_params_t),
            "::",
            stringify!(psize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemoryPrefetch"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_memory_prefetch_params_t =
    _ze_command_list_append_memory_prefetch_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemoryPrefetch"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemoryPrefetchCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_memory_prefetch_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemAdvise"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_mem_advise_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub padvice: *mut ze_memory_advice_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_mem_advise_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_mem_advise_params_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_mem_advise_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_mem_advise_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_mem_advise_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_mem_advise_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_mem_advise_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_mem_advise_params_t>())).phDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_mem_advise_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_mem_advise_params_t>())).pptr as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_mem_advise_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_mem_advise_params_t>())).psize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_mem_advise_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_mem_advise_params_t>())).padvice
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_mem_advise_params_t),
            "::",
            stringify!(padvice)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendMemAdvise"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_mem_advise_params_t = _ze_command_list_append_mem_advise_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendMemAdvise"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendMemAdviseCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_mem_advise_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendSignalEvent"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_signal_event_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_signal_event_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_signal_event_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_signal_event_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_signal_event_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_signal_event_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_signal_event_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_signal_event_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_signal_event_params_t>())).phEvent
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_signal_event_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendSignalEvent"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_signal_event_params_t =
    _ze_command_list_append_signal_event_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendSignalEvent"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendSignalEventCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_signal_event_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendWaitOnEvents"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_wait_on_events_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pnumEvents: *mut u32,
    pub pphEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_wait_on_events_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_wait_on_events_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_wait_on_events_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_wait_on_events_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_wait_on_events_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_wait_on_events_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_wait_on_events_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_wait_on_events_params_t>())).pnumEvents
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_wait_on_events_params_t),
            "::",
            stringify!(pnumEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_wait_on_events_params_t>())).pphEvents
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_wait_on_events_params_t),
            "::",
            stringify!(pphEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendWaitOnEvents"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_wait_on_events_params_t =
    _ze_command_list_append_wait_on_events_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendWaitOnEvents"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendWaitOnEventsCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_wait_on_events_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendEventReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_event_reset_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_event_reset_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_event_reset_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_event_reset_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_event_reset_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_event_reset_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_event_reset_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_event_reset_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_event_reset_params_t>())).phEvent
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_event_reset_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendEventReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_event_reset_params_t = _ze_command_list_append_event_reset_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendEventReset"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendEventResetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_event_reset_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendQueryKernelTimestamps"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_query_kernel_timestamps_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pnumEvents: *mut u32,
    pub pphEvents: *mut *mut ze_event_handle_t,
    pub pdstptr: *mut *mut ::std::os::raw::c_void,
    pub ppOffsets: *mut *const usize,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_query_kernel_timestamps_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_query_kernel_timestamps_params_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_query_kernel_timestamps_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .pnumEvents as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(pnumEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .pphEvents as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(pphEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .pdstptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .ppOffsets as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(ppOffsets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_query_kernel_timestamps_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_query_kernel_timestamps_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendQueryKernelTimestamps"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_query_kernel_timestamps_params_t =
    _ze_command_list_append_query_kernel_timestamps_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendQueryKernelTimestamps"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendQueryKernelTimestampsCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_query_kernel_timestamps_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchKernel"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_launch_kernel_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppLaunchFuncArgs: *mut *const ze_group_count_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_launch_kernel_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_launch_kernel_params_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_launch_kernel_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_launch_kernel_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>())).phCommandList
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>())).phKernel
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>()))
                .ppLaunchFuncArgs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(ppLaunchFuncArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>())).phSignalEvent
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_params_t>())).pphWaitEvents
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchKernel"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_launch_kernel_params_t =
    _ze_command_list_append_launch_kernel_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendLaunchKernel"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendLaunchKernelCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_launch_kernel_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchCooperativeKernel"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_launch_cooperative_kernel_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppLaunchFuncArgs: *mut *const ze_group_count_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_launch_cooperative_kernel_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_launch_cooperative_kernel_params_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_launch_cooperative_kernel_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .phKernel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .ppLaunchFuncArgs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(ppLaunchFuncArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_cooperative_kernel_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_cooperative_kernel_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchCooperativeKernel"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_launch_cooperative_kernel_params_t =
    _ze_command_list_append_launch_cooperative_kernel_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendLaunchCooperativeKernel"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendLaunchCooperativeKernelCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_launch_cooperative_kernel_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchKernelIndirect"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_launch_kernel_indirect_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppLaunchArgumentsBuffer: *mut *const ze_group_count_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_launch_kernel_indirect_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_launch_kernel_indirect_params_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_launch_kernel_indirect_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .phKernel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .ppLaunchArgumentsBuffer as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(ppLaunchArgumentsBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .phSignalEvent as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .pnumWaitEvents as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_append_launch_kernel_indirect_params_t>()))
                .pphWaitEvents as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_kernel_indirect_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchKernelIndirect"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_launch_kernel_indirect_params_t =
    _ze_command_list_append_launch_kernel_indirect_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendLaunchKernelIndirect"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendLaunchKernelIndirectCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_launch_kernel_indirect_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchMultipleKernelsIndirect"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_append_launch_multiple_kernels_indirect_params_t {
    pub phCommandList: *mut ze_command_list_handle_t,
    pub pnumKernels: *mut u32,
    pub pphKernels: *mut *mut ze_kernel_handle_t,
    pub ppCountBuffer: *mut *const u32,
    pub ppLaunchArgumentsBuffer: *mut *const ze_group_count_t,
    pub phSignalEvent: *mut ze_event_handle_t,
    pub pnumWaitEvents: *mut u32,
    pub pphWaitEvents: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_append_launch_multiple_kernels_indirect_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_append_launch_multiple_kernels_indirect_params_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_append_launch_multiple_kernels_indirect_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .phCommandList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(phCommandList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .pnumKernels as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(pnumKernels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .pphKernels as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(pphKernels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .ppCountBuffer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(ppCountBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .ppLaunchArgumentsBuffer as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(ppLaunchArgumentsBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .phSignalEvent as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(phSignalEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .pnumWaitEvents as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(pnumWaitEvents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _ze_command_list_append_launch_multiple_kernels_indirect_params_t,
            >()))
            .pphWaitEvents as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_append_launch_multiple_kernels_indirect_params_t),
            "::",
            stringify!(pphWaitEvents)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeCommandListAppendLaunchMultipleKernelsIndirect"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_command_list_append_launch_multiple_kernels_indirect_params_t =
    _ze_command_list_append_launch_multiple_kernels_indirect_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeCommandListAppendLaunchMultipleKernelsIndirect"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnCommandListAppendLaunchMultipleKernelsIndirectCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_command_list_append_launch_multiple_kernels_indirect_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of CommandList callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_command_list_callbacks_t {
    pub pfnCreateCb: ze_pfnCommandListCreateCb_t,
    pub pfnCreateImmediateCb: ze_pfnCommandListCreateImmediateCb_t,
    pub pfnDestroyCb: ze_pfnCommandListDestroyCb_t,
    pub pfnCloseCb: ze_pfnCommandListCloseCb_t,
    pub pfnResetCb: ze_pfnCommandListResetCb_t,
    pub pfnAppendWriteGlobalTimestampCb: ze_pfnCommandListAppendWriteGlobalTimestampCb_t,
    pub pfnAppendBarrierCb: ze_pfnCommandListAppendBarrierCb_t,
    pub pfnAppendMemoryRangesBarrierCb: ze_pfnCommandListAppendMemoryRangesBarrierCb_t,
    pub pfnAppendMemoryCopyCb: ze_pfnCommandListAppendMemoryCopyCb_t,
    pub pfnAppendMemoryFillCb: ze_pfnCommandListAppendMemoryFillCb_t,
    pub pfnAppendMemoryCopyRegionCb: ze_pfnCommandListAppendMemoryCopyRegionCb_t,
    pub pfnAppendMemoryCopyFromContextCb: ze_pfnCommandListAppendMemoryCopyFromContextCb_t,
    pub pfnAppendImageCopyCb: ze_pfnCommandListAppendImageCopyCb_t,
    pub pfnAppendImageCopyRegionCb: ze_pfnCommandListAppendImageCopyRegionCb_t,
    pub pfnAppendImageCopyToMemoryCb: ze_pfnCommandListAppendImageCopyToMemoryCb_t,
    pub pfnAppendImageCopyFromMemoryCb: ze_pfnCommandListAppendImageCopyFromMemoryCb_t,
    pub pfnAppendMemoryPrefetchCb: ze_pfnCommandListAppendMemoryPrefetchCb_t,
    pub pfnAppendMemAdviseCb: ze_pfnCommandListAppendMemAdviseCb_t,
    pub pfnAppendSignalEventCb: ze_pfnCommandListAppendSignalEventCb_t,
    pub pfnAppendWaitOnEventsCb: ze_pfnCommandListAppendWaitOnEventsCb_t,
    pub pfnAppendEventResetCb: ze_pfnCommandListAppendEventResetCb_t,
    pub pfnAppendQueryKernelTimestampsCb: ze_pfnCommandListAppendQueryKernelTimestampsCb_t,
    pub pfnAppendLaunchKernelCb: ze_pfnCommandListAppendLaunchKernelCb_t,
    pub pfnAppendLaunchCooperativeKernelCb: ze_pfnCommandListAppendLaunchCooperativeKernelCb_t,
    pub pfnAppendLaunchKernelIndirectCb: ze_pfnCommandListAppendLaunchKernelIndirectCb_t,
    pub pfnAppendLaunchMultipleKernelsIndirectCb:
        ze_pfnCommandListAppendLaunchMultipleKernelsIndirectCb_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_callbacks_t>(),
        208usize,
        concat!("Size of: ", stringify!(_ze_command_list_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_command_list_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnCreateCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnCreateImmediateCb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnCreateImmediateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnDestroyCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnCloseCb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnCloseCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnResetCb as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnResetCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendWriteGlobalTimestampCb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendWriteGlobalTimestampCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendBarrierCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendBarrierCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemoryRangesBarrierCb
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryRangesBarrierCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemoryCopyCb
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryCopyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemoryFillCb
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryFillCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemoryCopyRegionCb
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryCopyRegionCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>()))
                .pfnAppendMemoryCopyFromContextCb as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryCopyFromContextCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendImageCopyCb
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendImageCopyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendImageCopyRegionCb
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendImageCopyRegionCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendImageCopyToMemoryCb
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendImageCopyToMemoryCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendImageCopyFromMemoryCb
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendImageCopyFromMemoryCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemoryPrefetchCb
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemoryPrefetchCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendMemAdviseCb
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendMemAdviseCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendSignalEventCb
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendSignalEventCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendWaitOnEventsCb
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendWaitOnEventsCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendEventResetCb
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendEventResetCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>()))
                .pfnAppendQueryKernelTimestampsCb as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendQueryKernelTimestampsCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendLaunchKernelCb
                as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendLaunchKernelCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>()))
                .pfnAppendLaunchCooperativeKernelCb as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendLaunchCooperativeKernelCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>())).pfnAppendLaunchKernelIndirectCb
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendLaunchKernelIndirectCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_list_callbacks_t>()))
                .pfnAppendLaunchMultipleKernelsIndirectCb as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_callbacks_t),
            "::",
            stringify!(pfnAppendLaunchMultipleKernelsIndirectCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of CommandList callback functions pointers"]
pub type ze_command_list_callbacks_t = _ze_command_list_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_create_params_t {
    pub phCommandQueue: *mut ze_command_queue_handle_t,
    pub pdesc: *mut *const ze_fence_desc_t,
    pub pphFence: *mut *mut ze_fence_handle_t,
}
#[test]
fn bindgen_test_layout__ze_fence_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_create_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_fence_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_create_params_t>())).phCommandQueue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_create_params_t),
            "::",
            stringify!(phCommandQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_create_params_t>())).pdesc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_create_params_t>())).pphFence as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_create_params_t),
            "::",
            stringify!(pphFence)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_fence_create_params_t = _ze_fence_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeFenceCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnFenceCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_fence_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_destroy_params_t {
    pub phFence: *mut ze_fence_handle_t,
}
#[test]
fn bindgen_test_layout__ze_fence_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_fence_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_destroy_params_t>())).phFence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_destroy_params_t),
            "::",
            stringify!(phFence)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_fence_destroy_params_t = _ze_fence_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeFenceDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnFenceDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_fence_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceHostSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_host_synchronize_params_t {
    pub phFence: *mut ze_fence_handle_t,
    pub ptimeout: *mut u64,
}
#[test]
fn bindgen_test_layout__ze_fence_host_synchronize_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_host_synchronize_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_fence_host_synchronize_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_host_synchronize_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_fence_host_synchronize_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_host_synchronize_params_t>())).phFence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_host_synchronize_params_t),
            "::",
            stringify!(phFence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_host_synchronize_params_t>())).ptimeout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_host_synchronize_params_t),
            "::",
            stringify!(ptimeout)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceHostSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_fence_host_synchronize_params_t = _ze_fence_host_synchronize_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeFenceHostSynchronize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnFenceHostSynchronizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_fence_host_synchronize_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceQueryStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_query_status_params_t {
    pub phFence: *mut ze_fence_handle_t,
}
#[test]
fn bindgen_test_layout__ze_fence_query_status_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_query_status_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_fence_query_status_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_query_status_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_query_status_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_query_status_params_t>())).phFence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_query_status_params_t),
            "::",
            stringify!(phFence)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceQueryStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_fence_query_status_params_t = _ze_fence_query_status_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeFenceQueryStatus"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnFenceQueryStatusCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_fence_query_status_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_reset_params_t {
    pub phFence: *mut ze_fence_handle_t,
}
#[test]
fn bindgen_test_layout__ze_fence_reset_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_reset_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_fence_reset_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_reset_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_reset_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_reset_params_t>())).phFence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_reset_params_t),
            "::",
            stringify!(phFence)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeFenceReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_fence_reset_params_t = _ze_fence_reset_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeFenceReset"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnFenceResetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_fence_reset_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Fence callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_fence_callbacks_t {
    pub pfnCreateCb: ze_pfnFenceCreateCb_t,
    pub pfnDestroyCb: ze_pfnFenceDestroyCb_t,
    pub pfnHostSynchronizeCb: ze_pfnFenceHostSynchronizeCb_t,
    pub pfnQueryStatusCb: ze_pfnFenceQueryStatusCb_t,
    pub pfnResetCb: ze_pfnFenceResetCb_t,
}
#[test]
fn bindgen_test_layout__ze_fence_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_callbacks_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_fence_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_fence_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_callbacks_t>())).pfnHostSynchronizeCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_callbacks_t),
            "::",
            stringify!(pfnHostSynchronizeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_callbacks_t>())).pfnQueryStatusCb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_callbacks_t),
            "::",
            stringify!(pfnQueryStatusCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_fence_callbacks_t>())).pfnResetCb as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_callbacks_t),
            "::",
            stringify!(pfnResetCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Fence callback functions pointers"]
pub type ze_fence_callbacks_t = _ze_fence_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pdesc: *mut *const ze_event_pool_desc_t,
    pub pnumDevices: *mut u32,
    pub pphDevices: *mut *mut ze_device_handle_t,
    pub pphEventPool: *mut *mut ze_event_pool_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_create_params_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_event_pool_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_create_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_create_params_t>())).pdesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_create_params_t>())).pnumDevices as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_create_params_t),
            "::",
            stringify!(pnumDevices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_create_params_t>())).pphDevices as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_create_params_t),
            "::",
            stringify!(pphDevices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_create_params_t>())).pphEventPool as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_create_params_t),
            "::",
            stringify!(pphEventPool)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_pool_create_params_t = _ze_event_pool_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventPoolCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventPoolCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_pool_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_destroy_params_t {
    pub phEventPool: *mut ze_event_pool_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_event_pool_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_destroy_params_t>())).phEventPool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_destroy_params_t),
            "::",
            stringify!(phEventPool)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_pool_destroy_params_t = _ze_event_pool_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventPoolDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventPoolDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_pool_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolGetIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_get_ipc_handle_params_t {
    pub phEventPool: *mut ze_event_pool_handle_t,
    pub pphIpc: *mut *mut ze_ipc_event_pool_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_get_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_get_ipc_handle_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_event_pool_get_ipc_handle_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_get_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_event_pool_get_ipc_handle_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_get_ipc_handle_params_t>())).phEventPool
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_get_ipc_handle_params_t),
            "::",
            stringify!(phEventPool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_get_ipc_handle_params_t>())).pphIpc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_get_ipc_handle_params_t),
            "::",
            stringify!(pphIpc)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolGetIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_pool_get_ipc_handle_params_t = _ze_event_pool_get_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventPoolGetIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventPoolGetIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_pool_get_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolOpenIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_open_ipc_handle_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phIpc: *mut ze_ipc_event_pool_handle_t,
    pub pphEventPool: *mut *mut ze_event_pool_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_open_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_open_ipc_handle_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_event_pool_open_ipc_handle_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_open_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_event_pool_open_ipc_handle_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_open_ipc_handle_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_open_ipc_handle_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_open_ipc_handle_params_t>())).phIpc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_open_ipc_handle_params_t),
            "::",
            stringify!(phIpc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_open_ipc_handle_params_t>())).pphEventPool
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_open_ipc_handle_params_t),
            "::",
            stringify!(pphEventPool)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolOpenIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_pool_open_ipc_handle_params_t = _ze_event_pool_open_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventPoolOpenIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventPoolOpenIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_pool_open_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolCloseIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_close_ipc_handle_params_t {
    pub phEventPool: *mut ze_event_pool_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_close_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_close_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_ze_event_pool_close_ipc_handle_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_close_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_event_pool_close_ipc_handle_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_close_ipc_handle_params_t>())).phEventPool
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_close_ipc_handle_params_t),
            "::",
            stringify!(phEventPool)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventPoolCloseIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_pool_close_ipc_handle_params_t = _ze_event_pool_close_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventPoolCloseIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventPoolCloseIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_pool_close_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of EventPool callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_event_pool_callbacks_t {
    pub pfnCreateCb: ze_pfnEventPoolCreateCb_t,
    pub pfnDestroyCb: ze_pfnEventPoolDestroyCb_t,
    pub pfnGetIpcHandleCb: ze_pfnEventPoolGetIpcHandleCb_t,
    pub pfnOpenIpcHandleCb: ze_pfnEventPoolOpenIpcHandleCb_t,
    pub pfnCloseIpcHandleCb: ze_pfnEventPoolCloseIpcHandleCb_t,
}
#[test]
fn bindgen_test_layout__ze_event_pool_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_callbacks_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_event_pool_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_callbacks_t>())).pfnGetIpcHandleCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_callbacks_t),
            "::",
            stringify!(pfnGetIpcHandleCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_callbacks_t>())).pfnOpenIpcHandleCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_callbacks_t),
            "::",
            stringify!(pfnOpenIpcHandleCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_pool_callbacks_t>())).pfnCloseIpcHandleCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_callbacks_t),
            "::",
            stringify!(pfnCloseIpcHandleCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of EventPool callback functions pointers"]
pub type ze_event_pool_callbacks_t = _ze_event_pool_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_create_params_t {
    pub phEventPool: *mut ze_event_pool_handle_t,
    pub pdesc: *mut *const ze_event_desc_t,
    pub pphEvent: *mut *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_create_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_event_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_create_params_t>())).phEventPool as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_create_params_t),
            "::",
            stringify!(phEventPool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_create_params_t>())).pdesc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_create_params_t>())).pphEvent as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_create_params_t),
            "::",
            stringify!(pphEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_create_params_t = _ze_event_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_destroy_params_t {
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_event_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_destroy_params_t>())).phEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_destroy_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_destroy_params_t = _ze_event_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostSignal"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_host_signal_params_t {
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_host_signal_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_host_signal_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_event_host_signal_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_host_signal_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_host_signal_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_host_signal_params_t>())).phEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_host_signal_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostSignal"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_host_signal_params_t = _ze_event_host_signal_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventHostSignal"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventHostSignalCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_host_signal_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_host_synchronize_params_t {
    pub phEvent: *mut ze_event_handle_t,
    pub ptimeout: *mut u64,
}
#[test]
fn bindgen_test_layout__ze_event_host_synchronize_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_host_synchronize_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_event_host_synchronize_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_host_synchronize_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_event_host_synchronize_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_host_synchronize_params_t>())).phEvent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_host_synchronize_params_t),
            "::",
            stringify!(phEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_host_synchronize_params_t>())).ptimeout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_host_synchronize_params_t),
            "::",
            stringify!(ptimeout)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostSynchronize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_host_synchronize_params_t = _ze_event_host_synchronize_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventHostSynchronize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventHostSynchronizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_host_synchronize_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventQueryStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_query_status_params_t {
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_query_status_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_query_status_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_event_query_status_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_query_status_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_query_status_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_query_status_params_t>())).phEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_query_status_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventQueryStatus"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_query_status_params_t = _ze_event_query_status_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventQueryStatus"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventQueryStatusCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_query_status_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_host_reset_params_t {
    pub phEvent: *mut ze_event_handle_t,
}
#[test]
fn bindgen_test_layout__ze_event_host_reset_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_host_reset_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_event_host_reset_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_host_reset_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_host_reset_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_host_reset_params_t>())).phEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_host_reset_params_t),
            "::",
            stringify!(phEvent)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventHostReset"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_host_reset_params_t = _ze_event_host_reset_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventHostReset"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventHostResetCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_host_reset_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventQueryKernelTimestamp"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_query_kernel_timestamp_params_t {
    pub phEvent: *mut ze_event_handle_t,
    pub pdstptr: *mut *mut ze_kernel_timestamp_result_t,
}
#[test]
fn bindgen_test_layout__ze_event_query_kernel_timestamp_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_query_kernel_timestamp_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_event_query_kernel_timestamp_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_query_kernel_timestamp_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_event_query_kernel_timestamp_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_query_kernel_timestamp_params_t>())).phEvent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_query_kernel_timestamp_params_t),
            "::",
            stringify!(phEvent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_query_kernel_timestamp_params_t>())).pdstptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_query_kernel_timestamp_params_t),
            "::",
            stringify!(pdstptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeEventQueryKernelTimestamp"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_event_query_kernel_timestamp_params_t = _ze_event_query_kernel_timestamp_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeEventQueryKernelTimestamp"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnEventQueryKernelTimestampCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_event_query_kernel_timestamp_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Event callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_event_callbacks_t {
    pub pfnCreateCb: ze_pfnEventCreateCb_t,
    pub pfnDestroyCb: ze_pfnEventDestroyCb_t,
    pub pfnHostSignalCb: ze_pfnEventHostSignalCb_t,
    pub pfnHostSynchronizeCb: ze_pfnEventHostSynchronizeCb_t,
    pub pfnQueryStatusCb: ze_pfnEventQueryStatusCb_t,
    pub pfnHostResetCb: ze_pfnEventHostResetCb_t,
    pub pfnQueryKernelTimestampCb: ze_pfnEventQueryKernelTimestampCb_t,
}
#[test]
fn bindgen_test_layout__ze_event_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_callbacks_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_event_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_event_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnHostSignalCb as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnHostSignalCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnHostSynchronizeCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnHostSynchronizeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnQueryStatusCb as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnQueryStatusCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnHostResetCb as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnHostResetCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_event_callbacks_t>())).pfnQueryKernelTimestampCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_callbacks_t),
            "::",
            stringify!(pfnQueryKernelTimestampCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Event callback functions pointers"]
pub type ze_event_callbacks_t = _ze_event_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_get_properties_params_t {
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_image_desc_t,
    pub ppImageProperties: *mut *mut ze_image_properties_t,
}
#[test]
fn bindgen_test_layout__ze_image_get_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_get_properties_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_get_properties_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_get_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_image_get_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_get_properties_params_t>())).phDevice as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_get_properties_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_get_properties_params_t>())).pdesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_get_properties_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_get_properties_params_t>())).ppImageProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_get_properties_params_t),
            "::",
            stringify!(ppImageProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_image_get_properties_params_t = _ze_image_get_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeImageGetProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnImageGetPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_image_get_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_image_desc_t,
    pub pphImage: *mut *mut ze_image_handle_t,
}
#[test]
fn bindgen_test_layout__ze_image_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_create_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_image_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_create_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_create_params_t>())).phDevice as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_create_params_t>())).pdesc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_create_params_t>())).pphImage as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_create_params_t),
            "::",
            stringify!(pphImage)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_image_create_params_t = _ze_image_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeImageCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnImageCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_image_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_destroy_params_t {
    pub phImage: *mut ze_image_handle_t,
}
#[test]
fn bindgen_test_layout__ze_image_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_image_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_destroy_params_t>())).phImage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_destroy_params_t),
            "::",
            stringify!(phImage)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeImageDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_image_destroy_params_t = _ze_image_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeImageDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnImageDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_image_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Image callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_image_callbacks_t {
    pub pfnGetPropertiesCb: ze_pfnImageGetPropertiesCb_t,
    pub pfnCreateCb: ze_pfnImageCreateCb_t,
    pub pfnDestroyCb: ze_pfnImageDestroyCb_t,
}
#[test]
fn bindgen_test_layout__ze_image_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_callbacks_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_callbacks_t>())).pfnGetPropertiesCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_callbacks_t),
            "::",
            stringify!(pfnGetPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Image callback functions pointers"]
pub type ze_image_callbacks_t = _ze_image_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_module_desc_t,
    pub pphModule: *mut *mut ze_module_handle_t,
    pub pphBuildLog: *mut *mut ze_module_build_log_handle_t,
}
#[test]
fn bindgen_test_layout__ze_module_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_create_params_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_module_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_create_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_create_params_t>())).phDevice as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_create_params_t>())).pdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_create_params_t>())).pphModule as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_create_params_t),
            "::",
            stringify!(pphModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_create_params_t>())).pphBuildLog as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_create_params_t),
            "::",
            stringify!(pphBuildLog)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_create_params_t = _ze_module_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_destroy_params_t {
    pub phModule: *mut ze_module_handle_t,
}
#[test]
fn bindgen_test_layout__ze_module_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_module_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_destroy_params_t>())).phModule as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_destroy_params_t),
            "::",
            stringify!(phModule)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_destroy_params_t = _ze_module_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleDynamicLink"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_dynamic_link_params_t {
    pub pnumModules: *mut u32,
    pub pphModules: *mut *mut ze_module_handle_t,
    pub pphLinkLog: *mut *mut ze_module_build_log_handle_t,
}
#[test]
fn bindgen_test_layout__ze_module_dynamic_link_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_dynamic_link_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_dynamic_link_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_dynamic_link_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_dynamic_link_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_dynamic_link_params_t>())).pnumModules as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_dynamic_link_params_t),
            "::",
            stringify!(pnumModules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_dynamic_link_params_t>())).pphModules as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_dynamic_link_params_t),
            "::",
            stringify!(pphModules)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_dynamic_link_params_t>())).pphLinkLog as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_dynamic_link_params_t),
            "::",
            stringify!(pphLinkLog)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleDynamicLink"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_dynamic_link_params_t = _ze_module_dynamic_link_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleDynamicLink"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleDynamicLinkCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_dynamic_link_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetNativeBinary"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_get_native_binary_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub ppSize: *mut *mut usize,
    pub ppModuleNativeBinary: *mut *mut u8,
}
#[test]
fn bindgen_test_layout__ze_module_get_native_binary_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_get_native_binary_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_get_native_binary_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_get_native_binary_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_get_native_binary_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_native_binary_params_t>())).phModule as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_native_binary_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_native_binary_params_t>())).ppSize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_native_binary_params_t),
            "::",
            stringify!(ppSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_native_binary_params_t>())).ppModuleNativeBinary
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_native_binary_params_t),
            "::",
            stringify!(ppModuleNativeBinary)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetNativeBinary"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_get_native_binary_params_t = _ze_module_get_native_binary_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleGetNativeBinary"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleGetNativeBinaryCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_get_native_binary_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetGlobalPointer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_get_global_pointer_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub ppGlobalName: *mut *const ::std::os::raw::c_char,
    pub ppSize: *mut *mut usize,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_module_get_global_pointer_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_get_global_pointer_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_get_global_pointer_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_get_global_pointer_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_get_global_pointer_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_global_pointer_params_t>())).phModule as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_global_pointer_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_global_pointer_params_t>())).ppGlobalName
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_global_pointer_params_t),
            "::",
            stringify!(ppGlobalName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_global_pointer_params_t>())).ppSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_global_pointer_params_t),
            "::",
            stringify!(ppSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_global_pointer_params_t>())).ppptr as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_global_pointer_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetGlobalPointer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_get_global_pointer_params_t = _ze_module_get_global_pointer_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleGetGlobalPointer"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleGetGlobalPointerCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_get_global_pointer_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetKernelNames"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_get_kernel_names_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub ppCount: *mut *mut u32,
    pub ppNames: *mut *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_module_get_kernel_names_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_get_kernel_names_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_get_kernel_names_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_get_kernel_names_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_get_kernel_names_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_kernel_names_params_t>())).phModule as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_kernel_names_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_kernel_names_params_t>())).ppCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_kernel_names_params_t),
            "::",
            stringify!(ppCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_kernel_names_params_t>())).ppNames as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_kernel_names_params_t),
            "::",
            stringify!(ppNames)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetKernelNames"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_get_kernel_names_params_t = _ze_module_get_kernel_names_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleGetKernelNames"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleGetKernelNamesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_get_kernel_names_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_get_properties_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub ppModuleProperties: *mut *mut ze_module_properties_t,
}
#[test]
fn bindgen_test_layout__ze_module_get_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_get_properties_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_module_get_properties_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_get_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_get_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_properties_params_t>())).phModule as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_properties_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_properties_params_t>())).ppModuleProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_properties_params_t),
            "::",
            stringify!(ppModuleProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_get_properties_params_t = _ze_module_get_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleGetProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleGetPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_get_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetFunctionPointer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_get_function_pointer_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub ppFunctionName: *mut *const ::std::os::raw::c_char,
    pub ppfnFunction: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_module_get_function_pointer_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_get_function_pointer_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_get_function_pointer_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_get_function_pointer_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_get_function_pointer_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_function_pointer_params_t>())).phModule
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_function_pointer_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_function_pointer_params_t>())).ppFunctionName
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_function_pointer_params_t),
            "::",
            stringify!(ppFunctionName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_get_function_pointer_params_t>())).ppfnFunction
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_get_function_pointer_params_t),
            "::",
            stringify!(ppfnFunction)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleGetFunctionPointer"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_get_function_pointer_params_t = _ze_module_get_function_pointer_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleGetFunctionPointer"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleGetFunctionPointerCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_get_function_pointer_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Module callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_module_callbacks_t {
    pub pfnCreateCb: ze_pfnModuleCreateCb_t,
    pub pfnDestroyCb: ze_pfnModuleDestroyCb_t,
    pub pfnDynamicLinkCb: ze_pfnModuleDynamicLinkCb_t,
    pub pfnGetNativeBinaryCb: ze_pfnModuleGetNativeBinaryCb_t,
    pub pfnGetGlobalPointerCb: ze_pfnModuleGetGlobalPointerCb_t,
    pub pfnGetKernelNamesCb: ze_pfnModuleGetKernelNamesCb_t,
    pub pfnGetPropertiesCb: ze_pfnModuleGetPropertiesCb_t,
    pub pfnGetFunctionPointerCb: ze_pfnModuleGetFunctionPointerCb_t,
}
#[test]
fn bindgen_test_layout__ze_module_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_callbacks_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_module_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnDynamicLinkCb as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnDynamicLinkCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnGetNativeBinaryCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnGetNativeBinaryCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnGetGlobalPointerCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnGetGlobalPointerCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnGetKernelNamesCb as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnGetKernelNamesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnGetPropertiesCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnGetPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_callbacks_t>())).pfnGetFunctionPointerCb as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_callbacks_t),
            "::",
            stringify!(pfnGetFunctionPointerCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Module callback functions pointers"]
pub type ze_module_callbacks_t = _ze_module_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleBuildLogDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_build_log_destroy_params_t {
    pub phModuleBuildLog: *mut ze_module_build_log_handle_t,
}
#[test]
fn bindgen_test_layout__ze_module_build_log_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_build_log_destroy_params_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_build_log_destroy_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_build_log_destroy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_build_log_destroy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_destroy_params_t>())).phModuleBuildLog
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_destroy_params_t),
            "::",
            stringify!(phModuleBuildLog)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleBuildLogDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_build_log_destroy_params_t = _ze_module_build_log_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleBuildLogDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleBuildLogDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_build_log_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleBuildLogGetString"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_build_log_get_string_params_t {
    pub phModuleBuildLog: *mut ze_module_build_log_handle_t,
    pub ppSize: *mut *mut usize,
    pub ppBuildLog: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_module_build_log_get_string_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_build_log_get_string_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_module_build_log_get_string_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_build_log_get_string_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_build_log_get_string_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_get_string_params_t>())).phModuleBuildLog
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_get_string_params_t),
            "::",
            stringify!(phModuleBuildLog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_get_string_params_t>())).ppSize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_get_string_params_t),
            "::",
            stringify!(ppSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_get_string_params_t>())).ppBuildLog
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_get_string_params_t),
            "::",
            stringify!(ppBuildLog)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeModuleBuildLogGetString"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_module_build_log_get_string_params_t = _ze_module_build_log_get_string_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeModuleBuildLogGetString"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnModuleBuildLogGetStringCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_module_build_log_get_string_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of ModuleBuildLog callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_module_build_log_callbacks_t {
    pub pfnDestroyCb: ze_pfnModuleBuildLogDestroyCb_t,
    pub pfnGetStringCb: ze_pfnModuleBuildLogGetStringCb_t,
}
#[test]
fn bindgen_test_layout__ze_module_build_log_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_build_log_callbacks_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_module_build_log_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_build_log_callbacks_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_module_build_log_callbacks_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_callbacks_t>())).pfnDestroyCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_build_log_callbacks_t>())).pfnGetStringCb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_build_log_callbacks_t),
            "::",
            stringify!(pfnGetStringCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of ModuleBuildLog callback functions pointers"]
pub type ze_module_build_log_callbacks_t = _ze_module_build_log_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_create_params_t {
    pub phModule: *mut ze_module_handle_t,
    pub pdesc: *mut *const ze_kernel_desc_t,
    pub pphKernel: *mut *mut ze_kernel_handle_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_create_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_kernel_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_create_params_t>())).phModule as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_create_params_t),
            "::",
            stringify!(phModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_create_params_t>())).pdesc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_create_params_t>())).pphKernel as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_create_params_t),
            "::",
            stringify!(pphKernel)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_create_params_t = _ze_kernel_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_destroy_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_kernel_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_destroy_params_t>())).phKernel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_destroy_params_t),
            "::",
            stringify!(phKernel)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_destroy_params_t = _ze_kernel_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetCacheConfig"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_set_cache_config_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub pflags: *mut ze_cache_config_flags_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_set_cache_config_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_set_cache_config_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_set_cache_config_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_set_cache_config_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_set_cache_config_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_cache_config_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_cache_config_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_cache_config_params_t>())).pflags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_cache_config_params_t),
            "::",
            stringify!(pflags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetCacheConfig"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_set_cache_config_params_t = _ze_kernel_set_cache_config_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSetCacheConfig"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSetCacheConfigCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_set_cache_config_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetGroupSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_set_group_size_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub pgroupSizeX: *mut u32,
    pub pgroupSizeY: *mut u32,
    pub pgroupSizeZ: *mut u32,
}
#[test]
fn bindgen_test_layout__ze_kernel_set_group_size_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_set_group_size_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_kernel_set_group_size_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_set_group_size_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_set_group_size_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_group_size_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_group_size_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_group_size_params_t>())).pgroupSizeX as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_group_size_params_t),
            "::",
            stringify!(pgroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_group_size_params_t>())).pgroupSizeY as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_group_size_params_t),
            "::",
            stringify!(pgroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_group_size_params_t>())).pgroupSizeZ as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_group_size_params_t),
            "::",
            stringify!(pgroupSizeZ)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetGroupSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_set_group_size_params_t = _ze_kernel_set_group_size_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSetGroupSize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSetGroupSizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_set_group_size_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSuggestGroupSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_suggest_group_size_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub pglobalSizeX: *mut u32,
    pub pglobalSizeY: *mut u32,
    pub pglobalSizeZ: *mut u32,
    pub pgroupSizeX: *mut *mut u32,
    pub pgroupSizeY: *mut *mut u32,
    pub pgroupSizeZ: *mut *mut u32,
}
#[test]
fn bindgen_test_layout__ze_kernel_suggest_group_size_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_suggest_group_size_params_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_suggest_group_size_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_suggest_group_size_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_suggest_group_size_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pglobalSizeX
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pglobalSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pglobalSizeY
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pglobalSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pglobalSizeZ
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pglobalSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pgroupSizeX
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pgroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pgroupSizeY
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pgroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_group_size_params_t>())).pgroupSizeZ
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_group_size_params_t),
            "::",
            stringify!(pgroupSizeZ)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSuggestGroupSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_suggest_group_size_params_t = _ze_kernel_suggest_group_size_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSuggestGroupSize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSuggestGroupSizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_suggest_group_size_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSuggestMaxCooperativeGroupCount"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_suggest_max_cooperative_group_count_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub ptotalGroupCount: *mut *mut u32,
}
#[test]
fn bindgen_test_layout__ze_kernel_suggest_max_cooperative_group_count_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_suggest_max_cooperative_group_count_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_suggest_max_cooperative_group_count_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_suggest_max_cooperative_group_count_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_suggest_max_cooperative_group_count_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_max_cooperative_group_count_params_t>()))
                .phKernel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_max_cooperative_group_count_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_suggest_max_cooperative_group_count_params_t>()))
                .ptotalGroupCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_suggest_max_cooperative_group_count_params_t),
            "::",
            stringify!(ptotalGroupCount)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSuggestMaxCooperativeGroupCount"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_suggest_max_cooperative_group_count_params_t =
    _ze_kernel_suggest_max_cooperative_group_count_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSuggestMaxCooperativeGroupCount"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSuggestMaxCooperativeGroupCountCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_suggest_max_cooperative_group_count_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetArgumentValue"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_set_argument_value_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub pargIndex: *mut u32,
    pub pargSize: *mut usize,
    pub ppArgValue: *mut *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_kernel_set_argument_value_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_set_argument_value_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_set_argument_value_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_set_argument_value_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_set_argument_value_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_argument_value_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_argument_value_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_argument_value_params_t>())).pargIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_argument_value_params_t),
            "::",
            stringify!(pargIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_argument_value_params_t>())).pargSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_argument_value_params_t),
            "::",
            stringify!(pargSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_argument_value_params_t>())).ppArgValue
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_argument_value_params_t),
            "::",
            stringify!(ppArgValue)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetArgumentValue"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_set_argument_value_params_t = _ze_kernel_set_argument_value_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSetArgumentValue"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSetArgumentValueCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_set_argument_value_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetIndirectAccess"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_set_indirect_access_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub pflags: *mut ze_kernel_indirect_access_flags_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_set_indirect_access_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_set_indirect_access_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_set_indirect_access_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_set_indirect_access_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_set_indirect_access_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_indirect_access_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_indirect_access_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_set_indirect_access_params_t>())).pflags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_set_indirect_access_params_t),
            "::",
            stringify!(pflags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelSetIndirectAccess"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_set_indirect_access_params_t = _ze_kernel_set_indirect_access_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelSetIndirectAccess"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelSetIndirectAccessCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_set_indirect_access_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetIndirectAccess"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_get_indirect_access_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppFlags: *mut *mut ze_kernel_indirect_access_flags_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_get_indirect_access_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_get_indirect_access_params_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_get_indirect_access_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_get_indirect_access_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_get_indirect_access_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_indirect_access_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_indirect_access_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_indirect_access_params_t>())).ppFlags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_indirect_access_params_t),
            "::",
            stringify!(ppFlags)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetIndirectAccess"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_get_indirect_access_params_t = _ze_kernel_get_indirect_access_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelGetIndirectAccess"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelGetIndirectAccessCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_get_indirect_access_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetSourceAttributes"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_get_source_attributes_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppSize: *mut *mut u32,
    pub ppString: *mut *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_kernel_get_source_attributes_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_get_source_attributes_params_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_kernel_get_source_attributes_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_get_source_attributes_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_get_source_attributes_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_source_attributes_params_t>())).phKernel
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_source_attributes_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_source_attributes_params_t>())).ppSize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_source_attributes_params_t),
            "::",
            stringify!(ppSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_source_attributes_params_t>())).ppString
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_source_attributes_params_t),
            "::",
            stringify!(ppString)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetSourceAttributes"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_get_source_attributes_params_t = _ze_kernel_get_source_attributes_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelGetSourceAttributes"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelGetSourceAttributesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_get_source_attributes_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_get_properties_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppKernelProperties: *mut *mut ze_kernel_properties_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_get_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_get_properties_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_kernel_get_properties_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_get_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_kernel_get_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_properties_params_t>())).phKernel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_properties_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_properties_params_t>())).ppKernelProperties
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_properties_params_t),
            "::",
            stringify!(ppKernelProperties)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_get_properties_params_t = _ze_kernel_get_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelGetProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelGetPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_get_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetName"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_get_name_params_t {
    pub phKernel: *mut ze_kernel_handle_t,
    pub ppSize: *mut *mut usize,
    pub ppName: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_kernel_get_name_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_get_name_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_kernel_get_name_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_get_name_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_get_name_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_name_params_t>())).phKernel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_name_params_t),
            "::",
            stringify!(phKernel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_name_params_t>())).ppSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_name_params_t),
            "::",
            stringify!(ppSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_get_name_params_t>())).ppName as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_get_name_params_t),
            "::",
            stringify!(ppName)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeKernelGetName"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_kernel_get_name_params_t = _ze_kernel_get_name_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeKernelGetName"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnKernelGetNameCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_kernel_get_name_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Kernel callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_kernel_callbacks_t {
    pub pfnCreateCb: ze_pfnKernelCreateCb_t,
    pub pfnDestroyCb: ze_pfnKernelDestroyCb_t,
    pub pfnSetCacheConfigCb: ze_pfnKernelSetCacheConfigCb_t,
    pub pfnSetGroupSizeCb: ze_pfnKernelSetGroupSizeCb_t,
    pub pfnSuggestGroupSizeCb: ze_pfnKernelSuggestGroupSizeCb_t,
    pub pfnSuggestMaxCooperativeGroupCountCb: ze_pfnKernelSuggestMaxCooperativeGroupCountCb_t,
    pub pfnSetArgumentValueCb: ze_pfnKernelSetArgumentValueCb_t,
    pub pfnSetIndirectAccessCb: ze_pfnKernelSetIndirectAccessCb_t,
    pub pfnGetIndirectAccessCb: ze_pfnKernelGetIndirectAccessCb_t,
    pub pfnGetSourceAttributesCb: ze_pfnKernelGetSourceAttributesCb_t,
    pub pfnGetPropertiesCb: ze_pfnKernelGetPropertiesCb_t,
    pub pfnGetNameCb: ze_pfnKernelGetNameCb_t,
}
#[test]
fn bindgen_test_layout__ze_kernel_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_callbacks_t>(),
        96usize,
        concat!("Size of: ", stringify!(_ze_kernel_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSetCacheConfigCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSetCacheConfigCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSetGroupSizeCb as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSetGroupSizeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSuggestGroupSizeCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSuggestGroupSizeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSuggestMaxCooperativeGroupCountCb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSuggestMaxCooperativeGroupCountCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSetArgumentValueCb as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSetArgumentValueCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnSetIndirectAccessCb as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnSetIndirectAccessCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnGetIndirectAccessCb as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnGetIndirectAccessCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnGetSourceAttributesCb as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnGetSourceAttributesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnGetPropertiesCb as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnGetPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_callbacks_t>())).pfnGetNameCb as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_callbacks_t),
            "::",
            stringify!(pfnGetNameCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Kernel callback functions pointers"]
pub type ze_kernel_callbacks_t = _ze_kernel_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeSamplerCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *const ze_sampler_desc_t,
    pub pphSampler: *mut *mut ze_sampler_handle_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_create_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_sampler_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_create_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_sampler_create_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_create_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_create_params_t>())).phDevice as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_create_params_t>())).pdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_create_params_t>())).pphSampler as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_create_params_t),
            "::",
            stringify!(pphSampler)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeSamplerCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_sampler_create_params_t = _ze_sampler_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeSamplerCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnSamplerCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_sampler_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeSamplerDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_destroy_params_t {
    pub phSampler: *mut ze_sampler_handle_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_destroy_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_sampler_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_destroy_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_sampler_destroy_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_destroy_params_t>())).phSampler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_destroy_params_t),
            "::",
            stringify!(phSampler)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeSamplerDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_sampler_destroy_params_t = _ze_sampler_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeSamplerDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnSamplerDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_sampler_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Sampler callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_sampler_callbacks_t {
    pub pfnCreateCb: ze_pfnSamplerCreateCb_t,
    pub pfnDestroyCb: ze_pfnSamplerDestroyCb_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_callbacks_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_sampler_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_sampler_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_callbacks_t>())).pfnCreateCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_sampler_callbacks_t>())).pfnDestroyCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Sampler callback functions pointers"]
pub type ze_sampler_callbacks_t = _ze_sampler_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zePhysicalMemCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_create_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub pdesc: *mut *mut ze_physical_mem_desc_t,
    pub pphPhysicalMemory: *mut *mut ze_physical_mem_handle_t,
}
#[test]
fn bindgen_test_layout__ze_physical_mem_create_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_physical_mem_create_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_physical_mem_create_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_physical_mem_create_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_physical_mem_create_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_create_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_create_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_create_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_create_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_create_params_t>())).pdesc as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_create_params_t),
            "::",
            stringify!(pdesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_create_params_t>())).pphPhysicalMemory
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_create_params_t),
            "::",
            stringify!(pphPhysicalMemory)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zePhysicalMemCreate"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_physical_mem_create_params_t = _ze_physical_mem_create_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zePhysicalMemCreate"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnPhysicalMemCreateCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_physical_mem_create_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zePhysicalMemDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_physical_mem_destroy_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phPhysicalMemory: *mut ze_physical_mem_handle_t,
}
#[test]
fn bindgen_test_layout__ze_physical_mem_destroy_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_physical_mem_destroy_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_physical_mem_destroy_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_physical_mem_destroy_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_physical_mem_destroy_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_destroy_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_destroy_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_destroy_params_t>())).phPhysicalMemory
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_destroy_params_t),
            "::",
            stringify!(phPhysicalMemory)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zePhysicalMemDestroy"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_physical_mem_destroy_params_t = _ze_physical_mem_destroy_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zePhysicalMemDestroy"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnPhysicalMemDestroyCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_physical_mem_destroy_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of PhysicalMem callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_physical_mem_callbacks_t {
    pub pfnCreateCb: ze_pfnPhysicalMemCreateCb_t,
    pub pfnDestroyCb: ze_pfnPhysicalMemDestroyCb_t,
}
#[test]
fn bindgen_test_layout__ze_physical_mem_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_physical_mem_callbacks_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_physical_mem_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_physical_mem_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_physical_mem_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_callbacks_t>())).pfnCreateCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_callbacks_t),
            "::",
            stringify!(pfnCreateCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_physical_mem_callbacks_t>())).pfnDestroyCb as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_physical_mem_callbacks_t),
            "::",
            stringify!(pfnDestroyCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of PhysicalMem callback functions pointers"]
pub type ze_physical_mem_callbacks_t = _ze_physical_mem_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocShared"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_alloc_shared_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pdevice_desc: *mut *const ze_device_mem_alloc_desc_t,
    pub phost_desc: *mut *const ze_host_mem_alloc_desc_t,
    pub psize: *mut usize,
    pub palignment: *mut usize,
    pub phDevice: *mut ze_device_handle_t,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_alloc_shared_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_alloc_shared_params_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_mem_alloc_shared_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_alloc_shared_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_alloc_shared_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).pdevice_desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(pdevice_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).phost_desc as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(phost_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).psize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).palignment as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(palignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).phDevice as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_shared_params_t>())).ppptr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_shared_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocShared"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_alloc_shared_params_t = _ze_mem_alloc_shared_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemAllocShared"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemAllocSharedCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_alloc_shared_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocDevice"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_alloc_device_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pdevice_desc: *mut *const ze_device_mem_alloc_desc_t,
    pub psize: *mut usize,
    pub palignment: *mut usize,
    pub phDevice: *mut ze_device_handle_t,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_alloc_device_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_alloc_device_params_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ze_mem_alloc_device_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_alloc_device_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_alloc_device_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).pdevice_desc as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(pdevice_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).palignment as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(palignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).phDevice as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_device_params_t>())).ppptr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_device_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocDevice"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_alloc_device_params_t = _ze_mem_alloc_device_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemAllocDevice"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemAllocDeviceCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_alloc_device_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocHost"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_alloc_host_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phost_desc: *mut *const ze_host_mem_alloc_desc_t,
    pub psize: *mut usize,
    pub palignment: *mut usize,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_alloc_host_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_alloc_host_params_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_mem_alloc_host_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_alloc_host_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_alloc_host_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_host_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_host_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_host_params_t>())).phost_desc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_host_params_t),
            "::",
            stringify!(phost_desc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_host_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_host_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_host_params_t>())).palignment as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_host_params_t),
            "::",
            stringify!(palignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_alloc_host_params_t>())).ppptr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_alloc_host_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemAllocHost"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_alloc_host_params_t = _ze_mem_alloc_host_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemAllocHost"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemAllocHostCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_alloc_host_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemFree"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_free_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_free_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_free_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_mem_free_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_free_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_free_params_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_mem_free_params_t>())).phContext as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_free_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_mem_free_params_t>())).pptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_free_params_t),
            "::",
            stringify!(pptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemFree"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_free_params_t = _ze_mem_free_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemFree"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemFreeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_free_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetAllocProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_get_alloc_properties_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub ppMemAllocProperties: *mut *mut ze_memory_allocation_properties_t,
    pub pphDevice: *mut *mut ze_device_handle_t,
}
#[test]
fn bindgen_test_layout__ze_mem_get_alloc_properties_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_get_alloc_properties_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_mem_get_alloc_properties_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_get_alloc_properties_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_mem_get_alloc_properties_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_alloc_properties_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_alloc_properties_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_alloc_properties_params_t>())).pptr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_alloc_properties_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_alloc_properties_params_t>())).ppMemAllocProperties
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_alloc_properties_params_t),
            "::",
            stringify!(ppMemAllocProperties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_alloc_properties_params_t>())).pphDevice as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_alloc_properties_params_t),
            "::",
            stringify!(pphDevice)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetAllocProperties"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_get_alloc_properties_params_t = _ze_mem_get_alloc_properties_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemGetAllocProperties"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemGetAllocPropertiesCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_get_alloc_properties_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetAddressRange"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_get_address_range_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub ppBase: *mut *mut *mut ::std::os::raw::c_void,
    pub ppSize: *mut *mut usize,
}
#[test]
fn bindgen_test_layout__ze_mem_get_address_range_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_get_address_range_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_mem_get_address_range_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_get_address_range_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_mem_get_address_range_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_address_range_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_address_range_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_address_range_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_address_range_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_address_range_params_t>())).ppBase as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_address_range_params_t),
            "::",
            stringify!(ppBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_address_range_params_t>())).ppSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_address_range_params_t),
            "::",
            stringify!(ppSize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetAddressRange"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_get_address_range_params_t = _ze_mem_get_address_range_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemGetAddressRange"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemGetAddressRangeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_get_address_range_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_get_ipc_handle_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub ppIpcHandle: *mut *mut ze_ipc_mem_handle_t,
}
#[test]
fn bindgen_test_layout__ze_mem_get_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_get_ipc_handle_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_mem_get_ipc_handle_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_get_ipc_handle_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_get_ipc_handle_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_ipc_handle_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_ipc_handle_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_ipc_handle_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_ipc_handle_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_get_ipc_handle_params_t>())).ppIpcHandle as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_get_ipc_handle_params_t),
            "::",
            stringify!(ppIpcHandle)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemGetIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_get_ipc_handle_params_t = _ze_mem_get_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemGetIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemGetIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_get_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemOpenIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_open_ipc_handle_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub phandle: *mut ze_ipc_mem_handle_t,
    pub pflags: *mut ze_ipc_memory_flags_t,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_open_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_open_ipc_handle_params_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_mem_open_ipc_handle_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_open_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_mem_open_ipc_handle_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_open_ipc_handle_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_open_ipc_handle_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_open_ipc_handle_params_t>())).phDevice as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_open_ipc_handle_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_open_ipc_handle_params_t>())).phandle as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_open_ipc_handle_params_t),
            "::",
            stringify!(phandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_open_ipc_handle_params_t>())).pflags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_open_ipc_handle_params_t),
            "::",
            stringify!(pflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_open_ipc_handle_params_t>())).ppptr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_open_ipc_handle_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemOpenIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_open_ipc_handle_params_t = _ze_mem_open_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemOpenIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemOpenIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_open_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemCloseIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_mem_close_ipc_handle_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_mem_close_ipc_handle_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_close_ipc_handle_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_mem_close_ipc_handle_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_close_ipc_handle_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_mem_close_ipc_handle_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_close_ipc_handle_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_close_ipc_handle_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_close_ipc_handle_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_close_ipc_handle_params_t),
            "::",
            stringify!(pptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeMemCloseIpcHandle"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_mem_close_ipc_handle_params_t = _ze_mem_close_ipc_handle_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeMemCloseIpcHandle"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnMemCloseIpcHandleCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_mem_close_ipc_handle_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of Mem callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_mem_callbacks_t {
    pub pfnAllocSharedCb: ze_pfnMemAllocSharedCb_t,
    pub pfnAllocDeviceCb: ze_pfnMemAllocDeviceCb_t,
    pub pfnAllocHostCb: ze_pfnMemAllocHostCb_t,
    pub pfnFreeCb: ze_pfnMemFreeCb_t,
    pub pfnGetAllocPropertiesCb: ze_pfnMemGetAllocPropertiesCb_t,
    pub pfnGetAddressRangeCb: ze_pfnMemGetAddressRangeCb_t,
    pub pfnGetIpcHandleCb: ze_pfnMemGetIpcHandleCb_t,
    pub pfnOpenIpcHandleCb: ze_pfnMemOpenIpcHandleCb_t,
    pub pfnCloseIpcHandleCb: ze_pfnMemCloseIpcHandleCb_t,
}
#[test]
fn bindgen_test_layout__ze_mem_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_mem_callbacks_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ze_mem_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_mem_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_mem_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnAllocSharedCb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnAllocSharedCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnAllocDeviceCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnAllocDeviceCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnAllocHostCb as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnAllocHostCb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnFreeCb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnFreeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnGetAllocPropertiesCb as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnGetAllocPropertiesCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnGetAddressRangeCb as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnGetAddressRangeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnGetIpcHandleCb as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnGetIpcHandleCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnOpenIpcHandleCb as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnOpenIpcHandleCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_mem_callbacks_t>())).pfnCloseIpcHandleCb as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_mem_callbacks_t),
            "::",
            stringify!(pfnCloseIpcHandleCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of Mem callback functions pointers"]
pub type ze_mem_callbacks_t = _ze_mem_callbacks_t;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemReserve"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_reserve_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub ppStart: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub ppptr: *mut *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_reserve_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_reserve_params_t>(),
        32usize,
        concat!("Size of: ", stringify!(_ze_virtual_mem_reserve_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_reserve_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_virtual_mem_reserve_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_reserve_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_reserve_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_reserve_params_t>())).ppStart as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_reserve_params_t),
            "::",
            stringify!(ppStart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_reserve_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_reserve_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_reserve_params_t>())).ppptr as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_reserve_params_t),
            "::",
            stringify!(ppptr)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemReserve"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_reserve_params_t = _ze_virtual_mem_reserve_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemReserve"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemReserveCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_reserve_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemFree"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_free_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_free_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_free_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_virtual_mem_free_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_free_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_virtual_mem_free_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_free_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_free_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_free_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_free_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_free_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_free_params_t),
            "::",
            stringify!(psize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemFree"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_free_params_t = _ze_virtual_mem_free_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemFree"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemFreeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_free_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemQueryPageSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_query_page_size_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub phDevice: *mut ze_device_handle_t,
    pub psize: *mut usize,
    pub ppagesize: *mut *mut usize,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_query_page_size_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_query_page_size_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_virtual_mem_query_page_size_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_query_page_size_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_virtual_mem_query_page_size_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_query_page_size_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_query_page_size_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_query_page_size_params_t>())).phDevice
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_query_page_size_params_t),
            "::",
            stringify!(phDevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_query_page_size_params_t>())).psize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_query_page_size_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_query_page_size_params_t>())).ppagesize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_query_page_size_params_t),
            "::",
            stringify!(ppagesize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemQueryPageSize"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_query_page_size_params_t = _ze_virtual_mem_query_page_size_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemQueryPageSize"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemQueryPageSizeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_query_page_size_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemMap"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_map_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub phPhysicalMemory: *mut ze_physical_mem_handle_t,
    pub poffset: *mut usize,
    pub paccess: *mut ze_memory_access_attribute_t,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_map_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_map_params_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ze_virtual_mem_map_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_map_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_virtual_mem_map_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).phContext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).phPhysicalMemory as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(phPhysicalMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).poffset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(poffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_map_params_t>())).paccess as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_map_params_t),
            "::",
            stringify!(paccess)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemMap"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_map_params_t = _ze_virtual_mem_map_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemMap"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemMapCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_map_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemUnmap"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_unmap_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_unmap_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_unmap_params_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_virtual_mem_unmap_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_unmap_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_virtual_mem_unmap_params_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_unmap_params_t>())).phContext as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_unmap_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_unmap_params_t>())).pptr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_unmap_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_unmap_params_t>())).psize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_unmap_params_t),
            "::",
            stringify!(psize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemUnmap"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_unmap_params_t = _ze_virtual_mem_unmap_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemUnmap"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemUnmapCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_unmap_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemSetAccessAttribute"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_set_access_attribute_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub paccess: *mut ze_memory_access_attribute_t,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_set_access_attribute_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_set_access_attribute_params_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_set_access_attribute_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_set_access_attribute_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_set_access_attribute_params_t>())).pptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_set_access_attribute_params_t>())).psize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_set_access_attribute_params_t>())).paccess
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_set_access_attribute_params_t),
            "::",
            stringify!(paccess)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemSetAccessAttribute"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_set_access_attribute_params_t =
    _ze_virtual_mem_set_access_attribute_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemSetAccessAttribute"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemSetAccessAttributeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_set_access_attribute_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemGetAccessAttribute"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_virtual_mem_get_access_attribute_params_t {
    pub phContext: *mut ze_context_handle_t,
    pub pptr: *mut *const ::std::os::raw::c_void,
    pub psize: *mut usize,
    pub paccess: *mut *mut ze_memory_access_attribute_t,
    pub poutSize: *mut *mut usize,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_get_access_attribute_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_get_access_attribute_params_t>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_get_access_attribute_params_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_get_access_attribute_params_t>())).phContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t),
            "::",
            stringify!(phContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_get_access_attribute_params_t>())).pptr
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t),
            "::",
            stringify!(pptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_get_access_attribute_params_t>())).psize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t),
            "::",
            stringify!(psize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_get_access_attribute_params_t>())).paccess
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t),
            "::",
            stringify!(paccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_get_access_attribute_params_t>())).poutSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_get_access_attribute_params_t),
            "::",
            stringify!(poutSize)
        )
    );
}
#[doc = ""]
#[doc = " @brief Callback function parameters for zeVirtualMemGetAccessAttribute"]
#[doc = " @details Each entry is a pointer to the parameter passed to the function;"]
#[doc = "     allowing the callback the ability to modify the parameter's value"]
pub type ze_virtual_mem_get_access_attribute_params_t =
    _ze_virtual_mem_get_access_attribute_params_t;
#[doc = ""]
#[doc = " @brief Callback function-pointer for zeVirtualMemGetAccessAttribute"]
#[doc = " @param[in] params Parameters passed to this instance"]
#[doc = " @param[in] result Return value"]
#[doc = " @param[in] pTracerUserData Per-Tracer user data"]
#[doc = " @param[in,out] ppTracerInstanceUserData Per-Tracer, Per-Instance user data"]
pub type ze_pfnVirtualMemGetAccessAttributeCb_t = ::std::option::Option<
    unsafe extern "C" fn(
        params: *mut ze_virtual_mem_get_access_attribute_params_t,
        result: ze_result_t,
        pTracerUserData: *mut ::std::os::raw::c_void,
        ppTracerInstanceUserData: *mut *mut ::std::os::raw::c_void,
    ),
>;
#[doc = ""]
#[doc = " @brief Table of VirtualMem callback functions pointers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_virtual_mem_callbacks_t {
    pub pfnReserveCb: ze_pfnVirtualMemReserveCb_t,
    pub pfnFreeCb: ze_pfnVirtualMemFreeCb_t,
    pub pfnQueryPageSizeCb: ze_pfnVirtualMemQueryPageSizeCb_t,
    pub pfnMapCb: ze_pfnVirtualMemMapCb_t,
    pub pfnUnmapCb: ze_pfnVirtualMemUnmapCb_t,
    pub pfnSetAccessAttributeCb: ze_pfnVirtualMemSetAccessAttributeCb_t,
    pub pfnGetAccessAttributeCb: ze_pfnVirtualMemGetAccessAttributeCb_t,
}
#[test]
fn bindgen_test_layout__ze_virtual_mem_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_virtual_mem_callbacks_t>(),
        56usize,
        concat!("Size of: ", stringify!(_ze_virtual_mem_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_virtual_mem_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_virtual_mem_callbacks_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnReserveCb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnReserveCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnFreeCb as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnFreeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnQueryPageSizeCb as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnQueryPageSizeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnMapCb as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnMapCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnUnmapCb as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnUnmapCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnSetAccessAttributeCb
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnSetAccessAttributeCb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_virtual_mem_callbacks_t>())).pfnGetAccessAttributeCb
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_virtual_mem_callbacks_t),
            "::",
            stringify!(pfnGetAccessAttributeCb)
        )
    );
}
#[doc = ""]
#[doc = " @brief Table of VirtualMem callback functions pointers"]
pub type ze_virtual_mem_callbacks_t = _ze_virtual_mem_callbacks_t;
#[doc = ""]
#[doc = " @brief Container for all callbacks"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ze_callbacks_t {
    pub Global: ze_global_callbacks_t,
    pub Driver: ze_driver_callbacks_t,
    pub Device: ze_device_callbacks_t,
    pub Context: ze_context_callbacks_t,
    pub CommandQueue: ze_command_queue_callbacks_t,
    pub CommandList: ze_command_list_callbacks_t,
    pub Fence: ze_fence_callbacks_t,
    pub EventPool: ze_event_pool_callbacks_t,
    pub Event: ze_event_callbacks_t,
    pub Image: ze_image_callbacks_t,
    pub Module: ze_module_callbacks_t,
    pub ModuleBuildLog: ze_module_build_log_callbacks_t,
    pub Kernel: ze_kernel_callbacks_t,
    pub Sampler: ze_sampler_callbacks_t,
    pub PhysicalMem: ze_physical_mem_callbacks_t,
    pub Mem: ze_mem_callbacks_t,
    pub VirtualMem: ze_virtual_mem_callbacks_t,
}
#[test]
fn bindgen_test_layout__ze_callbacks_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_callbacks_t>(),
        960usize,
        concat!("Size of: ", stringify!(_ze_callbacks_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_callbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_callbacks_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Driver as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Driver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Device as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Context as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).CommandQueue as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(CommandQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).CommandList as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(CommandList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Fence as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Fence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).EventPool as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(EventPool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Event as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Image as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Image)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Module as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Module)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).ModuleBuildLog as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(ModuleBuildLog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Kernel as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Kernel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Sampler as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Sampler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).PhysicalMem as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(PhysicalMem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).Mem as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(Mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_callbacks_t>())).VirtualMem as *const _ as usize },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_callbacks_t),
            "::",
            stringify!(VirtualMem)
        )
    );
}
#[doc = ""]
#[doc = " @brief Container for all callbacks"]
pub type ze_callbacks_t = _ze_callbacks_t;
