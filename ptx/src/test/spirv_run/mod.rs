use super::read_test_file;
use crate::pass;
use cuda_types::cuda::CUstream;
use hip_runtime_sys::hipError_t;
use pretty_assertions;
use std::env;
use std::error;
use std::ffi::{CStr, CString};
use std::fmt::{self, Debug, Display, Formatter};
use std::fs::{self, File};
use std::io::Write;
use std::mem;
use std::path::Path;
use std::ptr;
use std::str;

macro_rules! test_ptx_llvm {
    ($fn_name:ident) => {
        paste::item! {
            #[test]
            fn [<$fn_name _llvm>]() -> Result<(), Box<dyn std::error::Error>> {
                let ptx = read_test_file!(concat!(stringify!($fn_name), ".ptx"));
                let ll = read_test_file!(concat!("../ll/", stringify!($fn_name), ".ll"));
                test_llvm_assert(stringify!($fn_name), &ptx, ll.trim())
            }
        }
    };
}

macro_rules! test_ptx {
    ($fn_name:ident, $input:expr, $output:expr) => {
        paste::item! {
            #[test]
            fn [<$fn_name _amdgpu>]() -> Result<(), Box<dyn std::error::Error>> {
                let ptx = read_test_file!(concat!(stringify!($fn_name), ".ptx"));
                let input = $input;
                let output = $output;
                test_hip_assert(stringify!($fn_name), &ptx, Some(&input), &output, 1)
            }
        }

        paste::item! {
            #[test]
            fn [<$fn_name _cuda>]() -> Result<(), Box<dyn std::error::Error>> {
                let ptx = read_test_file!(concat!(stringify!($fn_name), ".ptx"));
                let input = $input;
                let output = $output;
                test_cuda_assert(stringify!($fn_name), &ptx, Some(&input), &output, 1)
            }
        }

        test_ptx_llvm!($fn_name);
    };

    ($fn_name:ident) => {
        test_ptx_llvm!($fn_name);
    };
}

macro_rules! test_ptx_warp {
    ($fn_name:ident, $output:expr) => {
        paste::item! {
            #[test]
            fn [<$fn_name _amdgpu>]() -> Result<(), Box<dyn std::error::Error>> {
                let ptx = read_test_file!(concat!(stringify!($fn_name), ".ptx"));
                let mut output = $output;
                test_hip_assert(stringify!($fn_name), &ptx, None::<&[u8]>, &mut output, 64)
            }
        }

        paste::item! {
            #[test]
            fn [<$fn_name _cuda>]() -> Result<(), Box<dyn std::error::Error>> {
                let ptx = read_test_file!(concat!(stringify!($fn_name), ".ptx"));
                let mut output = $output;
                test_cuda_assert(stringify!($fn_name), &ptx, None::<&[u8]>, &mut output, 64)
            }
        }

        test_ptx_llvm!($fn_name);
    };
}

test_ptx!(ld_st, [1u64], [1u64]);
test_ptx!(ld_st_implicit, [0.5f32, 0.25f32], [0.5f32]);
test_ptx!(mov, [1u64], [1u64]);
test_ptx!(mul_lo, [1u64], [2u64]);
test_ptx!(mul_hi, [u64::max_value()], [1u64]);
test_ptx!(add, [1u64], [2u64]);
test_ptx!(
    mul24_lo_u32,
    [0b01110101_01010101_01010101u32],
    [0b00011100_00100011_10001110_00111001u32]
);
test_ptx!(
    mul24_hi_u32,
    [0b01110101_01010101_01010101u32],
    [0b00110101_11000111_00011100_00100011u32]
);
test_ptx!(
    mul24_lo_s32,
    [0b01110101_01010101_01010101i32],
    [-0b0011100_00100011_10001110_00111001i32]
);
test_ptx!(
    mul24_hi_s32,
    [0b01110101_01010101_01010101i32],
    [-0b0110101_11000111_00011100_00100100i32]
);
test_ptx!(setp, [10u64, 11u64], [1u64, 0u64]);
test_ptx!(setp_gt, [f32::NAN, 1f32], [1f32]);
test_ptx!(setp_leu, [1f32, f32::NAN], [1f32]);
test_ptx!(bra, [10u64], [11u64]);
test_ptx!(not, [0u64], [u64::max_value()]);
test_ptx!(shl, [11u64], [44u64]);
test_ptx!(
    cvt_pack,
    [-257i32, 257i32, -130436883i32],
    [2968322303u32, 2968354943]
);
test_ptx!(cvt_sat_s_u, [-1i32], [0i32]);
test_ptx!(cvta, [3.0f32], [3.0f32]);
test_ptx!(block, [1u64], [2u64]);
test_ptx!(local_align, [1u64], [1u64]);
test_ptx!(call, [1u64], [2u64]);
test_ptx!(vector, [1u32, 2u32], [3u32, 3u32]);
test_ptx!(vector4, [1u32, 2u32, 3u32, 4u32], [4u32]);
test_ptx!(
    vector8,
    [1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32],
    [8u32]
);
test_ptx!(ld_st_offset, [1u32, 2u32], [2u32, 1u32]);
test_ptx!(ntid, [3u32], [4u32]);
test_ptx!(reg_local, [12u64], [13u64]);
test_ptx!(reg_multi, [123u32, 456u32], [123u32, 456u32]);
test_ptx!(mov_address, [0xDEADu64], [0u64]);
test_ptx!(b64tof64, [111u64], [111u64]);
// This segfaults NV compiler
// test_ptx!(implicit_param, [34u32], [34u32]);
test_ptx!(pred_not, [10u64, 11u64], [2u64, 0u64]);
test_ptx!(mad_s32, [2i32, 3i32, 4i32], [10i32]);
test_ptx!(mad_wide, [-1i32, 3, 4, 5], [21474836481i64]);
test_ptx!(
    mul_wide,
    [0x01_00_00_00__01_00_00_00i64],
    [0x1_00_00_00_00_00_00i64]
);
test_ptx!(vector_extract, [1u8, 2u8, 3u8, 4u8], [3u8, 4u8, 1u8, 2u8]);
test_ptx!(
    vector8_extract,
    [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8],
    [8u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8]
);
test_ptx!(vector_operand, [0x1234u16], [0x12345678]);
test_ptx!(shr, [-2i32], [-1i32]);
test_ptx!(shr_oob, [-32768i16], [-1i16]);
test_ptx!(or, [1u64, 2u64], [3u64]);
test_ptx!(sub, [2u64], [1u64]);
test_ptx!(min, [555i32, 444i32], [444i32]);
test_ptx!(
    min_f16,
    [half::f16::NAN, half::f16::from_f64(123.0)],
    [half::f16::from_f64(123.0)]
);
test_ptx!(min_nan_f16);
test_ptx!(max, [555i32, 444i32], [555i32]);
test_ptx!(global_array, [0xDEADu32], [1u32]);
test_ptx!(global_array_f32, [0x0], [0f32]);
test_ptx!(extern_shared, [127u64], [127u64]);
test_ptx!(extern_shared_call, [121u64], [123u64]);
test_ptx!(rcp, [2f32], [0.5f32]);
// 0b1_00000000_10000000000000000000000u32 is a large denormal
// 0x3f000000 is 0.5
test_ptx!(
    mul_ftz,
    [0b1_00000000_10000000000000000000000u32, 0x3f000000u32],
    [0b1_00000000_00000000000000000000000u32]
);
test_ptx!(
    mul_non_ftz,
    [0b1_00000000_10000000000000000000000u32, 0x3f000000u32],
    [0b1_00000000_01000000000000000000000u32]
);
test_ptx!(constant_f32, [10f32], [5f32]);
test_ptx!(abs, [i32::MIN], [i32::MIN]);
test_ptx!(constant_negative, [-101i32], [101i32]);
test_ptx!(and, [6u32, 3u32], [2u32]);
test_ptx!(selp, [100u16, 200u16], [200u16]);
test_ptx!(selp_true, [100u16, 200u16], [100u16]);
test_ptx!(fma, [2f32, 3f32, 5f32], [11f32]);
test_ptx!(
    fma_bf16x2,
    [0x40004040, 0x40404080, 0x40A04040],
    [0x41304170]
);
test_ptx!(
    fma_f16x2,
    [0x40004040, 0x40404080, 0x40A04040],
    [1183860456u32]
);
test_ptx!(shared_variable, [513u64], [513u64]);
test_ptx!(shared_ptr_32, [513u64], [513u64]);
test_ptx!(atom_cas, [91u32, 91u32], [91u32, 100u32]);
test_ptx!(atom_inc, [100u32], [100u32, 101u32, 0u32]);
test_ptx!(atom_add, [2u32, 4u32], [2u32, 6u32]);
test_ptx!(div_approx, [1f32, 2f32], [0.5f32]);
test_ptx!(sqrt, [0.25f32], [0.5f32]);
test_ptx!(sqrt_rn_ftz, [0x1u32], [0x0u32]);
test_ptx!(rsqrt, [0.25f64], [2f64]);
test_ptx!(neg, [181i32], [-181i32]);
test_ptx!(sin, [std::f32::consts::PI / 2f32], [1f32]);
test_ptx!(cos, [std::f32::consts::PI], [-1f32]);
test_ptx!(lg2, [512f32], [9f32]);
test_ptx!(ex2, [10f32], [1024f32]);
test_ptx!(fmax, [0u16, half::f16::NAN.to_bits()], [0u16]);
test_ptx!(cvt_rni, [9.5f32, 10.5f32], [10f32, 10f32]);
test_ptx!(cvt_rzi, [-13.8f32, 12.9f32], [-13f32, 12f32]);
test_ptx!(cvt_s32_f32, [-13.8f32, 12.9f32], [-13i32, 13i32]);
test_ptx!(cvt_rni_u16_f32, [0x477FFF80u32], [65535u16]);
test_ptx!(cvt_rn_satfinite_e4m3x2_f32, [0.40625, 12.9f32], [0x2D55u16]);
test_ptx!(
    cvt_rn_satfinite_e5m2x2_f32,
    [0.375, -5256.6f32],
    [0x36EDu16]
);
test_ptx!(cvt_rn_f16x2_e4m3x2, [0x2D55u16], [0x36804a80u32]);
test_ptx!(cvt_rn_f16x2_e5m2x2, [0x36EDu16], [0x3600ED00u32]);
test_ptx!(cvt_rn_bf16x2_f32, [0.40625, 12.9f32], [0x3ED0414Eu32]);
test_ptx!(clz, [0b00000101_00101101_00010011_10101011u32], [5u32]);
test_ptx!(popc, [0b10111100_10010010_01001001_10001010u32], [14u32]);
test_ptx!(
    brev,
    [0b11000111_01011100_10101110_11111011u32],
    [0b11011111_01110101_00111010_11100011u32]
);
test_ptx!(
    xor,
    [
        0b01010010_00011010_01000000_00001101u32,
        0b11100110_10011011_00001100_00100011u32
    ],
    [0b10110100100000010100110000101110u32]
);
test_ptx!(rem, [21692i32, 13i32], [8i32]);
test_ptx!(
    bfe,
    [0b11111000_11000001_00100010_10100000u32, 16u32, 8u32],
    [0b11000001u32]
);
test_ptx!(bfi, [0b10u32, 0b101u32, 0u32, 2u32], [0b110u32]);
test_ptx!(stateful_ld_st_simple, [121u64], [121u64]);
test_ptx!(stateful_ld_st_ntid, [123u64], [123u64]);
test_ptx!(stateful_ld_st_ntid_chain, [12651u64], [12651u64]);
test_ptx!(stateful_ld_st_ntid_sub, [96311u64], [96311u64]);
test_ptx!(shared_ptr_take_address, [97815231u64], [97815231u64]);
test_ptx!(cvt_s64_s32, [-1i32], [-1i64]);
test_ptx!(add_tuning, [2u64], [3u64]);
test_ptx!(add_non_coherent, [3u64], [4u64]);
test_ptx!(sign_extend, [-1i16], [-1i32]);
test_ptx!(atom_add_float, [1.25f32, 0.5f32], [1.25f32, 1.75f32]);
test_ptx!(
    setp_nan,
    [
        0.5f32,
        f32::NAN,
        f32::NAN,
        0.5f32,
        f32::NAN,
        f32::NAN,
        0.5f32,
        0.5f32
    ],
    [1u32, 1u32, 1u32, 0u32]
);
test_ptx!(
    setp_num,
    [
        0.5f32,
        f32::NAN,
        f32::NAN,
        0.5f32,
        f32::NAN,
        f32::NAN,
        0.5f32,
        0.5f32
    ],
    [0u32, 0u32, 0u32, 2u32]
);
test_ptx!(non_scalar_ptr_offset, [1u32, 2u32, 3u32, 4u32], [7u32]);
test_ptx!(stateful_neg_offset, [1237518u64], [1237518u64]);
test_ptx!(const, [0u16], [10u16, 20, 30, 40]);
test_ptx!(const_ident, [0u16], [0u64, 0u64]);
test_ptx!(cvt_s16_s8, [0x139231C2u32], [0xFFFFFFC2u32]);
test_ptx!(cvt_f64_f32, [0.125f32], [0.125f64]);
test_ptx!(prmt, [0x70c507d6u32, 0x6fbd4b5cu32], [0x6fbdd65cu32]);
test_ptx!(
    prmt_slow,
    [0x70c507d6u32, 0x6fbd4b5cu32, 30212],
    [0x6fbdd65cu32]
);
test_ptx!(activemask, [0u32], [1u32]);
test_ptx!(membar, [152731u32], [152731u32]);
test_ptx!(shared_unify_extern, [7681u64, 7682u64], [15363u64]);
test_ptx!(shared_unify_local, [16752u64, 714u64], [17466u64]);
// FIXME: This test currently fails for reasons outside of ZLUDA's control.
// One of the LLVM passes does not understand that setreg instruction changes
// global floating point state and assumes that both floating point
// additions are the exact same expressions and optimizes second addition away.
// test_ptx!(
//     add_ftz,
//     [f32::from_bits(0x800000), f32::from_bits(0x007FFFFF)],
//     [0x800000u32, 0xFFFFFF]
// );
test_ptx!(add_s32_sat, [i32::MIN, -1], [i32::MIN, i32::MAX]);
test_ptx!(malformed_label, [2u64], [3u64]);
test_ptx!(
    call_rnd,
    [
        1.0f32,
        f32::from_bits(0x33800000),
        1.0f32,
        f32::from_bits(0x33800000)
    ],
    [1.0000001, 1.0f32]
);
test_ptx!(multiple_return, [5u32], [6u32, 123u32]);
test_ptx!(warp_sz, [0u8], [32u8]);
test_ptx!(tanh, [f32::INFINITY], [1.0f32]);
test_ptx!(cp_async, [0u32], [1u32, 2u32, 3u32, 0u32]);
// Two test below test very important compiler feature, make sure that you
// understand fully what's going on before you touch it.
// The problem is that the full-precision division gets legalized by LLVM
// using __module attribute__.
// In the two tests below we deliberately force our compiler to emit
// different a module that has a different module-level denormal attribute
// from the denormal attribute of the instruction to catch cases like this
test_ptx!(div_ftz, [0x16A2028Du32, 0x5E89F6AE], [0x0, 900636404u32]);
test_ptx!(
    div_noftz,
    [0x16A2028Du32, 0x5E89F6AE],
    [0x26u32, 900636404u32]
);

test_ptx!(nanosleep, [0u64], [0u64]);
test_ptx!(shf_l, [0x12345678u32, 0x9abcdef0u32, 12], [0xcdef0123u32]);
test_ptx!(shf_r, [0x12345678u32, 0x9abcdef0u32, 12], [0xef012345u32]);
test_ptx!(
    shf_l_clamp,
    [0x12345678u32, 0x9abcdef0u32, 44],
    [0x12345678u32]
);
test_ptx!(
    shf_r_clamp,
    [0x12345678u32, 0x9abcdef0u32, 44],
    [0x9abcdef0u32]
);
test_ptx!(
    shf_l_wrap,
    [0x12345678u32, 0x9abcdef0u32, 44],
    [0xcdef0123u32]
);
test_ptx!(
    shf_r_wrap,
    [0x12345678u32, 0x9abcdef0u32, 44],
    [0xef012345u32]
);
test_ptx!(
    dp4a,
    [0x8e2da590u32, 0xedeaee14, 0x248a9f70],
    [613065134u32]
);
test_ptx!(param_is_addressable, [0xDEAD], [0u64]);
// TODO: re-enable when we have a patched LLVM
//test_ptx!(
//    atomics_128,
//    [0xce16728dead1ceb0u64, 0xe7728e3c390b7fb7],
//    [0xce16728dead1ceb1u64, 0xe7728e3c390b7fb8]
//);
test_ptx!(copysign, [0x0BDA2A2Cu32, 0xe31a8fd7u32], [0x631A8FD7u32]);
test_ptx!(cvt_f16x2_f32, [1.0f32, 2.0f32], [0x3C004000u32]);
test_ptx!(
    cvt_relu_f16x2_f32,
    // Not testing for NaN because AMDG GPUs returns a different NaN
    [-1.0f32, 1.0f32, 3.14, f32::NEG_INFINITY],
    [15360u32, 1112014848]
);
test_ptx!(
    set_f16,
    [
        half::f16::NAN,
        half::f16::NAN,
        half::f16::from_f32(3.14),
        half::f16::NEG_INFINITY,
        half::f16::from_f32(-0.0),
        half::f16::from_f32(0.0)
    ],
    [4294967295u32, 65535]
);

test_ptx!(assertfail);
// TODO: not yet supported
//test_ptx!(func_ptr);
test_ptx!(lanemask_lt);
test_ptx!(extern_func);
test_ptx!(trap);
test_ptx!(noreturn);
test_ptx!(createpolicy);

test_ptx_warp!(
    tid,
    [
        0u8, 1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8, 13u8, 14u8, 15u8, 16u8,
        17u8, 18u8, 19u8, 20u8, 21u8, 22u8, 23u8, 24u8, 25u8, 26u8, 27u8, 28u8, 29u8, 30u8, 31u8,
        32u8, 33u8, 34u8, 35u8, 36u8, 37u8, 38u8, 39u8, 40u8, 41u8, 42u8, 43u8, 44u8, 45u8, 46u8,
        47u8, 48u8, 49u8, 50u8, 51u8, 52u8, 53u8, 54u8, 55u8, 56u8, 57u8, 58u8, 59u8, 60u8, 61u8,
        62u8, 63u8,
    ]
);
test_ptx_warp!(
    bar_red_and_pred,
    [
        2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32,
        2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32,
        2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32,
        2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32, 2u32,
        2u32, 2u32, 2u32, 2u32,
    ]
);
test_ptx_warp!(
    shfl_sync_up_b32_pred,
    [
        1000u32, 1001u32, 1002u32, 0u32, 1u32, 2u32, 3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32,
        10u32, 11u32, 12u32, 13u32, 14u32, 15u32, 16u32, 17u32, 18u32, 19u32, 20u32, 21u32, 22u32,
        23u32, 24u32, 25u32, 26u32, 27u32, 28u32, 1032u32, 1033u32, 1034u32, 32u32, 33u32, 34u32,
        35u32, 36u32, 37u32, 38u32, 39u32, 40u32, 41u32, 42u32, 43u32, 44u32, 45u32, 46u32, 47u32,
        48u32, 49u32, 50u32, 51u32, 52u32, 53u32, 54u32, 55u32, 56u32, 57u32, 58u32, 59u32, 60u32,
    ]
);
test_ptx_warp!(
    shfl_sync_down_b32_pred,
    [
        3u32, 4u32, 5u32, 6u32, 7u32, 8u32, 9u32, 10u32, 11u32, 12u32, 13u32, 14u32, 15u32, 16u32,
        17u32, 18u32, 19u32, 20u32, 21u32, 22u32, 23u32, 24u32, 25u32, 26u32, 27u32, 28u32, 29u32,
        30u32, 31u32, 1029u32, 1030u32, 1031u32, 35u32, 36u32, 37u32, 38u32, 39u32, 40u32, 41u32,
        42u32, 43u32, 44u32, 45u32, 46u32, 47u32, 48u32, 49u32, 50u32, 51u32, 52u32, 53u32, 54u32,
        55u32, 56u32, 57u32, 58u32, 59u32, 60u32, 61u32, 62u32, 63u32, 1061u32, 1062u32, 1063u32,
    ]
);
test_ptx_warp!(
    shfl_sync_bfly_b32_pred,
    [
        3u32, 2u32, 1u32, 0u32, 7u32, 6u32, 5u32, 4u32, 11u32, 10u32, 9u32, 8u32, 15u32, 14u32,
        13u32, 12u32, 19u32, 18u32, 17u32, 16u32, 23u32, 22u32, 21u32, 20u32, 27u32, 26u32, 25u32,
        24u32, 31u32, 30u32, 29u32, 28u32, 35u32, 34u32, 33u32, 32u32, 39u32, 38u32, 37u32, 36u32,
        43u32, 42u32, 41u32, 40u32, 47u32, 46u32, 45u32, 44u32, 51u32, 50u32, 49u32, 48u32, 55u32,
        54u32, 53u32, 52u32, 59u32, 58u32, 57u32, 56u32, 63u32, 62u32, 61u32, 60u32,
    ]
);
test_ptx_warp!(
    shfl_sync_idx_b32_pred,
    [
        12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32,
        12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 12u32,
        12u32, 12u32, 12u32, 12u32, 12u32, 12u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32,
        44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32,
        44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32, 44u32,
    ]
);
test_ptx_warp!(
    shfl_sync_mode_b32,
    [
        9u32, 7u32, 8u32, 9u32, 21u32, 19u32, 20u32, 21u32, 33u32, 31u32, 32u32, 33u32, 45u32,
        43u32, 44u32, 45u32, 73u32, 71u32, 72u32, 73u32, 85u32, 83u32, 84u32, 85u32, 97u32, 95u32,
        96u32, 97u32, 109u32, 107u32, 108u32, 109u32, 137u32, 135u32, 136u32, 137u32, 149u32,
        147u32, 148u32, 149u32, 161u32, 159u32, 160u32, 161u32, 173u32, 171u32, 172u32, 173u32,
        201u32, 199u32, 200u32, 201u32, 213u32, 211u32, 212u32, 213u32, 225u32, 223u32, 224u32,
        225u32, 237u32, 235u32, 236u32, 237u32,
    ]
);
test_ptx_warp!(
    vote_all,
    [
        0u32, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1
    ]
);
test_ptx_warp!(
    vote_all_sub,
    [
        0u32, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1
    ]
);
test_ptx_warp!(
    vote_any,
    [
        1u32, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0
    ]
);
test_ptx_warp!(
    vote_ballot,
    [
        0u32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292,
        4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292,
        4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292,
        4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292, 4294967292,
        4294967292, 4294967292, 4294967292, 4294967292, 4294967292
    ]
);
test_ptx_warp!(
    redux_sync_op_s32,
    [
        357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32,
        357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32,
        357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 357i32, 1445i32,
        1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32,
        1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32,
        1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32, 1445i32,
        1445i32,
    ]
);
test_ptx_warp!(
    redux_sync_op_u32,
    [
        527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32,
        527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32,
        527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 527u32, 1615u32,
        1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32,
        1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32,
        1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32, 1615u32,
        1615u32,
    ]
);
test_ptx_warp!(
    redux_sync_add_u32_partial,
    [
        240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32,
        0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 240u32, 0u32,
        240u32, 0u32, 240u32, 0u32, 240u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32,
        0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32,
        752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32, 752u32, 0u32
    ]
);
test_ptx_warp!(
    ldmatrix,
    [
        340u32, 7u32, 122u32, 619u32, 527u32, 998u32, 693u32, 930u32, 958u32, 773u32, 394u32,
        749u32, 668u32, 172u32, 432u32, 465u32, 646u32, 937u32, 354u32, 96u32, 761u32, 88u32,
        449u32, 621u32, 252u32, 909u32, 778u32, 298u32, 218u32, 283u32, 800u32, 286u32, 656u32,
        779u32, 493u32, 290u32, 659u32, 429u32, 787u32, 930u32, 672u32, 25u32, 203u32, 687u32,
        343u32, 423u32, 845u32, 200u32, 318u32, 918u32, 286u32, 10u32, 206u32, 515u32, 253u32,
        248u32, 194u32, 158u32, 489u32, 911u32, 29u32, 270u32, 323u32, 459u32
    ]
);
test_ptx_warp!(
    ldmatrix_trans,
    [
        1340, 646, 5832, 3398, 29007, 63639, 23344, 40295, 656, 318, 1576, 7944, 4232, 12500,
        36600, 40955, 7, 937, 2683, 4935, 46561, 6132, 18637, 63436, 779, 918, 9774, 6382, 25824,
        42062, 635, 22212, 122, 354, 3864, 8529, 29415, 13898, 23968, 40240, 493, 286, 6490, 7630,
        55743, 58864, 47635, 3027, 619, 96, 7465, 1935, 64210, 57140, 38733, 44576, 290, 10, 5110,
        1210, 31442, 11128, 28677, 16841, 527, 761, 7868, 2866, 25313, 58320, 6079, 3729, 659, 206,
        9895, 9699, 53799, 34285, 7766, 50887, 998, 88, 3107, 9328, 44873, 60190, 41604, 5954, 429,
        515, 5071, 2742, 57015, 46977, 29798, 35371, 693, 449, 6538, 1432, 44140, 20222, 19797,
        42553, 787, 253, 2152, 1957, 43819, 57337, 20953, 43566, 930, 621, 9822, 5164, 35751,
        10303, 53083, 30529, 930, 248, 8047, 2248, 51136, 4030, 13493, 29695, 958, 252, 3898, 4078,
        49542, 31469, 19404, 24354, 672, 194, 9668, 3360, 14011, 20956, 40955, 414, 773, 909, 2510,
        2759, 15886, 43042, 58074, 57190, 25, 158, 7267, 6789, 40915, 36098, 14433, 2862, 394, 778,
        8685, 1674, 21119, 34599, 35408, 14074, 203, 489, 7349, 2291, 12369, 4977, 46545, 8664,
        749, 298, 1642, 4816, 14343, 2064, 61885, 54828, 687, 911, 7716, 5282, 30984, 22884, 16122,
        26519, 668, 218, 356, 498, 55791, 64860, 12579, 50401, 343, 29, 1948, 3832, 56620, 49296,
        3574, 61616, 172, 283, 3240, 1049, 966, 22282, 22010, 57290, 423, 270, 1622, 5653, 58262,
        16603, 6113, 51711, 432, 800, 3655, 1124, 42732, 60671, 13888, 54112, 845, 323, 6239, 7370,
        13717, 19215, 36227, 21636, 465, 286, 8860, 725, 3529, 61555, 62303, 39307, 200, 459, 9645,
        5407, 13983, 60099, 29240, 38811
    ]
);
test_ptx_warp!(
    mma_m16n8k16_f32_bf16_bf16_f32,
    [
        4448.0f32, 11873.0, 4882.0, 13331.0, 19304.0, 26729.0, 21786.0, 30235.0, 34160.0, 41585.0,
        38690.0, 47139.0, 49016.0, 56441.0, 55594.0, 64043.0, 11392.0, 35201.0, 11826.0, 36659.0,
        59016.0, 82825.0, 61498.0, 86331.0, 106640.0, 130449.0, 111170.0, 136003.0, 154264.0,
        178073.0, 160842.0, 185675.0, 18336.0, 58529.0, 18770.0, 59987.0, 98728.0, 138921.0,
        101210.0, 142427.0, 179120.0, 219313.0, 183650.0, 224867.0, 259512.0, 299705.0, 266090.0,
        307307.0, 25280.0, 81857.0, 25714.0, 83315.0, 138440.0, 195017.0, 140922.0, 198523.0,
        251600.0, 308177.0, 256130.0, 313731.0, 364760.0, 421337.0, 371338.0, 428939.0, 32224.0,
        105185.0, 32658.0, 106643.0, 178152.0, 251113.0, 180634.0, 254619.0, 324080.0, 397041.0,
        328610.0, 402595.0, 470008.0, 542969.0, 476586.0, 550571.0, 39168.0, 128513.0, 39602.0,
        129971.0, 217864.0, 307209.0, 220346.0, 310715.0, 396560.0, 485905.0, 401090.0, 491459.0,
        575256.0, 664601.0, 581834.0, 672203.0, 46112.0, 151841.0, 46546.0, 153299.0, 257576.0,
        363305.0, 260058.0, 366811.0, 469040.0, 574769.0, 473570.0, 580323.0, 680504.0, 786233.0,
        687082.0, 793835.0, 53056.0, 175169.0, 53490.0, 176627.0, 297288.0, 419401.0, 299770.0,
        422907.0, 541520.0, 663633.0, 546050.0, 669187.0, 785752.0, 907865.0, 792330.0, 915467.0,
        1165824.0, 1304065.0, 1178770.0, 1318547.0, 1442312.0, 1580553.0, 1458330.0, 1598107.0,
        1718800.0, 1857041.0, 1737890.0, 1877667.0, 1995288.0, 2133529.0, 2017450.0, 2157227.0,
        1303840.0, 1458465.0, 1316786.0, 1472947.0, 1613096.0, 1767721.0, 1629114.0, 1785275.0,
        1922352.0, 2076977.0, 1941442.0, 2097603.0, 2231608.0, 2386233.0, 2253770.0, 2409931.0,
        1441856.0, 1612865.0, 1454802.0, 1627347.0, 1783880.0, 1954889.0, 1799898.0, 1972443.0,
        2125904.0, 2296913.0, 2144994.0, 2317539.0, 2467928.0, 2638937.0, 2490090.0, 2662635.0,
        1579872.0, 1767265.0, 1592818.0, 1781747.0, 1954664.0, 2142057.0, 1970682.0, 2159611.0,
        2329456.0, 2516849.0, 2348546.0, 2537475.0, 2704248.0, 2891641.0, 2726410.0, 2915339.0,
        1717888.0, 1921665.0, 1730834.0, 1936147.0, 2125448.0, 2329225.0, 2141466.0, 2346779.0,
        2533008.0, 2736785.0, 2552098.0, 2757411.0, 2940568.0, 3144345.0, 2962730.0, 3168043.0,
        1855904.0, 2076065.0, 1868850.0, 2090547.0, 2296232.0, 2516393.0, 2312250.0, 2533947.0,
        2736560.0, 2956721.0, 2755650.0, 2977347.0, 3176888.0, 3397049.0, 3199050.0, 3420747.0,
        1993920.0, 2230465.0, 2006866.0, 2244947.0, 2467016.0, 2703561.0, 2483034.0, 2721115.0,
        2940112.0, 3176657.0, 2959202.0, 3197283.0, 3413208.0, 3649753.0, 3435370.0, 3673451.0,
        2131936.0, 2384865.0, 2144882.0, 2399347.0, 2637800.0, 2890729.0, 2653818.0, 2908283.0,
        3143664.0, 3396593.0, 3162754.0, 3417219.0, 3649528.0, 3902457.0, 3671690.0, 3926155.0
    ]
);
test_ptx_warp!(
    mma_m16n8k32_s32_s8_s8_s32,
    [
        34352i32, 94769, 37618, 106227, -86464, -26047, -99582, -30973, 34624, 95041, 37922,
        106531, -86192, -25775, -99278, -30669, 86640, 278129, 89906, 289587, -296320, -104831,
        -309438, -109757, 87424, 278913, 90722, 290403, -295536, -104047, -308622, -108941, -69968,
        -271695, -66702, -260237, 333504, 131777, 320386, 126851, -70720, -272447, -67422, -260957,
        332752, 131025, 319666, 126131, -17680, -88335, -14414, -76877, 123648, 52993, 110530,
        48067, -17920, -88575, -14622, -77085, 123408, 52753, 110322, 47859, 34816, 95745, 38082,
        107203, -87024, -26095, -100142, -31021, 35096, 96025, 38394, 107515, -86744, -25815,
        -99830, -30709, 87104, 279105, 90370, 290563, -296880, -104879, -309998, -109805, 87896,
        279897, 91194, 291387, -296088, -104087, -309174, -108981, -69504, -270719, -66238,
        -259261, 332944, 131729, 319826, 126803, -70248, -271463, -66950, -259973, 332200, 130985,
        319114, 126091, -17216, -87359, -13950, -75901, 123088, 52945, 109970, 48019, -17448,
        -87591, -14150, -76101, 122856, 52713, 109770, 47819, 35760, 97201, 39090, 108723, -87104,
        -25663, -100158, -30525, 36032, 97473, 39394, 109027, -86832, -25391, -99854, -30221,
        89072, 281585, 92402, 293107, -295936, -103423, -308990, -108285, 89856, 282369, 93218,
        293923, -295152, -102639, -308174, -107469, -70608, -271311, -67278, -259789, 330816,
        130113, 317762, 125251, -71360, -272063, -67998, -260509, 330064, 129361, 317042, 124531,
        -17296, -86927, -13966, -75405, 121984, 52353, 108930, 47491, -17536, -87167, -14174,
        -75613, 121744, 52113, 108722, 47283, 36224, 98177, 39554, 109699, -87664, -25711, -100718,
        -30573, 36504, 98457, 39866, 110011, -87384, -25431, -100406, -30261, 89536, 282561, 92866,
        294083, -296496, -103471, -309550, -108333, 90328, 283353, 93690, 294907, -295704, -102679,
        -308726, -107509, -70144, -270335, -66814, -258813, 330256, 130065, 317202, 125203, -70888,
        -271079, -67526, -259525, 329512, 129321, 316490, 124491, -16832, -85951, -13502, -74429,
        121424, 52305, 108370, 47443, -17064, -86183, -13702, -74629, 121192, 52073, 108170, 47243
    ]
);
test_ptx_warp!(
    mma_m16n8k16_f32_f16_f16_f32,
    [
        4448.0f32, 11873.0, 4882.0, 13331.0, 19304.0, 26729.0, 21786.0, 30235.0, 34160.0, 41585.0,
        38690.0, 47139.0, 49016.0, 56441.0, 55594.0, 64043.0, 11392.0, 35201.0, 11826.0, 36659.0,
        59016.0, 82825.0, 61498.0, 86331.0, 106640.0, 130449.0, 111170.0, 136003.0, 154264.0,
        178073.0, 160842.0, 185675.0, 18336.0, 58529.0, 18770.0, 59987.0, 98728.0, 138921.0,
        101210.0, 142427.0, 179120.0, 219313.0, 183650.0, 224867.0, 259512.0, 299705.0, 266090.0,
        307307.0, 25280.0, 81857.0, 25714.0, 83315.0, 138440.0, 195017.0, 140922.0, 198523.0,
        251600.0, 308177.0, 256130.0, 313731.0, 364760.0, 421337.0, 371338.0, 428939.0, 32224.0,
        105185.0, 32658.0, 106643.0, 178152.0, 251113.0, 180634.0, 254619.0, 324080.0, 397041.0,
        328610.0, 402595.0, 470008.0, 542969.0, 476586.0, 550571.0, 39168.0, 128513.0, 39602.0,
        129971.0, 217864.0, 307209.0, 220346.0, 310715.0, 396560.0, 485905.0, 401090.0, 491459.0,
        575256.0, 664601.0, 581834.0, 672203.0, 46112.0, 151841.0, 46546.0, 153299.0, 257576.0,
        363305.0, 260058.0, 366811.0, 469040.0, 574769.0, 473570.0, 580323.0, 680504.0, 786233.0,
        687082.0, 793835.0, 53056.0, 175169.0, 53490.0, 176627.0, 297288.0, 419401.0, 299770.0,
        422907.0, 541520.0, 663633.0, 546050.0, 669187.0, 785752.0, 907865.0, 792330.0, 915467.0,
        1167968.0, 1306465.0, 1176594.0, 1316115.0, 1444968.0, 1583465.0, 1455642.0, 1595163.0,
        1721968.0, 1860465.0, 1734690.0, 1874211.0, 1998968.0, 2137465.0, 2013738.0, 2153259.0,
        1305984.0, 1460865.0, 1314610.0, 1470515.0, 1615752.0, 1770633.0, 1626426.0, 1782331.0,
        1925520.0, 2080401.0, 1938242.0, 2094147.0, 2235288.0, 2390169.0, 2250058.0, 2405963.0,
        1444000.0, 1615265.0, 1452626.0, 1624915.0, 1786536.0, 1957801.0, 1797210.0, 1969499.0,
        2129072.0, 2300337.0, 2141794.0, 2314083.0, 2471608.0, 2642873.0, 2486378.0, 2658667.0,
        1582016.0, 1769665.0, 1590642.0, 1779315.0, 1957320.0, 2144969.0, 1967994.0, 2156667.0,
        2332624.0, 2520273.0, 2345346.0, 2534019.0, 2707928.0, 2895577.0, 2722698.0, 2911371.0,
        1720032.0, 1924065.0, 1728658.0, 1933715.0, 2128104.0, 2332137.0, 2138778.0, 2343835.0,
        2536176.0, 2740209.0, 2548898.0, 2753955.0, 2944248.0, 3148281.0, 2959018.0, 3164075.0,
        1858048.0, 2078465.0, 1866674.0, 2088115.0, 2298888.0, 2519305.0, 2309562.0, 2531003.0,
        2739728.0, 2960145.0, 2752450.0, 2973891.0, 3180568.0, 3400985.0, 3195338.0, 3416779.0,
        1996064.0, 2232865.0, 2004690.0, 2242515.0, 2469672.0, 2706473.0, 2480346.0, 2718171.0,
        2943280.0, 3180081.0, 2956002.0, 3193827.0, 3416888.0, 3653689.0, 3431658.0, 3669483.0,
        2134080.0, 2387265.0, 2142706.0, 2396915.0, 2640456.0, 2893641.0, 2651130.0, 2905339.0,
        3146832.0, 3400017.0, 3159554.0, 3413763.0, 3653208.0, 3906393.0, 3667978.0, 3922187.0
    ]
);
test_ptx_warp!(
    mma_m16n8k16_f32_bf16_bf16_f32_2x,
    [
        4448.0f32,
        11873.0f32,
        4882.0f32,
        13331.0f32,
        5380.0f32,
        12805.0f32,
        5942.0f32,
        14391.0f32,
        19304.0f32,
        26729.0f32,
        21786.0f32,
        30235.0f32,
        20236.0f32,
        27661.0f32,
        22846.0f32,
        31295.0f32,
        34160.0f32,
        41585.0f32,
        38690.0f32,
        47139.0f32,
        35092.0f32,
        42517.0f32,
        39750.0f32,
        48199.0f32,
        49016.0f32,
        56441.0f32,
        55594.0f32,
        64043.0f32,
        49948.0f32,
        57373.0f32,
        56654.0f32,
        65103.0f32,
        11392.0f32,
        35201.0f32,
        11826.0f32,
        36659.0f32,
        14372.0f32,
        38181.0f32,
        14934.0f32,
        39767.0f32,
        59016.0f32,
        82825.0f32,
        61498.0f32,
        86331.0f32,
        61996.0f32,
        85805.0f32,
        64606.0f32,
        89439.0f32,
        106640.0f32,
        130449.0f32,
        111170.0f32,
        136003.0f32,
        109620.0f32,
        133429.0f32,
        114278.0f32,
        139111.0f32,
        154264.0f32,
        178073.0f32,
        160842.0f32,
        185675.0f32,
        157244.0f32,
        181053.0f32,
        163950.0f32,
        188783.0f32,
        18336.0f32,
        58529.0f32,
        18770.0f32,
        59987.0f32,
        23364.0f32,
        63557.0f32,
        23926.0f32,
        65143.0f32,
        98728.0f32,
        138921.0f32,
        101210.0f32,
        142427.0f32,
        103756.0f32,
        143949.0f32,
        106366.0f32,
        147583.0f32,
        179120.0f32,
        219313.0f32,
        183650.0f32,
        224867.0f32,
        184148.0f32,
        224341.0f32,
        188806.0f32,
        230023.0f32,
        259512.0f32,
        299705.0f32,
        266090.0f32,
        307307.0f32,
        264540.0f32,
        304733.0f32,
        271246.0f32,
        312463.0f32,
        25280.0f32,
        81857.0f32,
        25714.0f32,
        83315.0f32,
        32356.0f32,
        88933.0f32,
        32918.0f32,
        90519.0f32,
        138440.0f32,
        195017.0f32,
        140922.0f32,
        198523.0f32,
        145516.0f32,
        202093.0f32,
        148126.0f32,
        205727.0f32,
        251600.0f32,
        308177.0f32,
        256130.0f32,
        313731.0f32,
        258676.0f32,
        315253.0f32,
        263334.0f32,
        320935.0f32,
        364760.0f32,
        421337.0f32,
        371338.0f32,
        428939.0f32,
        371836.0f32,
        428413.0f32,
        378542.0f32,
        436143.0f32,
        32224.0f32,
        105185.0f32,
        32658.0f32,
        106643.0f32,
        41348.0f32,
        114309.0f32,
        41910.0f32,
        115895.0f32,
        178152.0f32,
        251113.0f32,
        180634.0f32,
        254619.0f32,
        187276.0f32,
        260237.0f32,
        189886.0f32,
        263871.0f32,
        324080.0f32,
        397041.0f32,
        328610.0f32,
        402595.0f32,
        333204.0f32,
        406165.0f32,
        337862.0f32,
        411847.0f32,
        470008.0f32,
        542969.0f32,
        476586.0f32,
        550571.0f32,
        479132.0f32,
        552093.0f32,
        485838.0f32,
        559823.0f32,
        39168.0f32,
        128513.0f32,
        39602.0f32,
        129971.0f32,
        50340.0f32,
        139685.0f32,
        50902.0f32,
        141271.0f32,
        217864.0f32,
        307209.0f32,
        220346.0f32,
        310715.0f32,
        229036.0f32,
        318381.0f32,
        231646.0f32,
        322015.0f32,
        396560.0f32,
        485905.0f32,
        401090.0f32,
        491459.0f32,
        407732.0f32,
        497077.0f32,
        412390.0f32,
        502759.0f32,
        575256.0f32,
        664601.0f32,
        581834.0f32,
        672203.0f32,
        586428.0f32,
        675773.0f32,
        593134.0f32,
        683503.0f32,
        46112.0f32,
        151841.0f32,
        46546.0f32,
        153299.0f32,
        59332.0f32,
        165061.0f32,
        59894.0f32,
        166647.0f32,
        257576.0f32,
        363305.0f32,
        260058.0f32,
        366811.0f32,
        270796.0f32,
        376525.0f32,
        273406.0f32,
        380159.0f32,
        469040.0f32,
        574769.0f32,
        473570.0f32,
        580323.0f32,
        482260.0f32,
        587989.0f32,
        486918.0f32,
        593671.0f32,
        680504.0f32,
        786233.0f32,
        687082.0f32,
        793835.0f32,
        693724.0f32,
        799453.0f32,
        700430.0f32,
        807183.0f32,
        53056.0f32,
        175169.0f32,
        53490.0f32,
        176627.0f32,
        68324.0f32,
        190437.0f32,
        68886.0f32,
        192023.0f32,
        297288.0f32,
        419401.0f32,
        299770.0f32,
        422907.0f32,
        312556.0f32,
        434669.0f32,
        315166.0f32,
        438303.0f32,
        541520.0f32,
        663633.0f32,
        546050.0f32,
        669187.0f32,
        556788.0f32,
        678901.0f32,
        561446.0f32,
        684583.0f32,
        785752.0f32,
        907865.0f32,
        792330.0f32,
        915467.0f32,
        801020.0f32,
        923133.0f32,
        807726.0f32,
        930863.0f32,
    ]
);
struct DisplayError<T: Debug> {
    err: T,
}

impl<T: Debug> Display for DisplayError<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        Debug::fmt(&self.err, f)
    }
}

impl<T: Debug> Debug for DisplayError<T> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        Debug::fmt(&self.err, f)
    }
}

impl<T: Debug> error::Error for DisplayError<T> {}

fn test_hip_assert<
    Input: From<u8> + Debug + Copy + PartialEq,
    Output: From<u8> + Debug + Copy + PartialEq + Default,
>(
    name: &str,
    ptx_text: &str,
    input: Option<&[Input]>,
    output: &[Output],
    block_dim_x: u32,
) -> Result<(), Box<dyn error::Error>> {
    let ast = ptx_parser::parse_module_checked(ptx_text).unwrap();
    let name = CString::new(name)?;
    let llvm_ir = pass::to_llvm_module(
        ast,
        pass::Attributes {
            clock_rate: 2124000,
        },
        |_| {},
    )
    .unwrap();
    let result = run_hip(name.as_c_str(), llvm_ir, input, output, block_dim_x)
        .map_err(|err| DisplayError { err })?;
    assert_eq!(result.as_slice(), output);
    Ok(())
}

fn test_llvm_assert(
    name: &str,
    ptx_text: &str,
    expected_ll: &str,
) -> Result<(), Box<dyn error::Error>> {
    let ast = ptx_parser::parse_module_checked(ptx_text).unwrap();
    let llvm_ir = pass::to_llvm_module(
        ast,
        pass::Attributes {
            clock_rate: 2124000,
        },
        |_| {},
    )
    .unwrap();
    let actual_ll = llvm_ir.llvm_ir.print_module_to_string();
    let actual_ll = actual_ll.to_str();
    compare_llvm(name, actual_ll, expected_ll);

    let expected_attributes_ll = read_test_file!(concat!("../ll/_attributes.ll"));
    let actual_attributes_ll = llvm_ir.attributes_ir.print_module_to_string();
    let actual_attributes_ll = actual_attributes_ll.to_str();
    compare_llvm("_attributes", actual_attributes_ll, &expected_attributes_ll);
    Ok(())
}

fn compare_llvm(name: &str, actual_ll: &str, expected_ll: &str) {
    if actual_ll != expected_ll {
        let output_dir = env::var("TEST_PTX_LLVM_FAIL_DIR");
        if let Ok(output_dir) = output_dir {
            let output_dir = Path::new(&output_dir);
            fs::create_dir_all(&output_dir).unwrap();
            let output_file = output_dir.join(format!("{}.ll", name));
            let mut output_file = File::create(output_file).unwrap();
            output_file.write_all(actual_ll.as_bytes()).unwrap();
        }
        let comparison = pretty_assertions::StrComparison::new(&expected_ll, &actual_ll);
        panic!("assertion failed: `(left == right)`\n\n{}", comparison);
    }
}

fn test_cuda_assert<
    Input: From<u8> + Debug + Copy + PartialEq,
    Output: From<u8> + Debug + Copy + PartialEq + Default,
>(
    name: &str,
    ptx_text: &str,
    input: Option<&[Input]>,
    output: &[Output],
    block_dim_x: u32,
) -> Result<(), Box<dyn error::Error>> {
    let name = CString::new(name)?;
    let result = run_cuda(name.as_c_str(), ptx_text, input, output, block_dim_x);
    assert_eq!(result.as_slice(), output);
    Ok(())
}

fn run_cuda<Input: From<u8> + Copy + Debug, Output: From<u8> + Copy + Debug + Default>(
    name: &CStr,
    ptx_module: &str,
    input: Option<&[Input]>,
    output: &[Output],
    block_dim_x: u32,
) -> Vec<Output> {
    unsafe { CUDA.cuInit(0) }.unwrap().unwrap();
    let ptx_module = CString::new(ptx_module).unwrap();
    let mut result = vec![0u8.into(); output.len()];
    {
        let mut ctx = unsafe { mem::zeroed() };
        unsafe { CUDA.cuCtxCreate_v2(&mut ctx, 0, 0) }
            .unwrap()
            .unwrap();
        let mut module = unsafe { mem::zeroed() };
        unsafe { CUDA.cuModuleLoadData(&mut module, ptx_module.as_ptr() as _) }
            .unwrap()
            .unwrap();
        let mut kernel = unsafe { mem::zeroed() };
        unsafe { CUDA.cuModuleGetFunction(&mut kernel, module, name.as_ptr()) }
            .unwrap()
            .unwrap();
        let mut out_b = unsafe { mem::zeroed() };
        unsafe { CUDA.cuMemAlloc_v2(&mut out_b, output.len() * mem::size_of::<Output>()) }
            .unwrap()
            .unwrap();
        let mut inp_b = unsafe { mem::zeroed() };
        if let Some(input) = input {
            unsafe { CUDA.cuMemAlloc_v2(&mut inp_b, input.len() * mem::size_of::<Input>()) }
                .unwrap()
                .unwrap();
            unsafe {
                CUDA.cuMemcpyHtoD_v2(
                    inp_b,
                    input.as_ptr() as _,
                    input.len() * mem::size_of::<Input>(),
                )
            }
            .unwrap()
            .unwrap();
        }
        unsafe { CUDA.cuMemsetD8_v2(out_b, 0, output.len() * mem::size_of::<Output>()) }
            .unwrap()
            .unwrap();
        let mut args = if input.is_some() {
            [&inp_b, &out_b]
        } else {
            [&out_b, &out_b]
        };
        unsafe {
            CUDA.cuLaunchKernel(
                kernel,
                1,
                1,
                1,
                block_dim_x,
                1,
                1,
                1024,
                CUstream(ptr::null_mut()),
                args.as_mut_ptr() as _,
                ptr::null_mut(),
            )
        }
        .unwrap()
        .unwrap();
        unsafe {
            CUDA.cuMemcpyDtoH_v2(
                result.as_mut_ptr() as _,
                out_b,
                output.len() * mem::size_of::<Output>(),
            )
        }
        .unwrap()
        .unwrap();
        unsafe { CUDA.cuStreamSynchronize(CUstream(ptr::null_mut())) }
            .unwrap()
            .unwrap();
        unsafe { CUDA.cuMemFree_v2(inp_b) }.unwrap().unwrap();
        unsafe { CUDA.cuMemFree_v2(out_b) }.unwrap().unwrap();
        unsafe { CUDA.cuModuleUnload(module) }.unwrap().unwrap();
        unsafe { CUDA.cuCtxDestroy_v2(ctx) }.unwrap().unwrap();
    }
    result
}

struct DynamicCuda {
    lib: libloading::Library,
}

impl DynamicCuda {
    #[cfg(not(windows))]
    const CUDA_PATH: &'static str = "/usr/lib/x86_64-linux-gnu/libcuda.so.1";
    #[cfg(windows)]
    const CUDA_PATH: &'static str = "C:\\Windows\\System32\\nvcuda.dll";

    pub fn new() -> Result<Self, libloading::Error> {
        let lib = unsafe { libloading::Library::new(Self::CUDA_PATH) }?;
        Ok(Self { lib })
    }
}

macro_rules! dynamic_fns {
    ($($abi:literal fn $fn_name:ident( $($arg_id:ident : $arg_type:ty),* ) -> $ret_type:ty;)*) => {
        impl DynamicCuda {
        $(
            #[allow(dead_code)]
            unsafe fn $fn_name(&self, $($arg_id : $arg_type),*) -> Result<$ret_type, libloading::Error> {
                let func = unsafe { self.lib.get::<unsafe extern $abi fn ($($arg_type),*) -> $ret_type>(concat!(stringify!($fn_name), "\0").as_bytes()) };
                func.map(|f| f($($arg_id),*) )
            }
        )*
        }
    };
}

cuda_macros::cuda_function_declarations!(dynamic_fns);

static CUDA: std::sync::LazyLock<DynamicCuda> =
    std::sync::LazyLock::new(|| DynamicCuda::new().unwrap());

fn run_hip<Input: From<u8> + Copy + Debug, Output: From<u8> + Copy + Debug + Default>(
    name: &CStr,
    module: pass::Module,
    input: Option<&[Input]>,
    output: &[Output],
    block_dim_x: u32,
) -> Result<Vec<Output>, hipError_t> {
    use hip_runtime_sys::*;
    unsafe { hipInit(0) }.unwrap();
    let mut result = vec![0u8.into(); output.len()];
    {
        let dev = 0;
        let mut stream = unsafe { mem::zeroed() };
        unsafe { hipStreamCreate(&mut stream) }.unwrap();
        let mut dev_props = unsafe { mem::zeroed() };
        unsafe { hipGetDevicePropertiesR0600(&mut dev_props, dev) }.unwrap();
        let ptx_impl = module.linked_bitcode();
        let elf_module = llvm_zluda::compile(
            &module.context,
            unsafe { CStr::from_ptr(dev_props.gcnArchName.as_ptr()) }
                .to_str()
                .unwrap(),
            module.llvm_ir,
            ptx_impl,
            module.attributes_ir,
            None,
        )
        .unwrap();
        // TODO: Re-enable when we are able to privatize function-scoped
        // globals and constants
        // let fns = comgr::get_symbols(&comgr, &elf_module).unwrap();
        // verify_symbols(fns);
        let mut module = unsafe { mem::zeroed() };
        unsafe { hipModuleLoadData(&mut module, elf_module.as_ptr() as _) }.unwrap();
        let mut kernel = unsafe { mem::zeroed() };
        unsafe { hipModuleGetFunction(&mut kernel, module, name.as_ptr()) }.unwrap();
        let mut out_b = ptr::null_mut();
        unsafe { hipMalloc(&mut out_b, output.len() * mem::size_of::<Output>()) }.unwrap();
        let mut inp_b = ptr::null_mut();
        if let Some(input) = input {
            unsafe { hipMalloc(&mut inp_b, input.len() * mem::size_of::<Input>()) }.unwrap();
            unsafe {
                hipMemcpyWithStream(
                    inp_b,
                    input.as_ptr() as _,
                    input.len() * mem::size_of::<Input>(),
                    hipMemcpyKind::hipMemcpyHostToDevice,
                    stream,
                )
            }
            .unwrap();
        }
        unsafe { hipMemset(out_b, 0, output.len() * mem::size_of::<Output>()) }.unwrap();
        let mut args = if input.is_some() {
            [&inp_b, &out_b]
        } else {
            [&out_b, &out_b]
        };
        unsafe {
            hipModuleLaunchKernel(
                kernel,
                1,
                1,
                1,
                block_dim_x,
                1,
                1,
                1024,
                stream,
                args.as_mut_ptr() as _,
                ptr::null_mut(),
            )
        }
        .unwrap();
        unsafe {
            hipMemcpyAsync(
                result.as_mut_ptr() as _,
                out_b,
                output.len() * mem::size_of::<Output>(),
                hipMemcpyKind::hipMemcpyDeviceToHost,
                stream,
            )
        }
        .unwrap();
        unsafe { hipStreamSynchronize(stream) }.unwrap();
        unsafe { hipFree(inp_b) }.unwrap();
        unsafe { hipFree(out_b) }.unwrap();
        unsafe { hipModuleUnload(module) }.unwrap();
    }
    Ok(result)
}

// TODO: Re-enable when we are able to privatize function-scoped
// globals and constants
/*
fn verify_symbols(mut symbols: Vec<(u32, String)>) {
    symbols.sort();
    if symbols.len() != 2 {
        panic!("Expected exactly two symbols, found: {:?}", symbols);
    }
    assert_eq!(
        symbols[0].0, 1,
        "Wrong symbols exported from binary: {:?}",
        symbols
    );
    assert_eq!(
        symbols[1].0, 2,
        "Wrong symbols exported from binary: {:?}",
        symbols
    );
    assert_eq!(
        symbols[0].1,
        format!("{}.kd", symbols[1].1),
        "Wrong symbols exported from binary: {:?}",
        symbols
    );
}
 */
