/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocsparse_float_complex {
    pub x: f32,
    pub y: f32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocsparse_double_complex {
    pub x: f64,
    pub y: f64,
}
pub type rocsparse_int = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
#[doc = " \\cond DO_NOT_DOCUMENT"]
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_handle {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Handle to the rocSPARSE library context queue.\n\n  \\details\n  The rocSPARSE handle is a structure holding the rocSPARSE library context. It must\n  be initialized using rocsparse_create_handle() and the returned handle must be\n  passed to all subsequent library function calls. It should be destroyed at the end\n  using rocsparse_destroy_handle()."]
pub type rocsparse_handle = *mut _rocsparse_handle;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_mat_descr {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix.\n\n  \\details\n  The rocSPARSE matrix descriptor is a structure holding all properties of a matrix.\n  It must be initialized using rocsparse_create_mat_descr() and the returned\n  descriptor must be passed to all subsequent library calls that involve the matrix.\n  It should be destroyed at the end using rocsparse_destroy_mat_descr()."]
pub type rocsparse_mat_descr = *mut _rocsparse_mat_descr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_hyb_mat {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief HYB matrix storage format.\n\n  \\details\n  The rocSPARSE HYB matrix structure holds the HYB matrix. It must be initialized using\n  rocsparse_create_hyb_mat() and the returned HYB matrix must be passed to all\n  subsequent library calls that involve the matrix. It should be destroyed at the end\n  using rocsparse_destroy_hyb_mat()."]
pub type rocsparse_hyb_mat = *mut _rocsparse_hyb_mat;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_mat_info {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Info structure to hold all matrix meta data.\n\n  \\details\n  The rocSPARSE matrix info is a structure holding all matrix information that is\n  gathered during analysis routines. It must be initialized using\n  rocsparse_create_mat_info() and the returned info structure must be passed to all\n  subsequent library calls that require additional matrix information. It should be\n  destroyed at the end using rocsparse_destroy_mat_info()."]
pub type rocsparse_mat_info = *mut _rocsparse_mat_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_spvec_descr {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Generic API descriptor of the sparse vector.\n\n  \\details\n  The rocSPARSE sparse vector descriptor is a structure holding all properties of a sparse vector.\n  It must be initialized using rocsparse_create_spvec_descr() and the returned\n  descriptor must be passed to all subsequent generic API library calls that involve the sparse vector.\n  It should be destroyed at the end using rocsparse_destroy_spvec_descr()."]
pub type rocsparse_spvec_descr = *mut _rocsparse_spvec_descr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_spmat_descr {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Generic API descriptor of the sparse matrix.\n\n  \\details\n  The rocSPARSE sparse matrix descriptor is a structure holding all properties of a sparse matrix.\n  It must be initialized using rocsparse_create_coo_descr(), rocsparse_create_coo_aos_descr(),\n  rocsparse_create_bsr_descr(), rocsparse_create_csr_descr(), rocsparse_create_csc_descr(),\n  rocsparse_create_ell_descr(), or rocsparse_create_bell_descr() and the returned\n  descriptor must be passed to all subsequent generic API library calls that involve the sparse matrix.\n  It should be destroyed at the end using rocsparse_destroy_spmat_descr()."]
pub type rocsparse_spmat_descr = *mut _rocsparse_spmat_descr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_dnvec_descr {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Generic API descriptor of the dense vector.\n\n  \\details\n  The rocSPARSE dense vector descriptor is a structure holding all properties of a dense vector.\n  It must be initialized using rocsparse_create_dnvec_descr() and the returned\n  descriptor must be passed to all subsequent generic API library calls that involve the dense vector.\n  It should be destroyed at the end using rocsparse_destroy_dnvec_descr()."]
pub type rocsparse_dnvec_descr = *mut _rocsparse_dnvec_descr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_dnmat_descr {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Generic API descriptor of the dense matrix.\n\n  \\details\n  The rocSPARSE dense matrix descriptor is a structure holding all properties of a dense matrix.\n  It must be initialized using rocsparse_create_dnmat_descr() and the returned\n  descriptor must be passed to all subsequent generic API library calls that involve the dense matrix.\n  It should be destroyed at the end using rocsparse_destroy_dnmat_descr()."]
pub type rocsparse_dnmat_descr = *mut _rocsparse_dnmat_descr;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _rocsparse_color_info {
    _unused: [u8; 0],
}
#[doc = " \\ingroup types_module\n  \\brief Coloring info structure to hold data gathered during analysis and later used in\n  rocSPARSE sparse matrix coloring routines.\n\n  \\details\n  The rocSPARSE color info is a structure holding coloring data that is\n  gathered during analysis routines. It must be initialized using\n  rocsparse_create_color_info() and the returned info structure must be passed to all\n  subsequent library calls that require coloring information. It should be\n  destroyed at the end using rocsparse_destroy_color_info()."]
pub type rocsparse_color_info = *mut _rocsparse_color_info;
impl rocsparse_operation_ {
    #[doc = "< Operate with matrix."]
    pub const rocsparse_operation_none: rocsparse_operation_ = rocsparse_operation_(111);
}
impl rocsparse_operation_ {
    #[doc = "< Operate with transpose."]
    pub const rocsparse_operation_transpose: rocsparse_operation_ = rocsparse_operation_(112);
}
impl rocsparse_operation_ {
    #[doc = "< Operate with conj. transpose."]
    pub const rocsparse_operation_conjugate_transpose: rocsparse_operation_ =
        rocsparse_operation_(113);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify whether the matrix is to be transposed or not.\n\n  \\details\n  The \\ref rocsparse_operation indicates the operation performed with the given matrix."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_operation_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify whether the matrix is to be transposed or not.\n\n  \\details\n  The \\ref rocsparse_operation indicates the operation performed with the given matrix."]
pub use self::rocsparse_operation_ as rocsparse_operation;
impl rocsparse_index_base_ {
    #[doc = "< zero based indexing."]
    pub const rocsparse_index_base_zero: rocsparse_index_base_ = rocsparse_index_base_(0);
}
impl rocsparse_index_base_ {
    #[doc = "< one based indexing."]
    pub const rocsparse_index_base_one: rocsparse_index_base_ = rocsparse_index_base_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix index base.\n\n  \\details\n  The \\ref rocsparse_index_base indicates the index base of the indices. For a\n  given \\ref rocsparse_mat_descr, the \\ref rocsparse_index_base can be set using\n  rocsparse_set_mat_index_base(). The current \\ref rocsparse_index_base of a matrix\n  can be obtained by rocsparse_get_mat_index_base()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_index_base_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix index base.\n\n  \\details\n  The \\ref rocsparse_index_base indicates the index base of the indices. For a\n  given \\ref rocsparse_mat_descr, the \\ref rocsparse_index_base can be set using\n  rocsparse_set_mat_index_base(). The current \\ref rocsparse_index_base of a matrix\n  can be obtained by rocsparse_get_mat_index_base()."]
pub use self::rocsparse_index_base_ as rocsparse_index_base;
impl rocsparse_matrix_type_ {
    #[doc = "< general matrix type."]
    pub const rocsparse_matrix_type_general: rocsparse_matrix_type_ = rocsparse_matrix_type_(0);
}
impl rocsparse_matrix_type_ {
    #[doc = "< symmetric matrix type."]
    pub const rocsparse_matrix_type_symmetric: rocsparse_matrix_type_ = rocsparse_matrix_type_(1);
}
impl rocsparse_matrix_type_ {
    #[doc = "< hermitian matrix type."]
    pub const rocsparse_matrix_type_hermitian: rocsparse_matrix_type_ = rocsparse_matrix_type_(2);
}
impl rocsparse_matrix_type_ {
    #[doc = "< triangular matrix type."]
    pub const rocsparse_matrix_type_triangular: rocsparse_matrix_type_ = rocsparse_matrix_type_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix type.\n\n  \\details\n  The \\ref rocsparse_matrix_type indices the type of a matrix. For a given\n  \\ref rocsparse_mat_descr, the \\ref rocsparse_matrix_type can be set using\n  rocsparse_set_mat_type(). The current \\ref rocsparse_matrix_type of a matrix can be\n  obtained by rocsparse_get_mat_type()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_matrix_type_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix type.\n\n  \\details\n  The \\ref rocsparse_matrix_type indices the type of a matrix. For a given\n  \\ref rocsparse_mat_descr, the \\ref rocsparse_matrix_type can be set using\n  rocsparse_set_mat_type(). The current \\ref rocsparse_matrix_type of a matrix can be\n  obtained by rocsparse_get_mat_type()."]
pub use self::rocsparse_matrix_type_ as rocsparse_matrix_type;
impl rocsparse_diag_type_ {
    #[doc = "< diagonal entries are non-unity."]
    pub const rocsparse_diag_type_non_unit: rocsparse_diag_type_ = rocsparse_diag_type_(0);
}
impl rocsparse_diag_type_ {
    #[doc = "< diagonal entries are unity"]
    pub const rocsparse_diag_type_unit: rocsparse_diag_type_ = rocsparse_diag_type_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Indicates if the diagonal entries are unity.\n\n  \\details\n  The \\ref rocsparse_diag_type indicates whether the diagonal entries of a matrix are\n  unity or not. If \\ref rocsparse_diag_type_unit is specified, all present diagonal\n  values will be ignored. For a given \\ref rocsparse_mat_descr, the\n  \\ref rocsparse_diag_type can be set using rocsparse_set_mat_diag_type(). The current\n  \\ref rocsparse_diag_type of a matrix can be obtained by\n  rocsparse_get_mat_diag_type()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_diag_type_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Indicates if the diagonal entries are unity.\n\n  \\details\n  The \\ref rocsparse_diag_type indicates whether the diagonal entries of a matrix are\n  unity or not. If \\ref rocsparse_diag_type_unit is specified, all present diagonal\n  values will be ignored. For a given \\ref rocsparse_mat_descr, the\n  \\ref rocsparse_diag_type can be set using rocsparse_set_mat_diag_type(). The current\n  \\ref rocsparse_diag_type of a matrix can be obtained by\n  rocsparse_get_mat_diag_type()."]
pub use self::rocsparse_diag_type_ as rocsparse_diag_type;
impl rocsparse_fill_mode_ {
    #[doc = "< lower triangular part is stored."]
    pub const rocsparse_fill_mode_lower: rocsparse_fill_mode_ = rocsparse_fill_mode_(0);
}
impl rocsparse_fill_mode_ {
    #[doc = "< upper triangular part is stored."]
    pub const rocsparse_fill_mode_upper: rocsparse_fill_mode_ = rocsparse_fill_mode_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix fill mode.\n\n  \\details\n  The \\ref rocsparse_fill_mode indicates whether the lower or the upper part is stored\n  in a sparse triangular matrix. For a given \\ref rocsparse_mat_descr, the\n  \\ref rocsparse_fill_mode can be set using rocsparse_set_mat_fill_mode(). The current\n  \\ref rocsparse_fill_mode of a matrix can be obtained by\n  rocsparse_get_mat_fill_mode()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_fill_mode_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix fill mode.\n\n  \\details\n  The \\ref rocsparse_fill_mode indicates whether the lower or the upper part is stored\n  in a sparse triangular matrix. For a given \\ref rocsparse_mat_descr, the\n  \\ref rocsparse_fill_mode can be set using rocsparse_set_mat_fill_mode(). The current\n  \\ref rocsparse_fill_mode of a matrix can be obtained by\n  rocsparse_get_mat_fill_mode()."]
pub use self::rocsparse_fill_mode_ as rocsparse_fill_mode;
impl rocsparse_storage_mode_ {
    #[doc = "< matrix is sorted."]
    pub const rocsparse_storage_mode_sorted: rocsparse_storage_mode_ = rocsparse_storage_mode_(0);
}
impl rocsparse_storage_mode_ {
    #[doc = "< matrix is unsorted."]
    pub const rocsparse_storage_mode_unsorted: rocsparse_storage_mode_ = rocsparse_storage_mode_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify whether the matrix is stored sorted or not.\n\n  \\details\n  The \\ref rocsparse_storage_mode indicates whether the matrix is stored sorted or not.\n  For a given \\ref rocsparse_mat_descr, the \\ref rocsparse_storage_mode can be set\n  using rocsparse_set_storage_mode(). The current \\ref rocsparse_storage_mode of a\n  matrix can be obtained by rocsparse_get_mat_storage_mode()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_storage_mode_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify whether the matrix is stored sorted or not.\n\n  \\details\n  The \\ref rocsparse_storage_mode indicates whether the matrix is stored sorted or not.\n  For a given \\ref rocsparse_mat_descr, the \\ref rocsparse_storage_mode can be set\n  using rocsparse_set_storage_mode(). The current \\ref rocsparse_storage_mode of a\n  matrix can be obtained by rocsparse_get_mat_storage_mode()."]
pub use self::rocsparse_storage_mode_ as rocsparse_storage_mode;
impl rocsparse_action_ {
    #[doc = "< Operate only on indices."]
    pub const rocsparse_action_symbolic: rocsparse_action_ = rocsparse_action_(0);
}
impl rocsparse_action_ {
    #[doc = "< Operate on data and indices."]
    pub const rocsparse_action_numeric: rocsparse_action_ = rocsparse_action_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify where the operation is performed on.\n\n  \\details\n  The \\ref rocsparse_action indicates whether the operation is performed on the full\n  matrix, or only on the sparsity pattern of the matrix."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_action_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify where the operation is performed on.\n\n  \\details\n  The \\ref rocsparse_action indicates whether the operation is performed on the full\n  matrix, or only on the sparsity pattern of the matrix."]
pub use self::rocsparse_action_ as rocsparse_action;
impl rocsparse_direction_ {
    #[doc = "< Parse the matrix by rows."]
    pub const rocsparse_direction_row: rocsparse_direction_ = rocsparse_direction_(0);
}
impl rocsparse_direction_ {
    #[doc = "< Parse the matrix by columns."]
    pub const rocsparse_direction_column: rocsparse_direction_ = rocsparse_direction_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix direction.\n\n  \\details\n  The \\ref rocsparse_direction indicates whether a dense matrix should be parsed by\n  rows or by columns, assuming column-major storage."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_direction_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify the matrix direction.\n\n  \\details\n  The \\ref rocsparse_direction indicates whether a dense matrix should be parsed by\n  rows or by columns, assuming column-major storage."]
pub use self::rocsparse_direction_ as rocsparse_direction;
impl rocsparse_hyb_partition_ {
    #[doc = "< automatically decide on ELL nnz per row."]
    pub const rocsparse_hyb_partition_auto: rocsparse_hyb_partition_ = rocsparse_hyb_partition_(0);
}
impl rocsparse_hyb_partition_ {
    #[doc = "< user given ELL nnz per row."]
    pub const rocsparse_hyb_partition_user: rocsparse_hyb_partition_ = rocsparse_hyb_partition_(1);
}
impl rocsparse_hyb_partition_ {
    #[doc = "< max ELL nnz per row, no COO part."]
    pub const rocsparse_hyb_partition_max: rocsparse_hyb_partition_ = rocsparse_hyb_partition_(2);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief HYB matrix partitioning type.\n\n  \\details\n  The \\ref rocsparse_hyb_partition type indicates how the hybrid format partitioning\n  between COO and ELL storage formats is performed."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_hyb_partition_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief HYB matrix partitioning type.\n\n  \\details\n  The \\ref rocsparse_hyb_partition type indicates how the hybrid format partitioning\n  between COO and ELL storage formats is performed."]
pub use self::rocsparse_hyb_partition_ as rocsparse_hyb_partition;
impl rocsparse_analysis_policy_ {
    #[doc = "< try to re-use meta data."]
    pub const rocsparse_analysis_policy_reuse: rocsparse_analysis_policy_ =
        rocsparse_analysis_policy_(0);
}
impl rocsparse_analysis_policy_ {
    #[doc = "< force to re-build meta data."]
    pub const rocsparse_analysis_policy_force: rocsparse_analysis_policy_ =
        rocsparse_analysis_policy_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify policy in analysis functions.\n\n  \\details\n  The \\ref rocsparse_analysis_policy specifies whether gathered analysis data should be\n  re-used or not. If meta data from a previous e.g. rocsparse_csrilu0_analysis() call\n  is available, it can be re-used for subsequent calls to e.g.\n  rocsparse_csrsv_analysis() and greatly improve performance of the analysis function."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_analysis_policy_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify policy in analysis functions.\n\n  \\details\n  The \\ref rocsparse_analysis_policy specifies whether gathered analysis data should be\n  re-used or not. If meta data from a previous e.g. rocsparse_csrilu0_analysis() call\n  is available, it can be re-used for subsequent calls to e.g.\n  rocsparse_csrsv_analysis() and greatly improve performance of the analysis function."]
pub use self::rocsparse_analysis_policy_ as rocsparse_analysis_policy;
impl rocsparse_solve_policy_ {
    #[doc = "< automatically decide on level information."]
    pub const rocsparse_solve_policy_auto: rocsparse_solve_policy_ = rocsparse_solve_policy_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Specify policy in triangular solvers and factorizations.\n\n  \\details\n  This is a placeholder."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_solve_policy_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Specify policy in triangular solvers and factorizations.\n\n  \\details\n  This is a placeholder."]
pub use self::rocsparse_solve_policy_ as rocsparse_solve_policy;
impl rocsparse_pointer_mode_ {
    #[doc = "< scalar pointers are in host memory."]
    pub const rocsparse_pointer_mode_host: rocsparse_pointer_mode_ = rocsparse_pointer_mode_(0);
}
impl rocsparse_pointer_mode_ {
    #[doc = "< scalar pointers are in device memory."]
    pub const rocsparse_pointer_mode_device: rocsparse_pointer_mode_ = rocsparse_pointer_mode_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief Indicates if the pointer is device pointer or host pointer.\n\n  \\details\n  The \\ref rocsparse_pointer_mode indicates whether scalar values are passed by\n  reference on the host or device. The \\ref rocsparse_pointer_mode can be changed by\n  rocsparse_set_pointer_mode(). The currently used pointer mode can be obtained by\n  rocsparse_get_pointer_mode()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_pointer_mode_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief Indicates if the pointer is device pointer or host pointer.\n\n  \\details\n  The \\ref rocsparse_pointer_mode indicates whether scalar values are passed by\n  reference on the host or device. The \\ref rocsparse_pointer_mode can be changed by\n  rocsparse_set_pointer_mode(). The currently used pointer mode can be obtained by\n  rocsparse_get_pointer_mode()."]
pub use self::rocsparse_pointer_mode_ as rocsparse_pointer_mode;
impl rocsparse_status_ {
    #[doc = "< success."]
    pub const rocsparse_status_success: rocsparse_status_ = rocsparse_status_(0);
}
impl rocsparse_status_ {
    #[doc = "< handle not initialized, invalid or null."]
    pub const rocsparse_status_invalid_handle: rocsparse_status_ = rocsparse_status_(1);
}
impl rocsparse_status_ {
    #[doc = "< function is not implemented."]
    pub const rocsparse_status_not_implemented: rocsparse_status_ = rocsparse_status_(2);
}
impl rocsparse_status_ {
    #[doc = "< invalid pointer parameter."]
    pub const rocsparse_status_invalid_pointer: rocsparse_status_ = rocsparse_status_(3);
}
impl rocsparse_status_ {
    #[doc = "< invalid size parameter."]
    pub const rocsparse_status_invalid_size: rocsparse_status_ = rocsparse_status_(4);
}
impl rocsparse_status_ {
    #[doc = "< failed memory allocation, copy, dealloc."]
    pub const rocsparse_status_memory_error: rocsparse_status_ = rocsparse_status_(5);
}
impl rocsparse_status_ {
    #[doc = "< other internal library failure."]
    pub const rocsparse_status_internal_error: rocsparse_status_ = rocsparse_status_(6);
}
impl rocsparse_status_ {
    #[doc = "< invalid value parameter."]
    pub const rocsparse_status_invalid_value: rocsparse_status_ = rocsparse_status_(7);
}
impl rocsparse_status_ {
    #[doc = "< device arch is not supported."]
    pub const rocsparse_status_arch_mismatch: rocsparse_status_ = rocsparse_status_(8);
}
impl rocsparse_status_ {
    #[doc = "< encountered zero pivot."]
    pub const rocsparse_status_zero_pivot: rocsparse_status_ = rocsparse_status_(9);
}
impl rocsparse_status_ {
    #[doc = "< descriptor has not been initialized."]
    pub const rocsparse_status_not_initialized: rocsparse_status_ = rocsparse_status_(10);
}
impl rocsparse_status_ {
    #[doc = "< index types do not match."]
    pub const rocsparse_status_type_mismatch: rocsparse_status_ = rocsparse_status_(11);
}
impl rocsparse_status_ {
    #[doc = "< sorted storage required."]
    pub const rocsparse_status_requires_sorted_storage: rocsparse_status_ = rocsparse_status_(12);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse status codes definition.\n\n  \\details\n  This is a list of the \\ref rocsparse_status types that are used by the rocSPARSE\n  library."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_status_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse status codes definition.\n\n  \\details\n  This is a list of the \\ref rocsparse_status types that are used by the rocSPARSE\n  library."]
pub use self::rocsparse_status_ as rocsparse_status;
impl rocsparse_data_status_ {
    #[doc = "< success."]
    pub const rocsparse_data_status_success: rocsparse_data_status_ = rocsparse_data_status_(0);
}
impl rocsparse_data_status_ {
    #[doc = "< An inf value detected."]
    pub const rocsparse_data_status_inf: rocsparse_data_status_ = rocsparse_data_status_(1);
}
impl rocsparse_data_status_ {
    #[doc = "< An nan value detected."]
    pub const rocsparse_data_status_nan: rocsparse_data_status_ = rocsparse_data_status_(2);
}
impl rocsparse_data_status_ {
    #[doc = "< An invalid row pointer offset detected."]
    pub const rocsparse_data_status_invalid_offset_ptr: rocsparse_data_status_ =
        rocsparse_data_status_(3);
}
impl rocsparse_data_status_ {
    #[doc = "< An invalid row indice detected."]
    pub const rocsparse_data_status_invalid_index: rocsparse_data_status_ =
        rocsparse_data_status_(4);
}
impl rocsparse_data_status_ {
    #[doc = "< Duplicate indice detected."]
    pub const rocsparse_data_status_duplicate_entry: rocsparse_data_status_ =
        rocsparse_data_status_(5);
}
impl rocsparse_data_status_ {
    #[doc = "< Incorrect sorting detected."]
    pub const rocsparse_data_status_invalid_sorting: rocsparse_data_status_ =
        rocsparse_data_status_(6);
}
impl rocsparse_data_status_ {
    #[doc = "< Incorrect fill mode detected."]
    pub const rocsparse_data_status_invalid_fill: rocsparse_data_status_ =
        rocsparse_data_status_(7);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse data status codes definition.\n\n  \\details\n  This is a list of the \\ref rocsparse_data_status types that are used by the rocSPARSE\n  library in the matrix check routines."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_data_status_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse data status codes definition.\n\n  \\details\n  This is a list of the \\ref rocsparse_data_status types that are used by the rocSPARSE\n  library in the matrix check routines."]
pub use self::rocsparse_data_status_ as rocsparse_data_status;
impl rocsparse_indextype_ {
    #[doc = "< 16 bit unsigned integer."]
    pub const rocsparse_indextype_u16: rocsparse_indextype_ = rocsparse_indextype_(1);
}
impl rocsparse_indextype_ {
    #[doc = "< 32 bit signed integer."]
    pub const rocsparse_indextype_i32: rocsparse_indextype_ = rocsparse_indextype_(2);
}
impl rocsparse_indextype_ {
    #[doc = "< 64 bit signed integer."]
    pub const rocsparse_indextype_i64: rocsparse_indextype_ = rocsparse_indextype_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse index types.\n\n  \\details\n  Indicates the index width of a rocsparse index type."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_indextype_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse index types.\n\n  \\details\n  Indicates the index width of a rocsparse index type."]
pub use self::rocsparse_indextype_ as rocsparse_indextype;
impl rocsparse_datatype_ {
    #[doc = "< 32 bit floating point, real."]
    pub const rocsparse_datatype_f32_r: rocsparse_datatype_ = rocsparse_datatype_(151);
}
impl rocsparse_datatype_ {
    #[doc = "< 64 bit floating point, real."]
    pub const rocsparse_datatype_f64_r: rocsparse_datatype_ = rocsparse_datatype_(152);
}
impl rocsparse_datatype_ {
    #[doc = "< 32 bit floating point, complex."]
    pub const rocsparse_datatype_f32_c: rocsparse_datatype_ = rocsparse_datatype_(154);
}
impl rocsparse_datatype_ {
    #[doc = "< 64 bit floating point, complex."]
    pub const rocsparse_datatype_f64_c: rocsparse_datatype_ = rocsparse_datatype_(155);
}
impl rocsparse_datatype_ {
    #[doc = "<  8-bit signed integer, real"]
    pub const rocsparse_datatype_i8_r: rocsparse_datatype_ = rocsparse_datatype_(160);
}
impl rocsparse_datatype_ {
    #[doc = "<  8-bit unsigned integer, real"]
    pub const rocsparse_datatype_u8_r: rocsparse_datatype_ = rocsparse_datatype_(161);
}
impl rocsparse_datatype_ {
    #[doc = "< 32-bit signed integer, real"]
    pub const rocsparse_datatype_i32_r: rocsparse_datatype_ = rocsparse_datatype_(162);
}
impl rocsparse_datatype_ {
    #[doc = "< 32-bit unsigned integer, real"]
    pub const rocsparse_datatype_u32_r: rocsparse_datatype_ = rocsparse_datatype_(163);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse data types.\n\n  \\details\n  Indicates the precision width of data stored in a rocsparse type."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_datatype_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of rocsparse data types.\n\n  \\details\n  Indicates the precision width of data stored in a rocsparse type."]
pub use self::rocsparse_datatype_ as rocsparse_datatype;
impl rocsparse_format_ {
    #[doc = "< COO sparse matrix format."]
    pub const rocsparse_format_coo: rocsparse_format_ = rocsparse_format_(0);
}
impl rocsparse_format_ {
    #[doc = "< COO AoS sparse matrix format."]
    pub const rocsparse_format_coo_aos: rocsparse_format_ = rocsparse_format_(1);
}
impl rocsparse_format_ {
    #[doc = "< CSR sparse matrix format."]
    pub const rocsparse_format_csr: rocsparse_format_ = rocsparse_format_(2);
}
impl rocsparse_format_ {
    #[doc = "< CSC sparse matrix format."]
    pub const rocsparse_format_csc: rocsparse_format_ = rocsparse_format_(3);
}
impl rocsparse_format_ {
    #[doc = "< ELL sparse matrix format."]
    pub const rocsparse_format_ell: rocsparse_format_ = rocsparse_format_(4);
}
impl rocsparse_format_ {
    #[doc = "< BLOCKED ELL sparse matrix format."]
    pub const rocsparse_format_bell: rocsparse_format_ = rocsparse_format_(5);
}
impl rocsparse_format_ {
    #[doc = "< BSR sparse matrix format."]
    pub const rocsparse_format_bsr: rocsparse_format_ = rocsparse_format_(6);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of sparse matrix formats.\n\n  \\details\n  This is a list of supported \\ref rocsparse_format types that are used to describe a\n  sparse matrix."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_format_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of sparse matrix formats.\n\n  \\details\n  This is a list of supported \\ref rocsparse_format types that are used to describe a\n  sparse matrix."]
pub use self::rocsparse_format_ as rocsparse_format;
impl rocsparse_order_ {
    #[doc = "< Row major."]
    pub const rocsparse_order_row: rocsparse_order_ = rocsparse_order_(0);
}
impl rocsparse_order_ {
    #[doc = "< Column major."]
    pub const rocsparse_order_column: rocsparse_order_ = rocsparse_order_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of dense matrix ordering.\n\n  \\details\n  This is a list of supported \\ref rocsparse_order types that are used to describe the\n  memory layout of a dense matrix"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_order_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of dense matrix ordering.\n\n  \\details\n  This is a list of supported \\ref rocsparse_order types that are used to describe the\n  memory layout of a dense matrix"]
pub use self::rocsparse_order_ as rocsparse_order;
impl rocsparse_spmat_attribute_ {
    #[doc = "< Fill mode attribute."]
    pub const rocsparse_spmat_fill_mode: rocsparse_spmat_attribute_ = rocsparse_spmat_attribute_(0);
}
impl rocsparse_spmat_attribute_ {
    #[doc = "< Diag type attribute."]
    pub const rocsparse_spmat_diag_type: rocsparse_spmat_attribute_ = rocsparse_spmat_attribute_(1);
}
impl rocsparse_spmat_attribute_ {
    #[doc = "< Matrix type attribute."]
    pub const rocsparse_spmat_matrix_type: rocsparse_spmat_attribute_ =
        rocsparse_spmat_attribute_(2);
}
impl rocsparse_spmat_attribute_ {
    #[doc = "< Matrix storage attribute."]
    pub const rocsparse_spmat_storage_mode: rocsparse_spmat_attribute_ =
        rocsparse_spmat_attribute_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of sparse matrix attributes"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spmat_attribute_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of sparse matrix attributes"]
pub use self::rocsparse_spmat_attribute_ as rocsparse_spmat_attribute;
impl rocsparse_itilu0_alg_ {
    #[doc = "< ASynchronous ITILU0 algorithm with in-place storage"]
    pub const rocsparse_itilu0_alg_default: rocsparse_itilu0_alg_ = rocsparse_itilu0_alg_(0);
}
impl rocsparse_itilu0_alg_ {
    pub const rocsparse_itilu0_alg_async_inplace: rocsparse_itilu0_alg_ = rocsparse_itilu0_alg_(1);
}
impl rocsparse_itilu0_alg_ {
    pub const rocsparse_itilu0_alg_async_split: rocsparse_itilu0_alg_ = rocsparse_itilu0_alg_(2);
}
impl rocsparse_itilu0_alg_ {
    pub const rocsparse_itilu0_alg_sync_split: rocsparse_itilu0_alg_ = rocsparse_itilu0_alg_(3);
}
impl rocsparse_itilu0_alg_ {
    pub const rocsparse_itilu0_alg_sync_split_fusion: rocsparse_itilu0_alg_ =
        rocsparse_itilu0_alg_(4);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of Iterative ILU0 algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_itilu0_alg types that are used to perform\n  the iterative ILU0 algorithm."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_itilu0_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of Iterative ILU0 algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_itilu0_alg types that are used to perform\n  the iterative ILU0 algorithm."]
pub use self::rocsparse_itilu0_alg_ as rocsparse_itilu0_alg;
impl rocsparse_gtsv_interleaved_alg_ {
    pub const rocsparse_gtsv_interleaved_alg_default: rocsparse_gtsv_interleaved_alg_ =
        rocsparse_gtsv_interleaved_alg_(0);
}
impl rocsparse_gtsv_interleaved_alg_ {
    pub const rocsparse_gtsv_interleaved_alg_thomas: rocsparse_gtsv_interleaved_alg_ =
        rocsparse_gtsv_interleaved_alg_(1);
}
impl rocsparse_gtsv_interleaved_alg_ {
    pub const rocsparse_gtsv_interleaved_alg_lu: rocsparse_gtsv_interleaved_alg_ =
        rocsparse_gtsv_interleaved_alg_(2);
}
impl rocsparse_gtsv_interleaved_alg_ {
    pub const rocsparse_gtsv_interleaved_alg_qr: rocsparse_gtsv_interleaved_alg_ =
        rocsparse_gtsv_interleaved_alg_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of interleaved gtsv algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_gtsv_interleaved_alg types that are used to perform\n  interleaved tridiagonal solve."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_gtsv_interleaved_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of interleaved gtsv algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_gtsv_interleaved_alg types that are used to perform\n  interleaved tridiagonal solve."]
pub use self::rocsparse_gtsv_interleaved_alg_ as rocsparse_gtsv_interleaved_alg;
impl rocsparse_spmv_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spmv_stage_auto: rocsparse_spmv_stage_ = rocsparse_spmv_stage_(0);
}
impl rocsparse_spmv_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spmv_stage_buffer_size: rocsparse_spmv_stage_ = rocsparse_spmv_stage_(1);
}
impl rocsparse_spmv_stage_ {
    #[doc = "< Preprocess data."]
    pub const rocsparse_spmv_stage_preprocess: rocsparse_spmv_stage_ = rocsparse_spmv_stage_(2);
}
impl rocsparse_spmv_stage_ {
    #[doc = "< Performs the actual SpMV computation."]
    pub const rocsparse_spmv_stage_compute: rocsparse_spmv_stage_ = rocsparse_spmv_stage_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpMV stages.\n\n  \\details\n  This is a list of possible stages during SpMV computation. Typical order is\n  rocsparse_spmv_buffer_size, rocsparse_spmv_preprocess, rocsparse_spmv_compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spmv_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpMV stages.\n\n  \\details\n  This is a list of possible stages during SpMV computation. Typical order is\n  rocsparse_spmv_buffer_size, rocsparse_spmv_preprocess, rocsparse_spmv_compute."]
pub use self::rocsparse_spmv_stage_ as rocsparse_spmv_stage;
impl rocsparse_spmv_alg_ {
    #[doc = "< Default SpMV algorithm for the given format."]
    pub const rocsparse_spmv_alg_default: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(0);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< COO SpMV algorithm 1 (segmented) for COO matrices."]
    pub const rocsparse_spmv_alg_coo: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(1);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< CSR SpMV algorithm 1 (adaptive) for CSR matrices."]
    pub const rocsparse_spmv_alg_csr_adaptive: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(2);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< CSR SpMV algorithm 2 (stream) for CSR matrices."]
    pub const rocsparse_spmv_alg_csr_stream: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(3);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< ELL SpMV algorithm for ELL matrices."]
    pub const rocsparse_spmv_alg_ell: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(4);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< COO SpMV algorithm 2 (atomic) for COO matrices."]
    pub const rocsparse_spmv_alg_coo_atomic: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(5);
}
impl rocsparse_spmv_alg_ {
    #[doc = "< BSR SpMV algorithm 1 for BSR matrices."]
    pub const rocsparse_spmv_alg_bsr: rocsparse_spmv_alg_ = rocsparse_spmv_alg_(6);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpMV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spmv_alg types that are used to perform\n  matrix vector product."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spmv_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpMV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spmv_alg types that are used to perform\n  matrix vector product."]
pub use self::rocsparse_spmv_alg_ as rocsparse_spmv_alg;
impl rocsparse_spsv_alg_ {
    #[doc = "< Default SpSV algorithm for the given format."]
    pub const rocsparse_spsv_alg_default: rocsparse_spsv_alg_ = rocsparse_spsv_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpSV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spsv_alg types that are used to perform\n  triangular solve."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spsv_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpSV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spsv_alg types that are used to perform\n  triangular solve."]
pub use self::rocsparse_spsv_alg_ as rocsparse_spsv_alg;
impl rocsparse_spsv_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spsv_stage_auto: rocsparse_spsv_stage_ = rocsparse_spsv_stage_(0);
}
impl rocsparse_spsv_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spsv_stage_buffer_size: rocsparse_spsv_stage_ = rocsparse_spsv_stage_(1);
}
impl rocsparse_spsv_stage_ {
    #[doc = "< Preprocess data."]
    pub const rocsparse_spsv_stage_preprocess: rocsparse_spsv_stage_ = rocsparse_spsv_stage_(2);
}
impl rocsparse_spsv_stage_ {
    #[doc = "< Performs the actual SpSV computation."]
    pub const rocsparse_spsv_stage_compute: rocsparse_spsv_stage_ = rocsparse_spsv_stage_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpSV stages.\n\n  \\details\n  This is a list of possible stages during SpSV computation. Typical order is\n  rocsparse_spsv_buffer_size, rocsparse_spsv_preprocess, rocsparse_spsv_compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spsv_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpSV stages.\n\n  \\details\n  This is a list of possible stages during SpSV computation. Typical order is\n  rocsparse_spsv_buffer_size, rocsparse_spsv_preprocess, rocsparse_spsv_compute."]
pub use self::rocsparse_spsv_stage_ as rocsparse_spsv_stage;
impl rocsparse_spitsv_alg_ {
    #[doc = "< Default SpITSV algorithm for the given format."]
    pub const rocsparse_spitsv_alg_default: rocsparse_spitsv_alg_ = rocsparse_spitsv_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpITSV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spitsv_alg types that are used to perform\n  triangular solve."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spitsv_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpITSV algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spitsv_alg types that are used to perform\n  triangular solve."]
pub use self::rocsparse_spitsv_alg_ as rocsparse_spitsv_alg;
impl rocsparse_spitsv_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spitsv_stage_auto: rocsparse_spitsv_stage_ = rocsparse_spitsv_stage_(0);
}
impl rocsparse_spitsv_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spitsv_stage_buffer_size: rocsparse_spitsv_stage_ =
        rocsparse_spitsv_stage_(1);
}
impl rocsparse_spitsv_stage_ {
    #[doc = "< Preprocess data."]
    pub const rocsparse_spitsv_stage_preprocess: rocsparse_spitsv_stage_ =
        rocsparse_spitsv_stage_(2);
}
impl rocsparse_spitsv_stage_ {
    #[doc = "< Performs the actual SpITSV computation."]
    pub const rocsparse_spitsv_stage_compute: rocsparse_spitsv_stage_ = rocsparse_spitsv_stage_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpITSV stages.\n\n  \\details\n  This is a list of possible stages during SpITSV computation. Typical order is\n  buffer_size, preprocess, compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spitsv_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpITSV stages.\n\n  \\details\n  This is a list of possible stages during SpITSV computation. Typical order is\n  buffer_size, preprocess, compute."]
pub use self::rocsparse_spitsv_stage_ as rocsparse_spitsv_stage;
impl rocsparse_spsm_alg_ {
    #[doc = "< Default SpSM algorithm for the given format."]
    pub const rocsparse_spsm_alg_default: rocsparse_spsm_alg_ = rocsparse_spsm_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpSM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spsm_alg types that are used to perform\n  triangular solve."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spsm_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpSM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spsm_alg types that are used to perform\n  triangular solve."]
pub use self::rocsparse_spsm_alg_ as rocsparse_spsm_alg;
impl rocsparse_spsm_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spsm_stage_auto: rocsparse_spsm_stage_ = rocsparse_spsm_stage_(0);
}
impl rocsparse_spsm_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spsm_stage_buffer_size: rocsparse_spsm_stage_ = rocsparse_spsm_stage_(1);
}
impl rocsparse_spsm_stage_ {
    #[doc = "< Preprocess data."]
    pub const rocsparse_spsm_stage_preprocess: rocsparse_spsm_stage_ = rocsparse_spsm_stage_(2);
}
impl rocsparse_spsm_stage_ {
    #[doc = "< Performs the actual SpSM computation."]
    pub const rocsparse_spsm_stage_compute: rocsparse_spsm_stage_ = rocsparse_spsm_stage_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpSM stages.\n\n  \\details\n  This is a list of possible stages during SpSM computation. Typical order is\n  rocsparse_spsm_buffer_size, rocsparse_spsm_preprocess, rocsparse_spsm_compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spsm_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpSM stages.\n\n  \\details\n  This is a list of possible stages during SpSM computation. Typical order is\n  rocsparse_spsm_buffer_size, rocsparse_spsm_preprocess, rocsparse_spsm_compute."]
pub use self::rocsparse_spsm_stage_ as rocsparse_spsm_stage;
impl rocsparse_spmm_alg_ {
    #[doc = "< Default SpMM algorithm for the given format."]
    pub const rocsparse_spmm_alg_default: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(0);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for CSR format using row split and shared memory."]
    pub const rocsparse_spmm_alg_csr: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(1);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for COO format using segmented scan."]
    pub const rocsparse_spmm_alg_coo_segmented: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(2);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for COO format using atomics."]
    pub const rocsparse_spmm_alg_coo_atomic: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(3);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for CSR format using row split and shfl."]
    pub const rocsparse_spmm_alg_csr_row_split: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(4);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for CSR format using conversion to COO."]
    pub const rocsparse_spmm_alg_csr_merge: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(5);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for COO format using segmented scan and atomics."]
    pub const rocsparse_spmm_alg_coo_segmented_atomic: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(6);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for Blocked ELL format."]
    pub const rocsparse_spmm_alg_bell: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(7);
}
impl rocsparse_spmm_alg_ {
    #[doc = "< SpMM algorithm for BSR format."]
    pub const rocsparse_spmm_alg_bsr: rocsparse_spmm_alg_ = rocsparse_spmm_alg_(8);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpMM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spmm_alg types that are used to perform\n  matrix vector product."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spmm_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpMM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spmm_alg types that are used to perform\n  matrix vector product."]
pub use self::rocsparse_spmm_alg_ as rocsparse_spmm_alg;
impl rocsparse_sddmm_alg_ {
    #[doc = "< Default sddmm algorithm for the given format."]
    pub const rocsparse_sddmm_alg_default: rocsparse_sddmm_alg_ = rocsparse_sddmm_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of sddmm algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_sddmm_alg types that are used to perform\n  matrix vector product."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_sddmm_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of sddmm algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_sddmm_alg types that are used to perform\n  matrix vector product."]
pub use self::rocsparse_sddmm_alg_ as rocsparse_sddmm_alg;
impl rocsparse_sparse_to_dense_alg_ {
    pub const rocsparse_sparse_to_dense_alg_default: rocsparse_sparse_to_dense_alg_ =
        rocsparse_sparse_to_dense_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of sparse to dense algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_sparse_to_dense_alg types that are used to perform\n  sparse to dense conversion."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_sparse_to_dense_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of sparse to dense algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_sparse_to_dense_alg types that are used to perform\n  sparse to dense conversion."]
pub use self::rocsparse_sparse_to_dense_alg_ as rocsparse_sparse_to_dense_alg;
impl rocsparse_dense_to_sparse_alg_ {
    pub const rocsparse_dense_to_sparse_alg_default: rocsparse_dense_to_sparse_alg_ =
        rocsparse_dense_to_sparse_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of dense to sparse algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_dense_to_sparse_alg types that are used to perform\n  dense to sparse conversion."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_dense_to_sparse_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of dense to sparse algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_dense_to_sparse_alg types that are used to perform\n  dense to sparse conversion."]
pub use self::rocsparse_dense_to_sparse_alg_ as rocsparse_dense_to_sparse_alg;
impl rocsparse_spmm_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spmm_stage_auto: rocsparse_spmm_stage_ = rocsparse_spmm_stage_(0);
}
impl rocsparse_spmm_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spmm_stage_buffer_size: rocsparse_spmm_stage_ = rocsparse_spmm_stage_(1);
}
impl rocsparse_spmm_stage_ {
    #[doc = "< Preprocess data."]
    pub const rocsparse_spmm_stage_preprocess: rocsparse_spmm_stage_ = rocsparse_spmm_stage_(2);
}
impl rocsparse_spmm_stage_ {
    #[doc = "< Performs the actual SpMM computation."]
    pub const rocsparse_spmm_stage_compute: rocsparse_spmm_stage_ = rocsparse_spmm_stage_(3);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpMM stages.\n\n  \\details\n  This is a list of possible stages during SpMM computation. Typical order is\n  rocsparse_spmm_buffer_size, rocsparse_spmm_preprocess, rocsparse_spmm_compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spmm_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpMM stages.\n\n  \\details\n  This is a list of possible stages during SpMM computation. Typical order is\n  rocsparse_spmm_buffer_size, rocsparse_spmm_preprocess, rocsparse_spmm_compute."]
pub use self::rocsparse_spmm_stage_ as rocsparse_spmm_stage;
impl rocsparse_spgemm_stage_ {
    #[doc = "< Automatic stage detection."]
    pub const rocsparse_spgemm_stage_auto: rocsparse_spgemm_stage_ = rocsparse_spgemm_stage_(0);
}
impl rocsparse_spgemm_stage_ {
    #[doc = "< Returns the required buffer size."]
    pub const rocsparse_spgemm_stage_buffer_size: rocsparse_spgemm_stage_ =
        rocsparse_spgemm_stage_(1);
}
impl rocsparse_spgemm_stage_ {
    #[doc = "< Computes number of non-zero entries."]
    pub const rocsparse_spgemm_stage_nnz: rocsparse_spgemm_stage_ = rocsparse_spgemm_stage_(2);
}
impl rocsparse_spgemm_stage_ {
    #[doc = "< Performs the actual SpGEMM computation."]
    pub const rocsparse_spgemm_stage_compute: rocsparse_spgemm_stage_ = rocsparse_spgemm_stage_(3);
}
impl rocsparse_spgemm_stage_ {
    #[doc = "< Performs the actual SpGEMM symbolic computation."]
    pub const rocsparse_spgemm_stage_symbolic: rocsparse_spgemm_stage_ = rocsparse_spgemm_stage_(4);
}
impl rocsparse_spgemm_stage_ {
    #[doc = "< Performs the actual SpGEMM numeric computation."]
    pub const rocsparse_spgemm_stage_numeric: rocsparse_spgemm_stage_ = rocsparse_spgemm_stage_(5);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpGEMM stages.\n\n  \\details\n  This is a list of possible stages during SpGEMM computation. Typical order is\n  rocsparse_spgemm_buffer_size, rocsparse_spgemm_nnz, rocsparse_spgemm_compute."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spgemm_stage_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpGEMM stages.\n\n  \\details\n  This is a list of possible stages during SpGEMM computation. Typical order is\n  rocsparse_spgemm_buffer_size, rocsparse_spgemm_nnz, rocsparse_spgemm_compute."]
pub use self::rocsparse_spgemm_stage_ as rocsparse_spgemm_stage;
impl rocsparse_spgemm_alg_ {
    #[doc = "< Default SpGEMM algorithm for the given format."]
    pub const rocsparse_spgemm_alg_default: rocsparse_spgemm_alg_ = rocsparse_spgemm_alg_(0);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of SpGEMM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spgemm_alg types that are used to perform\n  sparse matrix sparse matrix product."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_spgemm_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of SpGEMM algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_spgemm_alg types that are used to perform\n  sparse matrix sparse matrix product."]
pub use self::rocsparse_spgemm_alg_ as rocsparse_spgemm_alg;
impl rocsparse_gpsv_interleaved_alg_ {
    #[doc = "< Default gpsv algorithm."]
    pub const rocsparse_gpsv_interleaved_alg_default: rocsparse_gpsv_interleaved_alg_ =
        rocsparse_gpsv_interleaved_alg_(0);
}
impl rocsparse_gpsv_interleaved_alg_ {
    #[doc = "< QR algorithm"]
    pub const rocsparse_gpsv_interleaved_alg_qr: rocsparse_gpsv_interleaved_alg_ =
        rocsparse_gpsv_interleaved_alg_(1);
}
#[repr(transparent)]
#[doc = " \\ingroup types_module\n  \\brief List of gpsv algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_gpsv_interleaved_alg types that are used to solve\n  pentadiagonal linear systems."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rocsparse_gpsv_interleaved_alg_(pub ::std::os::raw::c_uint);
#[doc = " \\ingroup types_module\n  \\brief List of gpsv algorithms.\n\n  \\details\n  This is a list of supported \\ref rocsparse_gpsv_interleaved_alg types that are used to solve\n  pentadiagonal linear systems."]
pub use self::rocsparse_gpsv_interleaved_alg_ as rocsparse_gpsv_interleaved_alg;
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a rocsparse handle\n\n  \\details\n  \\p rocsparse_create_handle creates the rocSPARSE library context. It must be\n  initialized before any other rocSPARSE API function is invoked and must be passed to\n  all subsequent library function calls. The handle should be destroyed at the end\n  using rocsparse_destroy_handle().\n\n  @param[out]\n  handle  the pointer to the handle to the rocSPARSE library context.\n\n  \\retval rocsparse_status_success the initialization succeeded.\n  \\retval rocsparse_status_invalid_handle \\p handle pointer is invalid.\n  \\retval rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_create_handle(handle: *mut rocsparse_handle) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a rocsparse handle\n\n  \\details\n  \\p rocsparse_destroy_handle destroys the rocSPARSE library context and releases all\n  resources used by the rocSPARSE library.\n\n  @param[in]\n  handle  the handle to the rocSPARSE library context.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid.\n  \\retval rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_destroy_handle(handle: rocsparse_handle) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify user defined HIP stream\n\n  \\details\n  \\p rocsparse_set_stream specifies the stream to be used by the rocSPARSE library\n  context and all subsequent function calls.\n\n  @param[inout]\n  handle  the handle to the rocSPARSE library context.\n  @param[in]\n  stream  the stream to be used by the rocSPARSE library context.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid.\n\n  \\par Example\n  This example illustrates, how a user defined stream can be used in rocSPARSE.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create stream\n      hipStream_t stream;\n      hipStreamCreate(&stream);\n\n      // Set stream to rocSPARSE handle\n      rocsparse_set_stream(handle, stream);\n\n      // Do some work\n      // ...\n\n      // Clean up\n      rocsparse_destroy_handle(handle);\n      hipStreamDestroy(stream);\n  \\endcode"]
    pub fn rocsparse_set_stream(handle: rocsparse_handle, stream: hipStream_t) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get current stream from library context\n\n  \\details\n  \\p rocsparse_get_stream gets the rocSPARSE library context stream which is currently\n  used for all subsequent function calls.\n\n  @param[in]\n  handle the handle to the rocSPARSE library context.\n  @param[out]\n  stream the stream currently used by the rocSPARSE library context.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid."]
    pub fn rocsparse_get_stream(
        handle: rocsparse_handle,
        stream: *mut hipStream_t,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify pointer mode\n\n  \\details\n  \\p rocsparse_set_pointer_mode specifies the pointer mode to be used by the rocSPARSE\n  library context and all subsequent function calls. By default, all values are passed\n  by reference on the host. Valid pointer modes are \\ref rocsparse_pointer_mode_host\n  or \\p rocsparse_pointer_mode_device.\n\n  @param[in]\n  handle          the handle to the rocSPARSE library context.\n  @param[in]\n  pointer_mode    the pointer mode to be used by the rocSPARSE library context.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid."]
    pub fn rocsparse_set_pointer_mode(
        handle: rocsparse_handle,
        pointer_mode: rocsparse_pointer_mode,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get current pointer mode from library context\n\n  \\details\n  \\p rocsparse_get_pointer_mode gets the rocSPARSE library context pointer mode which\n  is currently used for all subsequent function calls.\n\n  @param[in]\n  handle          the handle to the rocSPARSE library context.\n  @param[out]\n  pointer_mode    the pointer mode that is currently used by the rocSPARSE library\n                  context.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid."]
    pub fn rocsparse_get_pointer_mode(
        handle: rocsparse_handle,
        pointer_mode: *mut rocsparse_pointer_mode,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get rocSPARSE version\n\n  \\details\n  \\p rocsparse_get_version gets the rocSPARSE library version number.\n  - patch = version % 100\n  - minor = version / 100 % 1000\n  - major = version / 100000\n\n  @param[in]\n  handle  the handle to the rocSPARSE library context.\n  @param[out]\n  version the version number of the rocSPARSE library.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid."]
    pub fn rocsparse_get_version(
        handle: rocsparse_handle,
        version: *mut ::std::os::raw::c_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get rocSPARSE git revision\n\n  \\details\n  \\p rocsparse_get_git_rev gets the rocSPARSE library git commit revision (SHA-1).\n\n  @param[in]\n  handle  the handle to the rocSPARSE library context.\n  @param[out]\n  rev     the git commit revision (SHA-1).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle \\p handle is invalid."]
    pub fn rocsparse_get_git_rev(
        handle: rocsparse_handle,
        rev: *mut ::std::os::raw::c_char,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a matrix descriptor\n  \\details\n  \\p rocsparse_create_mat_descr creates a matrix descriptor. It initializes\n  \\ref rocsparse_matrix_type to \\ref rocsparse_matrix_type_general and\n  \\ref rocsparse_index_base to \\ref rocsparse_index_base_zero. It should be destroyed\n  at the end using rocsparse_destroy_mat_descr().\n\n  @param[out]\n  descr   the pointer to the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid."]
    pub fn rocsparse_create_mat_descr(descr: *mut rocsparse_mat_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Copy a matrix descriptor\n  \\details\n  \\p rocsparse_copy_mat_descr copies a matrix descriptor. Both, source and destination\n  matrix descriptors must be initialized prior to calling \\p rocsparse_copy_mat_descr.\n\n  @param[out]\n  dest    the pointer to the destination matrix descriptor.\n  @param[in]\n  src     the pointer to the source matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p src or \\p dest pointer is invalid."]
    pub fn rocsparse_copy_mat_descr(
        dest: rocsparse_mat_descr,
        src: rocsparse_mat_descr,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a matrix descriptor\n\n  \\details\n  \\p rocsparse_destroy_mat_descr destroys a matrix descriptor and releases all\n  resources used by the descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr is invalid."]
    pub fn rocsparse_destroy_mat_descr(descr: rocsparse_mat_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify the index base of a matrix descriptor\n\n  \\details\n  \\p rocsparse_set_mat_index_base sets the index base of a matrix descriptor. Valid\n  options are \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  @param[inout]\n  descr   the matrix descriptor.\n  @param[in]\n  base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid.\n  \\retval rocsparse_status_invalid_value \\p base is invalid."]
    pub fn rocsparse_set_mat_index_base(
        descr: rocsparse_mat_descr,
        base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[doc = " \\ingroup aux_module\n  \\brief Get the index base of a matrix descriptor\n\n  \\details\n  \\p rocsparse_get_mat_index_base returns the index base of a matrix descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\returns \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one."]
    pub fn rocsparse_get_mat_index_base(descr: rocsparse_mat_descr) -> rocsparse_index_base;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify the matrix type of a matrix descriptor\n\n  \\details\n  \\p rocsparse_set_mat_type sets the matrix type of a matrix descriptor. Valid\n  matrix types are \\ref rocsparse_matrix_type_general,\n  \\ref rocsparse_matrix_type_symmetric, \\ref rocsparse_matrix_type_hermitian or\n  \\ref rocsparse_matrix_type_triangular.\n\n  @param[inout]\n  descr   the matrix descriptor.\n  @param[in]\n  type    \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n          \\ref rocsparse_matrix_type_hermitian or\n          \\ref rocsparse_matrix_type_triangular.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid.\n  \\retval rocsparse_status_invalid_value \\p type is invalid."]
    pub fn rocsparse_set_mat_type(
        descr: rocsparse_mat_descr,
        type_: rocsparse_matrix_type,
    ) -> rocsparse_status;
}
extern "C" {
    #[doc = " \\ingroup aux_module\n  \\brief Get the matrix type of a matrix descriptor\n\n  \\details\n  \\p rocsparse_get_mat_type returns the matrix type of a matrix descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\returns    \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or\n              \\ref rocsparse_matrix_type_triangular."]
    pub fn rocsparse_get_mat_type(descr: rocsparse_mat_descr) -> rocsparse_matrix_type;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify the matrix fill mode of a matrix descriptor\n\n  \\details\n  \\p rocsparse_set_mat_fill_mode sets the matrix fill mode of a matrix descriptor.\n  Valid fill modes are \\ref rocsparse_fill_mode_lower or\n  \\ref rocsparse_fill_mode_upper.\n\n  @param[inout]\n  descr       the matrix descriptor.\n  @param[in]\n  fill_mode   \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid.\n  \\retval rocsparse_status_invalid_value \\p fill_mode is invalid."]
    pub fn rocsparse_set_mat_fill_mode(
        descr: rocsparse_mat_descr,
        fill_mode: rocsparse_fill_mode,
    ) -> rocsparse_status;
}
extern "C" {
    #[doc = " \\ingroup aux_module\n  \\brief Get the matrix fill mode of a matrix descriptor\n\n  \\details\n  \\p rocsparse_get_mat_fill_mode returns the matrix fill mode of a matrix descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\returns    \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper."]
    pub fn rocsparse_get_mat_fill_mode(descr: rocsparse_mat_descr) -> rocsparse_fill_mode;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify the matrix diagonal type of a matrix descriptor\n\n  \\details\n  \\p rocsparse_set_mat_diag_type sets the matrix diagonal type of a matrix\n  descriptor. Valid diagonal types are \\ref rocsparse_diag_type_unit or\n  \\ref rocsparse_diag_type_non_unit.\n\n  @param[inout]\n  descr       the matrix descriptor.\n  @param[in]\n  diag_type   \\ref rocsparse_diag_type_unit or \\ref rocsparse_diag_type_non_unit.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid.\n  \\retval rocsparse_status_invalid_value \\p diag_type is invalid."]
    pub fn rocsparse_set_mat_diag_type(
        descr: rocsparse_mat_descr,
        diag_type: rocsparse_diag_type,
    ) -> rocsparse_status;
}
extern "C" {
    #[doc = " \\ingroup aux_module\n  \\brief Get the matrix diagonal type of a matrix descriptor\n\n  \\details\n  \\p rocsparse_get_mat_diag_type returns the matrix diagonal type of a matrix\n  descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\returns \\ref rocsparse_diag_type_unit or \\ref rocsparse_diag_type_non_unit."]
    pub fn rocsparse_get_mat_diag_type(descr: rocsparse_mat_descr) -> rocsparse_diag_type;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Specify the matrix storage mode of a matrix descriptor\n\n  \\details\n  \\p rocsparse_set_mat_storage_mode sets the matrix storage mode of a matrix descriptor.\n  Valid fill modes are \\ref rocsparse_storage_mode_sorted or\n  \\ref rocsparse_storage_mode_unsorted.\n\n  @param[inout]\n  descr           the matrix descriptor.\n  @param[in]\n  storage_mode    \\ref rocsparse_storage_mode_sorted or\n                  \\ref rocsparse_storage_mode_unsorted.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr pointer is invalid.\n  \\retval rocsparse_status_invalid_value \\p storage_mode is invalid."]
    pub fn rocsparse_set_mat_storage_mode(
        descr: rocsparse_mat_descr,
        storage_mode: rocsparse_storage_mode,
    ) -> rocsparse_status;
}
extern "C" {
    #[doc = " \\ingroup aux_module\n  \\brief Get the matrix storage mode of a matrix descriptor\n\n  \\details\n  \\p rocsparse_get_mat_storage_mode returns the matrix storage mode of a matrix descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\returns    \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_unsorted."]
    pub fn rocsparse_get_mat_storage_mode(descr: rocsparse_mat_descr) -> rocsparse_storage_mode;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a \\p HYB matrix structure\n\n  \\details\n  \\p rocsparse_create_hyb_mat creates a structure that holds the matrix in \\p HYB\n  storage format. It should be destroyed at the end using rocsparse_destroy_hyb_mat().\n\n  @param[inout]\n  hyb the pointer to the hybrid matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p hyb pointer is invalid."]
    pub fn rocsparse_create_hyb_mat(hyb: *mut rocsparse_hyb_mat) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Copy a \\p HYB matrix structure\n\n  \\details\n  \\p rocsparse_copy_hyb_mat copies a matrix info structure. Both, source and destination\n  matrix info structure must be initialized prior to calling \\p rocsparse_copy_hyb_mat.\n\n  @param[out]\n  dest    the pointer to the destination matrix info structure.\n  @param[in]\n  src     the pointer to the source matrix info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p hyb pointer is invalid."]
    pub fn rocsparse_copy_hyb_mat(
        dest: rocsparse_hyb_mat,
        src: rocsparse_hyb_mat,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a \\p HYB matrix structure\n\n  \\details\n  \\p rocsparse_destroy_hyb_mat destroys a \\p HYB structure.\n\n  @param[in]\n  hyb the hybrid matrix structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p hyb pointer is invalid.\n  \\retval rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_destroy_hyb_mat(hyb: rocsparse_hyb_mat) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a matrix info structure\n\n  \\details\n  \\p rocsparse_create_mat_info creates a structure that holds the matrix info data\n  that is gathered during the analysis routines available. It should be destroyed\n  at the end using rocsparse_destroy_mat_info().\n\n  @param[inout]\n  info    the pointer to the info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p info pointer is invalid."]
    pub fn rocsparse_create_mat_info(info: *mut rocsparse_mat_info) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Copy a matrix info structure\n  \\details\n  \\p rocsparse_copy_mat_info copies a matrix info structure. Both, source and destination\n  matrix info structure must be initialized prior to calling \\p rocsparse_copy_mat_info.\n\n  @param[out]\n  dest    the pointer to the destination matrix info structure.\n  @param[in]\n  src     the pointer to the source matrix info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p src or \\p dest pointer is invalid."]
    pub fn rocsparse_copy_mat_info(
        dest: rocsparse_mat_info,
        src: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a matrix info structure\n\n  \\details\n  \\p rocsparse_destroy_mat_info destroys a matrix info structure.\n\n  @param[in]\n  info    the info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_destroy_mat_info(info: rocsparse_mat_info) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a color info structure\n\n  \\details\n  \\p rocsparse_create_color_info creates a structure that holds the color info data\n  that is gathered during the analysis routines available. It should be destroyed\n  at the end using rocsparse_destroy_color_info().\n\n  @param[inout]\n  info    the pointer to the info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p info pointer is invalid."]
    pub fn rocsparse_create_color_info(info: *mut rocsparse_color_info) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Copy a color info structure\n  \\details\n  \\p rocsparse_copy_color_info copies a color info structure. Both, source and destination\n  color info structure must be initialized prior to calling \\p rocsparse_copy_color_info.\n\n  @param[out]\n  dest    the pointer to the destination color info structure.\n  @param[in]\n  src     the pointer to the source color info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p src or \\p dest pointer is invalid."]
    pub fn rocsparse_copy_color_info(
        dest: rocsparse_color_info,
        src: rocsparse_color_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a color info structure\n\n  \\details\n  \\p rocsparse_destroy_color_info destroys a color info structure.\n\n  @param[in]\n  info    the info structure.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_destroy_color_info(info: rocsparse_color_info) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse vector descriptor\n  \\details\n  \\p rocsparse_create_spvec_descr creates a sparse vector descriptor. It should be\n  destroyed at the end using rocsparse_destroy_mat_descr().\n\n  @param[out]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  size   size of the sparse vector.\n  @param[in]\n  nnz   number of non-zeros in sparse vector.\n  @param[in]\n  indices   indices of the sparse vector where non-zeros occur (must be array of length \\p nnz ).\n  @param[in]\n  values   non-zero values in the sparse vector (must be array of length \\p nnz ).\n  @param[in]\n  idx_type   \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base   \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p indices or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p size or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_spvec_descr(
        descr: *mut rocsparse_spvec_descr,
        size: i64,
        nnz: i64,
        indices: *mut ::std::os::raw::c_void,
        values: *mut ::std::os::raw::c_void,
        idx_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a sparse vector descriptor\n\n  \\details\n  \\p rocsparse_destroy_spvec_descr destroys a sparse vector descriptor and releases all\n  resources used by the descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr is invalid."]
    pub fn rocsparse_destroy_spvec_descr(descr: rocsparse_spvec_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse vector descriptor\n  \\details\n  \\p rocsparse_spvec_get gets the fields of the sparse vector descriptor\n\n  @param[in]\n  descr   the pointer to the sparse vector descriptor.\n  @param[out]\n  size   size of the sparse vector.\n  @param[out]\n  nnz   number of non-zeros in sparse vector.\n  @param[out]\n  indices   indices of the sparse vector where non-zeros occur (must be array of length \\p nnz ).\n  @param[out]\n  values   non-zero values in the sparse vector (must be array of length \\p nnz ).\n  @param[out]\n  idx_type   \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base   \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p indices or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p size or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_spvec_get(
        descr: rocsparse_spvec_descr,
        size: *mut i64,
        nnz: *mut i64,
        indices: *mut *mut ::std::os::raw::c_void,
        values: *mut *mut ::std::os::raw::c_void,
        idx_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the index base stored in the sparse vector descriptor\n\n  @param[in]\n  descr   the pointer to the sparse vector descriptor.\n  @param[out]\n  idx_base   \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_base is invalid."]
    pub fn rocsparse_spvec_get_index_base(
        descr: rocsparse_spvec_descr,
        idx_base: *mut rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the values array stored in the sparse vector descriptor\n\n  @param[in]\n  descr   the pointer to the sparse vector descriptor.\n  @param[out]\n  values   non-zero values in the sparse vector (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid."]
    pub fn rocsparse_spvec_get_values(
        descr: rocsparse_spvec_descr,
        values: *mut *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the values array in the sparse vector descriptor\n\n  @param[inout]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  values   non-zero values in the sparse vector (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid."]
    pub fn rocsparse_spvec_set_values(
        descr: rocsparse_spvec_descr,
        values: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse COO matrix descriptor\n  \\details\n  \\p rocsparse_create_coo_descr creates a sparse COO matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr       the pointer to the sparse COO matrix descriptor.\n  @param[in]\n  rows        number of rows in the COO matrix.\n  @param[in]\n  cols        number of columns in the COO matrix\n  @param[in]\n  nnz         number of non-zeros in the COO matrix.\n  @param[in]\n  coo_row_ind row indices of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_col_ind column indices of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_val     values of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_row_ind or \\p coo_col_ind or \\p coo_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_coo_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        nnz: i64,
        coo_row_ind: *mut ::std::os::raw::c_void,
        coo_col_ind: *mut ::std::os::raw::c_void,
        coo_val: *mut ::std::os::raw::c_void,
        idx_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse COO AoS matrix descriptor\n  \\details\n  \\p rocsparse_create_coo_aos_descr creates a sparse COO AoS matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr       the pointer to the sparse COO AoS matrix descriptor.\n  @param[in]\n  rows        number of rows in the COO AoS matrix.\n  @param[in]\n  cols        number of columns in the COO AoS matrix\n  @param[in]\n  nnz         number of non-zeros in the COO AoS matrix.\n  @param[in]\n  coo_ind     <row, column> indices of the COO AoS matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_val     values of the COO AoS matrix (must be array of length \\p nnz ).\n  @param[in]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_ind or \\p coo_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_coo_aos_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        nnz: i64,
        coo_ind: *mut ::std::os::raw::c_void,
        coo_val: *mut ::std::os::raw::c_void,
        idx_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse BSR matrix descriptor\n  \\details\n  \\p rocsparse_create_bsr_descr creates a sparse BSR matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr        the pointer to the sparse BSR matrix descriptor.\n  @param[in]\n  mb           number of rows in the BSR matrix.\n  @param[in]\n  nb           number of columns in the BSR matrix\n  @param[in]\n  nnzb         number of non-zeros in the BSR matrix.\n  @param[in]\n  block_dir    direction of the internal block storage.\n  @param[in]\n  block_dim    dimension of the blocks.\n  @param[in]\n  bsr_row_ptr  row offsets of the BSR matrix (must be array of length \\p mb+1 ).\n  @param[in]\n  bsr_col_ind  column indices of the BSR matrix (must be array of length \\p nnzb ).\n  @param[in]\n  bsr_val      values of the BSR matrix (must be array of length \\p nnzb * \\p block_dim * \\p block_dim ).\n  @param[in]\n  row_ptr_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  col_ind_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base     \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type    \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n               \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p bsr_row_ptr or \\p bsr_col_ind or \\p bsr_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p mb or \\p nb or \\p nnzb \\p block_dim is invalid.\n  \\retval rocsparse_status_invalid_value if \\p row_ptr_type or \\p col_ind_type or \\p idx_base or \\p data_type or \\p block_dir is invalid."]
    pub fn rocsparse_create_bsr_descr(
        descr: *mut rocsparse_spmat_descr,
        mb: i64,
        nb: i64,
        nnzb: i64,
        block_dir: rocsparse_direction,
        block_dim: i64,
        bsr_row_ptr: *mut ::std::os::raw::c_void,
        bsr_col_ind: *mut ::std::os::raw::c_void,
        bsr_val: *mut ::std::os::raw::c_void,
        row_ptr_type: rocsparse_indextype,
        col_ind_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse CSR matrix descriptor\n  \\details\n  \\p rocsparse_create_csr_descr creates a sparse CSR matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr        the pointer to the sparse CSR matrix descriptor.\n  @param[in]\n  rows         number of rows in the CSR matrix.\n  @param[in]\n  cols         number of columns in the CSR matrix\n  @param[in]\n  nnz          number of non-zeros in the CSR matrix.\n  @param[in]\n  csr_row_ptr  row offsets of the CSR matrix (must be array of length \\p rows+1 ).\n  @param[in]\n  csr_col_ind  column indices of the CSR matrix (must be array of length \\p nnz ).\n  @param[in]\n  csr_val      values of the CSR matrix (must be array of length \\p nnz ).\n  @param[in]\n  row_ptr_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  col_ind_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base     \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type    \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n               \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p csr_row_ptr or \\p csr_col_ind or \\p csr_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p row_ptr_type or \\p col_ind_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_csr_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        nnz: i64,
        csr_row_ptr: *mut ::std::os::raw::c_void,
        csr_col_ind: *mut ::std::os::raw::c_void,
        csr_val: *mut ::std::os::raw::c_void,
        row_ptr_type: rocsparse_indextype,
        col_ind_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse CSC matrix descriptor\n  \\details\n  \\p rocsparse_create_csc_descr creates a sparse CSC matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr       the pointer to the sparse CSC matrix descriptor.\n  @param[in]\n  rows         number of rows in the CSC matrix.\n  @param[in]\n  cols         number of columns in the CSC matrix\n  @param[in]\n  nnz          number of non-zeros in the CSC matrix.\n  @param[in]\n  csc_col_ptr  column offsets of the CSC matrix (must be array of length \\p cols+1 ).\n  @param[in]\n  csc_row_ind  row indices of the CSC matrix (must be array of length \\p nnz ).\n  @param[in]\n  csc_val      values of the CSC matrix (must be array of length \\p nnz ).\n  @param[in]\n  col_ptr_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  row_ind_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base     \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type    \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n               \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p csc_col_ptr or \\p csc_row_ind or \\p csc_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p col_ptr_type or \\p row_ind_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_csc_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        nnz: i64,
        csc_col_ptr: *mut ::std::os::raw::c_void,
        csc_row_ind: *mut ::std::os::raw::c_void,
        csc_val: *mut ::std::os::raw::c_void,
        col_ptr_type: rocsparse_indextype,
        row_ind_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse ELL matrix descriptor\n  \\details\n  \\p rocsparse_create_ell_descr creates a sparse ELL matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr       the pointer to the sparse ELL matrix descriptor.\n  @param[in]\n  rows        number of rows in the ELL matrix.\n  @param[in]\n  cols        number of columns in the ELL matrix\n  @param[in]\n  ell_col_ind column indices of the ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  ell_val     values of the ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  ell_width   width of the ELL matrix.\n  @param[in]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p ell_col_ind or \\p ell_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p ell_width is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_ell_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        ell_col_ind: *mut ::std::os::raw::c_void,
        ell_val: *mut ::std::os::raw::c_void,
        ell_width: i64,
        idx_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a sparse blocked ELL matrix descriptor\n  \\details\n  \\p rocsparse_create_bell_descr creates a sparse blocked ELL matrix descriptor. It should be\n  destroyed at the end using \\p rocsparse_destroy_spmat_descr.\n\n  @param[out]\n  descr         the pointer to the sparse blocked ELL matrix descriptor.\n  @param[in]\n  rows          number of rows in the blocked ELL matrix.\n  @param[in]\n  cols          number of columns in the blocked ELL matrix\n  @param[in]\n  ell_block_dir \\ref rocsparse_direction_row or \\ref rocsparse_direction_column.\n  @param[in]\n  ell_block_dim block dimension of the sparse blocked ELL matrix.\n  @param[in]\n  ell_cols      column indices of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  ell_col_ind   column indices of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  ell_val       values of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  idx_type      \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[in]\n  idx_base      \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  data_type     \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n                \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p ell_cols or \\p ell_col_ind or \\p ell_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_create_bell_descr(
        descr: *mut rocsparse_spmat_descr,
        rows: i64,
        cols: i64,
        ell_block_dir: rocsparse_direction,
        ell_block_dim: i64,
        ell_cols: i64,
        ell_col_ind: *mut ::std::os::raw::c_void,
        ell_val: *mut ::std::os::raw::c_void,
        idx_type: rocsparse_indextype,
        idx_base: rocsparse_index_base,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a sparse matrix descriptor\n\n  \\details\n  \\p rocsparse_destroy_spmat_descr destroys a sparse matrix descriptor and releases all\n  resources used by the descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr is invalid."]
    pub fn rocsparse_destroy_spmat_descr(descr: rocsparse_spmat_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse COO matrix descriptor\n  \\details\n  \\p rocsparse_coo_get gets the fields of the sparse COO matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse COO matrix descriptor.\n  @param[out]\n  rows        number of rows in the sparse COO matrix.\n  @param[out]\n  cols        number of columns in the sparse COO matrix.\n  @param[out]\n  nnz         number of non-zeros in sparse COO matrix.\n  @param[out]\n  coo_row_ind row indices of the COO matrix (must be array of length \\p nnz ).\n  @param[out]\n  coo_col_ind column indices of the COO matrix (must be array of length \\p nnz ).\n  @param[out]\n  coo_val     values of the COO matrix (must be array of length \\p nnz ).\n  @param[out]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_row_ind or \\p coo_col_ind or \\p coo_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_coo_get(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        nnz: *mut i64,
        coo_row_ind: *mut *mut ::std::os::raw::c_void,
        coo_col_ind: *mut *mut ::std::os::raw::c_void,
        coo_val: *mut *mut ::std::os::raw::c_void,
        idx_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse COO AoS matrix descriptor\n  \\details\n  \\p rocsparse_coo_aos_get gets the fields of the sparse COO AoS matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse COO AoS matrix descriptor.\n  @param[out]\n  rows        number of rows in the sparse COO AoS matrix.\n  @param[out]\n  cols        number of columns in the sparse COO AoS matrix.\n  @param[out]\n  nnz         number of non-zeros in sparse COO AoS matrix.\n  @param[out]\n  coo_ind     <row, columns> indices of the COO AoS matrix (must be array of length \\p nnz ).\n  @param[out]\n  coo_val     values of the COO AoS matrix (must be array of length \\p nnz ).\n  @param[out]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_ind or \\p coo_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_coo_aos_get(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        nnz: *mut i64,
        coo_ind: *mut *mut ::std::os::raw::c_void,
        coo_val: *mut *mut ::std::os::raw::c_void,
        idx_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse CSR matrix descriptor\n  \\details\n  \\p rocsparse_csr_get gets the fields of the sparse CSR matrix descriptor\n\n  @param[in]\n  descr        the pointer to the sparse CSR matrix descriptor.\n  @param[out]\n  rows         number of rows in the CSR matrix.\n  @param[out]\n  cols         number of columns in the CSR matrix\n  @param[out]\n  nnz          number of non-zeros in the CSR matrix.\n  @param[out]\n  csr_row_ptr  row offsets of the CSR matrix (must be array of length \\p rows+1 ).\n  @param[out]\n  csr_col_ind  column indices of the CSR matrix (must be array of length \\p nnz ).\n  @param[out]\n  csr_val      values of the CSR matrix (must be array of length \\p nnz ).\n  @param[out]\n  row_ptr_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  col_ind_type \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base     \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type    \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n               \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p csr_row_ptr or \\p csr_col_ind or \\p csr_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_value if \\p row_ptr_type or \\p col_ind_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_csr_get(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        nnz: *mut i64,
        csr_row_ptr: *mut *mut ::std::os::raw::c_void,
        csr_col_ind: *mut *mut ::std::os::raw::c_void,
        csr_val: *mut *mut ::std::os::raw::c_void,
        row_ptr_type: *mut rocsparse_indextype,
        col_ind_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse ELL matrix descriptor\n  \\details\n  \\p rocsparse_ell_get gets the fields of the sparse ELL matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse ELL matrix descriptor.\n  @param[out]\n  rows        number of rows in the ELL matrix.\n  @param[out]\n  cols        number of columns in the ELL matrix\n  @param[out]\n  ell_col_ind column indices of the ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[out]\n  ell_val     values of the ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[out]\n  ell_width   width of the ELL matrix.\n  @param[out]\n  idx_type    \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p ell_col_ind or \\p ell_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p ell_width is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_ell_get(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        ell_col_ind: *mut *mut ::std::os::raw::c_void,
        ell_val: *mut *mut ::std::os::raw::c_void,
        ell_width: *mut i64,
        idx_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the sparse blocked ELL matrix descriptor\n  \\details\n  \\p rocsparse_bell_get gets the fields of the sparse blocked ELL matrix descriptor\n\n  @param[in]\n  descr         the pointer to the sparse blocked ELL matrix descriptor.\n  @param[out]\n  rows          number of rows in the blocked ELL matrix.\n  @param[out]\n  cols          number of columns in the blocked ELL matrix\n  @param[out]\n  ell_block_dir \\ref rocsparse_direction_row or \\ref rocsparse_direction_column.\n  @param[out]\n  ell_block_dim block dimension of the sparse blocked ELL matrix.\n  @param[out]\n  ell_cols      column indices of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[out]\n  ell_col_ind   column indices of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[out]\n  ell_val       values of the blocked ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[out]\n  idx_type      \\ref rocsparse_indextype_i32 or \\ref rocsparse_indextype_i64.\n  @param[out]\n  idx_base      \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[out]\n  data_type     \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n                \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p ell_cols or \\p ell_col_ind or \\p ell_val is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p ell_block_dim is invalid.\n  \\retval rocsparse_status_invalid_value if \\p ell_block_dir or \\p idx_type or \\p idx_base or \\p data_type is invalid."]
    pub fn rocsparse_bell_get(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        ell_block_dir: *mut rocsparse_direction,
        ell_block_dim: *mut i64,
        ell_cols: *mut i64,
        ell_col_ind: *mut *mut ::std::os::raw::c_void,
        ell_val: *mut *mut ::std::os::raw::c_void,
        idx_type: *mut rocsparse_indextype,
        idx_base: *mut rocsparse_index_base,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the row indices, column indices and values array in the sparse COO matrix descriptor\n\n  @param[inout]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  coo_row_ind row indices of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_col_ind column indices of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_val     values of the COO matrix (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_row_ind or \\p coo_col_ind or \\p coo_val is invalid."]
    pub fn rocsparse_coo_set_pointers(
        descr: rocsparse_spmat_descr,
        coo_row_ind: *mut ::std::os::raw::c_void,
        coo_col_ind: *mut ::std::os::raw::c_void,
        coo_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the <row, column> indices and values array in the sparse COO AoS matrix descriptor\n\n  @param[inout]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  coo_ind <row, column> indices of the COO matrix (must be array of length \\p nnz ).\n  @param[in]\n  coo_val values of the COO matrix (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_ind or \\p coo_val is invalid."]
    pub fn rocsparse_coo_aos_set_pointers(
        descr: rocsparse_spmat_descr,
        coo_ind: *mut ::std::os::raw::c_void,
        coo_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the row offsets, column indices and values array in the sparse CSR matrix descriptor\n\n  @param[inout]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  csr_row_ptr  row offsets of the CSR matrix (must be array of length \\p rows+1 ).\n  @param[in]\n  csr_col_ind  column indices of the CSR matrix (must be array of length \\p nnz ).\n  @param[in]\n  csr_val      values of the CSR matrix (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p coo_ind or \\p coo_val is invalid."]
    pub fn rocsparse_csr_set_pointers(
        descr: rocsparse_spmat_descr,
        csr_row_ptr: *mut ::std::os::raw::c_void,
        csr_col_ind: *mut ::std::os::raw::c_void,
        csr_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the column offsets, row indices and values array in the sparse CSC matrix descriptor\n\n  @param[inout]\n  descr       the pointer to the sparse vector descriptor.\n  @param[in]\n  csc_col_ptr column offsets of the CSC matrix (must be array of length \\p cols+1 ).\n  @param[in]\n  csc_row_ind row indices of the CSC matrix (must be array of length \\p nnz ).\n  @param[in]\n  csc_val     values of the CSC matrix (must be array of length \\p nnz ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p csc_col_ptr or \\p csc_row_ind or \\p csc_val is invalid."]
    pub fn rocsparse_csc_set_pointers(
        descr: rocsparse_spmat_descr,
        csc_col_ptr: *mut ::std::os::raw::c_void,
        csc_row_ind: *mut ::std::os::raw::c_void,
        csc_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the column indices and values array in the sparse ELL matrix descriptor\n\n  @param[inout]\n  descr       the pointer to the sparse vector descriptor.\n  @param[in]\n  ell_col_ind column indices of the ELL matrix (must be array of length \\p rows*ell_width ).\n  @param[in]\n  ell_val     values of the ELL matrix (must be array of length \\p rows*ell_width ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p ell_col_ind or \\p ell_val is invalid."]
    pub fn rocsparse_ell_set_pointers(
        descr: rocsparse_spmat_descr,
        ell_col_ind: *mut ::std::os::raw::c_void,
        ell_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the row offsets, column indices and values array in the sparse BSR matrix descriptor\n\n  @param[inout]\n  descr   the pointer to the sparse vector descriptor.\n  @param[in]\n  bsr_row_ptr  row offsets of the BSR matrix (must be array of length \\p rows+1 ).\n  @param[in]\n  bsr_col_ind  column indices of the BSR matrix (must be array of length \\p nnzb ).\n  @param[in]\n  bsr_val      values of the BSR matrix (must be array of length \\p nnzb*block_dim*block_dim ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p bsr_row_ptr or \\p bsr_col_ind or \\p bsr_val is invalid."]
    pub fn rocsparse_bsr_set_pointers(
        descr: rocsparse_spmat_descr,
        bsr_row_ptr: *mut ::std::os::raw::c_void,
        bsr_col_ind: *mut ::std::os::raw::c_void,
        bsr_val: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the number of rows, columns and non-zeros from the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[out]\n  rows        number of rows in the sparse matrix.\n  @param[out]\n  cols        number of columns in the sparse matrix.\n  @param[out]\n  nnz         number of non-zeros in sparse matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p nnz is invalid."]
    pub fn rocsparse_spmat_get_size(
        descr: rocsparse_spmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        nnz: *mut i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the sparse matrix format from the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[out]\n  format      \\ref rocsparse_format_coo or \\ref rocsparse_format_coo_aos or\n              \\ref rocsparse_format_csr or \\ref rocsparse_format_csc or\n              \\ref rocsparse_format_ell\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_value if \\p format is invalid."]
    pub fn rocsparse_spmat_get_format(
        descr: rocsparse_spmat_descr,
        format: *mut rocsparse_format,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the sparse matrix index base from the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[out]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_value if \\p idx_base is invalid."]
    pub fn rocsparse_spmat_get_index_base(
        descr: rocsparse_spmat_descr,
        idx_base: *mut rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the values array from the sparse matrix descriptor\n\n  @param[in]\n  descr     the pointer to the sparse matrix descriptor.\n  @param[out]\n  values    values array of the sparse matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid."]
    pub fn rocsparse_spmat_get_values(
        descr: rocsparse_spmat_descr,
        values: *mut *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the values array in the sparse matrix descriptor\n\n  @param[inout]\n  descr     the pointer to the sparse matrix descriptor.\n  @param[in]\n  values    values array of the sparse matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid."]
    pub fn rocsparse_spmat_set_values(
        descr: rocsparse_spmat_descr,
        values: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the strided batch count from the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[out]\n  batch_count batch_count of the sparse matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count is invalid."]
    pub fn rocsparse_spmat_get_strided_batch(
        descr: rocsparse_spmat_descr,
        batch_count: *mut ::std::os::raw::c_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the strided batch count in the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[in]\n  batch_count batch_count of the sparse matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count is invalid."]
    pub fn rocsparse_spmat_set_strided_batch(
        descr: rocsparse_spmat_descr,
        batch_count: ::std::os::raw::c_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the batch count and batch stride in the sparse COO matrix descriptor\n\n  @param[inout]\n  descr        the pointer to the sparse COO matrix descriptor.\n  @param[in]\n  batch_count  batch_count of the sparse COO matrix.\n  @param[in]\n  batch_stride batch stride of the sparse COO matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count or \\p batch_stride is invalid."]
    pub fn rocsparse_coo_set_strided_batch(
        descr: rocsparse_spmat_descr,
        batch_count: ::std::os::raw::c_int,
        batch_stride: i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the batch count, row offset batch stride and the column indices batch stride in the sparse CSR matrix descriptor\n\n  @param[inout]\n  descr                       the pointer to the sparse CSR matrix descriptor.\n  @param[in]\n  batch_count                 batch_count of the sparse CSR matrix.\n  @param[in]\n  offsets_batch_stride        row offset batch stride of the sparse CSR matrix.\n  @param[in]\n  columns_values_batch_stride column indices batch stride of the sparse CSR matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count or \\p offsets_batch_stride or \\p columns_values_batch_stride is invalid."]
    pub fn rocsparse_csr_set_strided_batch(
        descr: rocsparse_spmat_descr,
        batch_count: ::std::os::raw::c_int,
        offsets_batch_stride: i64,
        columns_values_batch_stride: i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the batch count, column offset batch stride and the row indices batch stride in the sparse CSC matrix descriptor\n\n  @param[inout]\n  descr                       the pointer to the sparse CSC matrix descriptor.\n  @param[in]\n  batch_count                 batch_count of the sparse CSC matrix.\n  @param[in]\n  offsets_batch_stride        column offset batch stride of the sparse CSC matrix.\n  @param[in]\n  rows_values_batch_stride    row indices batch stride of the sparse CSC matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count or \\p offsets_batch_stride or \\p rows_values_batch_stride is invalid."]
    pub fn rocsparse_csc_set_strided_batch(
        descr: rocsparse_spmat_descr,
        batch_count: ::std::os::raw::c_int,
        offsets_batch_stride: i64,
        rows_values_batch_stride: i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the requested attribute data from the sparse matrix descriptor\n\n  @param[in]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[in]\n  attribute \\ref rocsparse_spmat_fill_mode or \\ref rocsparse_spmat_diag_type or\n            \\ref rocsparse_spmat_matrix_type or \\ref rocsparse_spmat_storage_mode\n  @param[out]\n  data      attribute data\n  @param[in]\n  data_size attribute data size.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p data is invalid.\n  \\retval rocsparse_status_invalid_value if \\p attribute is invalid.\n  \\retval rocsparse_status_invalid_size if \\p data_size is invalid."]
    pub fn rocsparse_spmat_get_attribute(
        descr: rocsparse_spmat_descr,
        attribute: rocsparse_spmat_attribute,
        data: *mut ::std::os::raw::c_void,
        data_size: usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the requested attribute data in the sparse matrix descriptor\n\n  @param[inout]\n  descr       the pointer to the sparse matrix descriptor.\n  @param[in]\n  attribute \\ref rocsparse_spmat_fill_mode or \\ref rocsparse_spmat_diag_type or\n            \\ref rocsparse_spmat_matrix_type or \\ref rocsparse_spmat_storage_mode\n  @param[in]\n  data      attribute data\n  @param[in]\n  data_size attribute data size.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p data is invalid.\n  \\retval rocsparse_status_invalid_value if \\p attribute is invalid.\n  \\retval rocsparse_status_invalid_size if \\p data_size is invalid."]
    pub fn rocsparse_spmat_set_attribute(
        descr: rocsparse_spmat_descr,
        attribute: rocsparse_spmat_attribute,
        data: *const ::std::os::raw::c_void,
        data_size: usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a dense vector descriptor\n  \\details\n  \\p rocsparse_create_dnvec_descr creates a dense vector descriptor. It should be\n  destroyed at the end using rocsparse_destroy_dnvec_descr().\n\n  @param[out]\n  descr   the pointer to the dense vector descriptor.\n  @param[in]\n  size   size of the dense vector.\n  @param[in]\n  values   non-zero values in the dense vector (must be array of length \\p size ).\n  @param[in]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p size is invalid.\n  \\retval rocsparse_status_invalid_value if \\p data_type is invalid."]
    pub fn rocsparse_create_dnvec_descr(
        descr: *mut rocsparse_dnvec_descr,
        size: i64,
        values: *mut ::std::os::raw::c_void,
        data_type: rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a dense vector descriptor\n\n  \\details\n  \\p rocsparse_destroy_dnvec_descr destroys a dense vector descriptor and releases all\n  resources used by the descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr is invalid."]
    pub fn rocsparse_destroy_dnvec_descr(descr: rocsparse_dnvec_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the dense vector descriptor\n  \\details\n  \\p rocsparse_dnvec_get gets the fields of the dense vector descriptor\n\n  @param[in]\n  descr   the pointer to the dense vector descriptor.\n  @param[out]\n  size   size of the dense vector.\n  @param[out]\n  values   non-zero values in the dense vector (must be array of length \\p size ).\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p size is invalid.\n  \\retval rocsparse_status_invalid_value if \\p data_type is invalid."]
    pub fn rocsparse_dnvec_get(
        descr: rocsparse_dnvec_descr,
        size: *mut i64,
        values: *mut *mut ::std::os::raw::c_void,
        data_type: *mut rocsparse_datatype,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the values array from a dense vector descriptor\n\n  @param[in]\n  descr   the matrix descriptor.\n  @param[out]\n  values   non-zero values in the dense vector (must be array of length \\p size ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr or \\p values is invalid."]
    pub fn rocsparse_dnvec_get_values(
        descr: rocsparse_dnvec_descr,
        values: *mut *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the values array in a dense vector descriptor\n\n  @param[inout]\n  descr   the matrix descriptor.\n  @param[in]\n  values   non-zero values in the dense vector (must be array of length \\p size ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr or \\p values is invalid."]
    pub fn rocsparse_dnvec_set_values(
        descr: rocsparse_dnvec_descr,
        values: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Create a dense matrix descriptor\n  \\details\n  \\p rocsparse_create_dnmat_descr creates a dense matrix descriptor. It should be\n  destroyed at the end using rocsparse_destroy_dnmat_descr().\n\n  @param[out]\n  descr     the pointer to the dense matrix descriptor.\n  @param[in]\n  rows      number of rows in the dense matrix.\n  @param[in]\n  cols      number of columns in the dense matrix.\n  @param[in]\n  ld        leading dimension of the dense matrix.\n  @param[in]\n  values    non-zero values in the dense vector (must be array of length\n            \\p ld*rows if \\p order=rocsparse_order_column or \\p ld*cols if \\p order=rocsparse_order_row ).\n  @param[in]\n  data_type \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n            \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n  @param[in]\n  order     \\ref rocsparse_order_row or \\ref rocsparse_order_column.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p ld is invalid.\n  \\retval rocsparse_status_invalid_value if \\p data_type or \\p order is invalid."]
    pub fn rocsparse_create_dnmat_descr(
        descr: *mut rocsparse_dnmat_descr,
        rows: i64,
        cols: i64,
        ld: i64,
        values: *mut ::std::os::raw::c_void,
        data_type: rocsparse_datatype,
        order: rocsparse_order,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Destroy a dense matrix descriptor\n\n  \\details\n  \\p rocsparse_destroy_dnmat_descr destroys a dense matrix descriptor and releases all\n  resources used by the descriptor.\n\n  @param[in]\n  descr   the matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr is invalid."]
    pub fn rocsparse_destroy_dnmat_descr(descr: rocsparse_dnmat_descr) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the fields of the dense matrix descriptor\n\n  @param[in]\n  descr   the pointer to the dense matrix descriptor.\n  @param[out]\n  rows   number of rows in the dense matrix.\n  @param[out]\n  cols   number of columns in the dense matrix.\n  @param[out]\n  ld        leading dimension of the dense matrix.\n  @param[out]\n  values    non-zero values in the dense matrix (must be array of length\n            \\p ld*rows if \\p order=rocsparse_order_column or \\p ld*cols if \\p order=rocsparse_order_row ).\n  @param[out]\n  data_type   \\ref rocsparse_datatype_f32_r, \\ref rocsparse_datatype_f64_r,\n              \\ref rocsparse_datatype_f32_c or \\ref rocsparse_datatype_f64_c.\n  @param[out]\n  order     \\ref rocsparse_order_row or \\ref rocsparse_order_column.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid.\n  \\retval rocsparse_status_invalid_size if \\p rows or \\p cols or \\p ld is invalid.\n  \\retval rocsparse_status_invalid_value if \\p data_type or \\p order is invalid."]
    pub fn rocsparse_dnmat_get(
        descr: rocsparse_dnmat_descr,
        rows: *mut i64,
        cols: *mut i64,
        ld: *mut i64,
        values: *mut *mut ::std::os::raw::c_void,
        data_type: *mut rocsparse_datatype,
        order: *mut rocsparse_order,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the values array from the dense matrix descriptor\n\n  @param[in]\n  descr   the pointer to the dense matrix descriptor.\n  @param[out]\n  values    non-zero values in the dense matrix (must be array of length\n            \\p ld*rows if \\p order=rocsparse_order_column or \\p ld*cols if \\p order=rocsparse_order_row ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr or \\p values is invalid."]
    pub fn rocsparse_dnmat_get_values(
        descr: rocsparse_dnmat_descr,
        values: *mut *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the values array in a dense matrix descriptor\n\n  @param[inout]\n  descr   the matrix descriptor.\n  @param[in]\n  values    non-zero values in the dense matrix (must be array of length\n            \\p ld*rows if \\p order=rocsparse_order_column or \\p ld*cols if \\p order=rocsparse_order_row ).\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer \\p descr or \\p values is invalid."]
    pub fn rocsparse_dnmat_set_values(
        descr: rocsparse_dnmat_descr,
        values: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Get the batch count and batch stride from the dense matrix descriptor\n\n  @param[in]\n  descr        the pointer to the dense matrix descriptor.\n  @param[out]\n  batch_count  the batch count in the dense matrix.\n  @param[out]\n  batch_stride the batch stride in the dense matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count or \\p batch_stride is invalid."]
    pub fn rocsparse_dnmat_get_strided_batch(
        descr: rocsparse_dnmat_descr,
        batch_count: *mut ::std::os::raw::c_int,
        batch_stride: *mut i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup aux_module\n  \\brief Set the batch count and batch stride in the dense matrix descriptor\n\n  @param[inout]\n  descr        the pointer to the dense matrix descriptor.\n  @param[in]\n  batch_count  the batch count in the dense matrix.\n  @param[in]\n  batch_stride the batch stride in the dense matrix.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_pointer if \\p descr is invalid.\n  \\retval rocsparse_status_invalid_size if \\p batch_count or \\p batch_stride is invalid."]
    pub fn rocsparse_dnmat_set_strided_batch(
        descr: rocsparse_dnmat_descr,
        batch_count: ::std::os::raw::c_int,
        batch_stride: i64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_csr_buffer_size computes the required buffer size needed when calling \\p rocsparse_check_matrix_csr\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_csr(), rocsparse_dcheck_matrix_csr(),\n              rocsparse_ccheck_matrix_csr() and rocsparse_zcheck_matrix_csr().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p csr_val, \\p csr_row_ptr, \\p csr_col_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_csr checks if the input CSR matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p csr_val, \\p csr_row_ptr, \\p csr_col_ind, \\p temp_buffer or \\p data_status pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_coo_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_coo\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  coo_val     array of \\p nnz elements of the sparse COO matrix.\n  @param[in]\n  coo_row_ind array of \\p nnz elements containing the row indices of the sparse\n              COO matrix.\n  @param[in]\n  coo_col_ind array of \\p nnz elements containing the column indices of the sparse\n              COO matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_coo(), rocsparse_dcheck_matrix_coo(),\n              rocsparse_ccheck_matrix_coo() and rocsparse_zcheck_matrix_coo().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p coo_val, \\p coo_row_ind, \\p coo_col_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_coo_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const f32,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_coo_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const f64,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_coo_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const rocsparse_float_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_coo_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const rocsparse_double_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_coo checks if the input COO matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse COO matrix.\n  @param[in]\n  n           number of columns of the sparse COO matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse COO matrix.\n  @param[in]\n  coo_val     array of \\p nnz elements of the sparse COO matrix.\n  @param[in]\n  coo_row_ind array of \\p nnz elements containing the row indices of the sparse\n              COO matrix.\n  @param[in]\n  coo_col_ind array of \\p nnz elements containing the column indices of the sparse\n              COO matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p coo_val, \\p coo_row_ind, \\p coo_col_ind, \\p temp_buffer or \\p data_status  pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const f32,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const f64,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const rocsparse_float_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_val: *const rocsparse_double_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_gebsr_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_gebsr\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir          matrix storage of GEBSR blocks.\n  @param[in]\n  mb           number of block rows of the sparse GEBSR matrix.\n  @param[in]\n  nb           number of block columns of the sparse GEBSR matrix.\n  @param[in]\n  nnzb         number of non-zero blocks of the sparse GEBSR matrix.\n  @param[in]\n  row_block_dim row block dimension of the sparse GEBSR matrix.\n  @param[in]\n  col_block_dim column block dimension of the sparse GEBSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb elements of the sparse GEBSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every row of the\n              sparse GEBSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the column indices of the sparse\n              GEBSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_gebsr(), rocsparse_dcheck_matrix_gebsr(),\n              rocsparse_ccheck_matrix_gebsr() and rocsparse_zcheck_matrix_gebsr().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p dir or \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p mb \\p nb \\p nnzb \\p row_block_dim or \\p col_block_dim is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p bsr_val, \\p bsr_row_ptr, \\p bsr_col_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_gebsr checks if the input GEBSR matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir          matrix storage of GEBSR blocks.\n  @param[in]\n  mb           number of block rows of the sparse GEBSR matrix.\n  @param[in]\n  nb           number of block columns of the sparse GEBSR matrix.\n  @param[in]\n  nnzb         number of non-zero blocks of the sparse GEBSR matrix.\n  @param[in]\n  row_block_dim row block dimension of the sparse GEBSR matrix.\n  @param[in]\n  col_block_dim column block dimension of the sparse GEBSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb elements of the sparse GEBSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every row of the\n              sparse GEBSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the column indices of the sparse\n              GEBSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p dir or \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p mb \\p nb \\p nnzb \\p row_block_dim or \\p col_block_dim is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p bsr_val, \\p bsr_row_ptr, \\p bsr_col_ind, \\p temp_buffer or \\p data_status pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_gebsc_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_gebsc\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir          matrix storage of GEBSC blocks.\n  @param[in]\n  mb           number of block rows of the sparse GEBSC matrix.\n  @param[in]\n  nb           number of block columns of the sparse GEBSC matrix.\n  @param[in]\n  nnzb         number of non-zero blocks of the sparse GEBSC matrix.\n  @param[in]\n  row_block_dim row block dimension of the sparse GEBSC matrix.\n  @param[in]\n  col_block_dim column block dimension of the sparse GEBSC matrix.\n  @param[in]\n  bsc_val     array of \\p nnzb elements of the sparse GEBSC matrix.\n  @param[in]\n  bsc_col_ptr array of \\p nb+1 elements that point to the start of every column of the\n              sparse GEBSC matrix.\n  @param[in]\n  bsc_row_ind array of \\p nnzb elements containing the row indices of the sparse\n              GEBSC matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_gebsc(), rocsparse_dcheck_matrix_gebsc(),\n              rocsparse_ccheck_matrix_gebsc() and rocsparse_zcheck_matrix_gebsc().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p dir or \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p mb \\p nb \\p nnzb \\p row_block_dim or \\p col_block_dim is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p bsc_val, \\p bsc_col_ptr, \\p bsc_row_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_gebsc_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const f32,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_gebsc_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const f64,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_gebsc_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const rocsparse_float_complex,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_gebsc_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const rocsparse_double_complex,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_gebsc checks if the input GEBSC matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir          matrix storage of GEBSC blocks.\n  @param[in]\n  mb           number of block rows of the sparse GEBSC matrix.\n  @param[in]\n  nb           number of block columns of the sparse GEBSC matrix.\n  @param[in]\n  nnzb         number of non-zero blocks of the sparse GEBSC matrix.\n  @param[in]\n  row_block_dim row block dimension of the sparse GEBSC matrix.\n  @param[in]\n  col_block_dim column block dimension of the sparse GEBSC matrix.\n  @param[in]\n  bsc_val     array of \\p nnzb elements of the sparse GEBSC matrix.\n  @param[in]\n  bsc_col_ptr array of \\p nb+1 elements that point to the start of every column of the\n              sparse GEBSC matrix.\n  @param[in]\n  bsc_row_ind array of \\p nnzb elements containing the row indices of the sparse\n              GEBSC matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p dir or \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p mb \\p nb \\p nnzb \\p row_block_dim or \\p col_block_dim is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p bsc_val, \\p bsc_col_ptr, \\p bsc_row_ind, \\p temp_buffer or \\p data_status pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_gebsc(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const f32,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_gebsc(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const f64,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_gebsc(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const rocsparse_float_complex,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_gebsc(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *const rocsparse_double_complex,
        bsc_col_ptr: *const rocsparse_int,
        bsc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_csc_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_csc\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSC matrix.\n  @param[in]\n  n           number of columns of the sparse CSC matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSC matrix.\n  @param[in]\n  csc_val     array of \\p nnz elements of the sparse CSC matrix.\n  @param[in]\n  csc_col_ptr array of \\p m+1 elements that point to the start of every column of the\n              sparse CSC matrix.\n  @param[in]\n  csc_row_ind array of \\p nnz elements containing the row indices of the sparse\n              CSC matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_csc(), rocsparse_dcheck_matrix_csc(),\n              rocsparse_ccheck_matrix_csc() and rocsparse_zcheck_matrix_csc().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p csc_val, \\p csc_col_ptr, \\p csc_row_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_csc_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const f32,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_csc_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const f64,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_csc_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const rocsparse_float_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_csc_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const rocsparse_double_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_csc checks if the input CSC matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSC matrix.\n  @param[in]\n  n           number of columns of the sparse CSC matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSC matrix.\n  @param[in]\n  csc_val     array of \\p nnz elements of the sparse CSC matrix.\n  @param[in]\n  csc_col_ptr array of \\p m+1 elements that point to the start of every column of the\n              sparse CSC matrix.\n  @param[in]\n  csc_row_ind array of \\p nnz elements containing the row indices of the sparse\n              CSC matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p csc_val, \\p csc_col_ptr, \\p csc_row_ind, \\p temp_buffer or \\p data_status pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const f32,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const f64,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const rocsparse_float_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_val: *const rocsparse_double_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_ell_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_ell\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse ELL matrix.\n  @param[in]\n  n           number of columns of the sparse ELL matrix.\n  @param[in]\n  ell_width   number of non-zero elements per row of the sparse ELL matrix.\n  @param[in]\n  ell_val     array that contains the elements of the sparse ELL matrix. Padded\n              elements should be zero.\n  @param[in]\n  ell_col_ind array that contains the column indices of the sparse ELL matrix.\n              Padded column indices should be -1.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scheck_matrix_ell(), rocsparse_dcheck_matrix_ell(),\n              rocsparse_ccheck_matrix_ell() and rocsparse_zcheck_matrix_ell().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p ell_width is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p ell_val, \\p ell_col_ind or \\p buffer_size pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_ell_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const f32,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_ell_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const f64,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_ell_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_float_complex,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_ell_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_double_complex,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_ell checks if the input ELL matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse ELL matrix.\n  @param[in]\n  n           number of columns of the sparse ELL matrix.\n  @param[in]\n  ell_width   number of non-zero elements per row of the sparse ELL matrix.\n  @param[in]\n  ell_val     array that contains the elements of the sparse ELL matrix. Padded\n              elements should be zero.\n  @param[in]\n  ell_col_ind array that contains the column indices of the sparse ELL matrix.\n              Padded column indices should be -1.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_size \\p m \\p n or \\p ell_width is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p ell_val, \\p ell_col_ind, \\p temp_buffer or \\p data_status pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_scheck_matrix_ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const f32,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcheck_matrix_ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const f64,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccheck_matrix_ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_float_complex,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcheck_matrix_ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_double_complex,
        ell_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_hyb_buffer_size computes the required buffer size needed when\n  calling \\p rocsparse_check_matrix_hyb\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  hyb         matrix in HYB storage format.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_check_matrix_hyb().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p hyb or \\p buffer_size pointer is invalid."]
    pub fn rocsparse_check_matrix_hyb_buffer_size(
        handle: rocsparse_handle,
        hyb: rocsparse_hyb_mat,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup utility_module\n  \\brief Check matrix to see if it is valid.\n\n  \\details\n  \\p rocsparse_check_matrix_hyb checks if the input HYB matrix is valid.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  hyb         matrix in HYB storage format.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  matrix_type \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric,\n              \\ref rocsparse_matrix_type_hermitian or \\ref rocsparse_matrix_type_triangular.\n  @param[in]\n  uplo        \\ref rocsparse_fill_mode_lower or \\ref rocsparse_fill_mode_upper.\n  @param[in]\n  storage     \\ref rocsparse_storage_mode_sorted or \\ref rocsparse_storage_mode_sorted.\n  @param[out]\n  data_status modified to indicate the status of the data\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base or \\p matrix_type or \\p uplo or \\p storage is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p hyb or \\p data_status pointer is invalid."]
    pub fn rocsparse_check_matrix_hyb(
        handle: rocsparse_handle,
        hyb: rocsparse_hyb_mat,
        idx_base: rocsparse_index_base,
        matrix_type: rocsparse_matrix_type,
        uplo: rocsparse_fill_mode,
        storage: rocsparse_storage_mode,
        data_status: *mut rocsparse_data_status,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Scale a sparse vector and add it to a dense vector.\n\n  \\details\n  \\p rocsparse_axpyi multiplies the sparse vector \\f$x\\f$ with scalar \\f$\\alpha\\f$ and\n  adds the result to the dense vector \\f$y\\f$, such that\n\n  \\f[\n      y := y + \\alpha \\cdot x\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          y[x_ind[i]] = y[x_ind[i]] + alpha * x_val[i];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of vector \\f$x\\f$.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  x_val       array of \\p nnz elements containing the values of \\f$x\\f$.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[inout]\n  y           array of values in dense format.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha, \\p x_val, \\p x_ind or \\p y pointer\n          is invalid.\n/\n/**@{"]
    pub fn rocsparse_saxpyi(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        alpha: *const f32,
        x_val: *const f32,
        x_ind: *const rocsparse_int,
        y: *mut f32,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_daxpyi(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        alpha: *const f64,
        x_val: *const f64,
        x_ind: *const rocsparse_int,
        y: *mut f64,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_caxpyi(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        x_val: *const rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        y: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zaxpyi(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        x_val: *const rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        y: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Compute the dot product of a sparse vector with a dense vector.\n\n  \\details\n  \\p rocsparse_doti computes the dot product of the sparse vector \\f$x\\f$ with the\n  dense vector \\f$y\\f$, such that\n  \\f[\n    \\text{result} := y^T x\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          result += x_val[i] * y[x_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of vector \\f$x\\f$.\n  @param[in]\n  x_val       array of \\p nnz values.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[in]\n  y           array of values in dense format.\n  @param[out]\n  result      pointer to the result, can be host or device memory\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p x_val, \\p x_ind, \\p y or \\p result\n          pointer is invalid.\n  \\retval rocsparse_status_memory_error the buffer for the dot product reduction\n          could not be allocated.\n  \\retval rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sdoti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const f32,
        x_ind: *const rocsparse_int,
        y: *const f32,
        result: *mut f32,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ddoti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const f64,
        x_ind: *const rocsparse_int,
        y: *const f64,
        result: *mut f64,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cdoti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        y: *const rocsparse_float_complex,
        result: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zdoti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        y: *const rocsparse_double_complex,
        result: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Compute the dot product of a complex conjugate sparse vector with a dense\n  vector.\n\n  \\details\n  \\p rocsparse_dotci computes the dot product of the complex conjugate sparse vector\n  \\f$x\\f$ with the dense vector \\f$y\\f$, such that\n  \\f[\n    \\text{result} := \\bar{x}^H y\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          result += conj(x_val[i]) * y[x_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of vector \\f$x\\f$.\n  @param[in]\n  x_val       array of \\p nnz values.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[in]\n  y           array of values in dense format.\n  @param[out]\n  result      pointer to the result, can be host or device memory\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p x_val, \\p x_ind, \\p y or \\p result\n          pointer is invalid.\n  \\retval rocsparse_status_memory_error the buffer for the dot product reduction\n          could not be allocated.\n  \\retval rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_cdotci(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        y: *const rocsparse_float_complex,
        result: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zdotci(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        y: *const rocsparse_double_complex,
        result: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Gather elements from a dense vector and store them into a sparse vector.\n\n  \\details\n  \\p rocsparse_gthr gathers the elements that are listed in \\p x_ind from the dense\n  vector \\f$y\\f$ and stores them in the sparse vector \\f$x\\f$.\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          x_val[i] = y[x_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of \\f$x\\f$.\n  @param[in]\n  y           array of values in dense format.\n  @param[out]\n  x_val       array of \\p nnz elements containing the values of \\f$x\\f$.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval     rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p y, \\p x_val or \\p x_ind pointer is\n              invalid.\n/\n/**@{"]
    pub fn rocsparse_sgthr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *const f32,
        x_val: *mut f32,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgthr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *const f64,
        x_val: *mut f64,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgthr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *const rocsparse_float_complex,
        x_val: *mut rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgthr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *const rocsparse_double_complex,
        x_val: *mut rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Gather and zero out elements from a dense vector and store them into a sparse\n  vector.\n\n  \\details\n  \\p rocsparse_gthrz gathers the elements that are listed in \\p x_ind from the dense\n  vector \\f$y\\f$ and stores them in the sparse vector \\f$x\\f$. The gathered elements\n  in \\f$y\\f$ are replaced by zero.\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          x_val[i]    = y[x_ind[i]];\n          y[x_ind[i]] = 0;\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of \\f$x\\f$.\n  @param[inout]\n  y           array of values in dense format.\n  @param[out]\n  x_val       array of \\p nnz elements containing the non-zero values of \\f$x\\f$.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval     rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p y, \\p x_val or \\p x_ind pointer is\n              invalid.\n/\n/**@{"]
    pub fn rocsparse_sgthrz(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *mut f32,
        x_val: *mut f32,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgthrz(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *mut f64,
        x_val: *mut f64,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgthrz(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *mut rocsparse_float_complex,
        x_val: *mut rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgthrz(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        y: *mut rocsparse_double_complex,
        x_val: *mut rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Apply Givens rotation to a dense and a sparse vector.\n\n  \\details\n  \\p rocsparse_roti applies the Givens rotation matrix \\f$G\\f$ to the sparse vector\n  \\f$x\\f$ and the dense vector \\f$y\\f$, where\n  \\f[\n    G = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          x_tmp = x_val[i];\n          y_tmp = y[x_ind[i]];\n\n          x_val[i]    = c * x_tmp + s * y_tmp;\n          y[x_ind[i]] = c * y_tmp - s * x_tmp;\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of \\f$x\\f$.\n  @param[inout]\n  x_val       array of \\p nnz elements containing the non-zero values of \\f$x\\f$.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of \\f$x\\f$.\n  @param[inout]\n  y           array of values in dense format.\n  @param[in]\n  c           pointer to the cosine element of \\f$G\\f$, can be on host or device.\n  @param[in]\n  s           pointer to the sine element of \\f$G\\f$, can be on host or device.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval     rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p c, \\p s, \\p x_val, \\p x_ind or \\p y\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sroti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *mut f32,
        x_ind: *const rocsparse_int,
        y: *mut f32,
        c: *const f32,
        s: *const f32,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_droti(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *mut f64,
        x_ind: *const rocsparse_int,
        y: *mut f64,
        c: *const f64,
        s: *const f64,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level1_module\n  \\brief Scatter elements from a dense vector across a sparse vector.\n\n  \\details\n  \\p rocsparse_sctr scatters the elements that are listed in \\p x_ind from the sparse\n  vector \\f$x\\f$ into the dense vector \\f$y\\f$. Indices of \\f$y\\f$ that are not listed\n  in \\p x_ind remain unchanged.\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          y[x_ind[i]] = x_val[i];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  nnz         number of non-zero entries of \\f$x\\f$.\n  @param[in]\n  x_val       array of \\p nnz elements containing the non-zero values of \\f$x\\f$.\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the non-zero\n              values of x.\n  @param[inout]\n  y           array of values in dense format.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_value \\p idx_base is invalid.\n  \\retval     rocsparse_status_invalid_size \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p x_val, \\p x_ind or \\p y pointer is\n              invalid.\n/\n/**@{"]
    pub fn rocsparse_ssctr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const f32,
        x_ind: *const rocsparse_int,
        y: *mut f32,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dsctr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const f64,
        x_ind: *const rocsparse_int,
        y: *mut f64,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_csctr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        y: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zsctr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        y: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_isctr(
        handle: rocsparse_handle,
        nnz: rocsparse_int,
        x_val: *const rocsparse_int,
        x_ind: *const rocsparse_int,
        y: *mut rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrmv_ex_analysis performs the analysis step for rocsparse_sbsrmv(),\n  rocsparse_dbsrmv(), rocsparse_cbsrmv() and rocsparse_zbsrmv(). It is expected that\n  this function will be executed only once for a given matrix and particular operation\n  type. The gathered analysis meta data can be cleared by rocsparse_bsrmv_ex_clear().\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nb          number of block columns of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb or \\p nnzb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind or \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer for the gathered information\n              could not be allocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrmv_ex_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrmv_ex_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrmv_ex_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrmv_ex_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrmv_ex multiplies the scalar \\f$\\alpha\\f$ with a sparse\n  \\f$(mb \\cdot \\text{block_dim}) \\times (nb \\cdot \\text{block_dim})\\f$\n  matrix, defined in BSR storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nb          number of block columns of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[in]\n  x           array of \\p nb*block_dim elements (\\f$op(A) = A\\f$) or \\p mb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p mb*block_dim elements (\\f$op(A) = A\\f$) or \\p nb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb, \\p nnzb or \\p block_dim is\n              invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ind, \\p bsr_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrmv_ex(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrmv_ex(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrmv_ex(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrmv_ex(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrmv multiplies the scalar \\f$\\alpha\\f$ with a sparse\n  \\f$(mb \\cdot \\text{block_dim}) \\times (nb \\cdot \\text{block_dim})\\f$\n  matrix, defined in BSR storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nb          number of block columns of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[in]\n  x           array of \\p nb*block_dim elements (\\f$op(A) = A\\f$) or \\p mb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p mb*block_dim elements (\\f$op(A) = A\\f$) or \\p nb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb, \\p nnzb or \\p block_dim is\n              invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ind, \\p bsr_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication with mask operation using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrxmv multiplies the scalar \\f$\\alpha\\f$ with a sparse\n  \\f$(mb \\cdot \\text{block_dim}) \\times (nb \\cdot \\text{block_dim})\\f$\n  modified matrix, defined in BSR storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\left( \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y \\right)\\left( \\text{mask} \\right),\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  The \\f$\\text{mask}\\f$ is defined as an array of block row indices.\n  The input sparse matrix is defined with a modified BSR storage format where the beginning and the end of each row\n  is defined with two arrays, \\p bsr_row_ptr and \\p bsr_end_ptr (both of size \\p mb), rather the usual \\p bsr_row_ptr of size \\p mb+1.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none is supported.\n  Currently, \\p block_dim==1 is not supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  size_of_mask number of updated block rows of the array \\p y.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nb          number of block columns of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n\n  @param[in]\n  bsr_mask_ptr array of \\p size_of_mask elements that give the indices of the updated block rows.\n\n  @param[in]\n  bsr_row_ptr array of \\p mb elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_end_ptr array of \\p mb elements that point to the end of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[in]\n  x           array of \\p nb*block_dim elements (\\f$op(A) = A\\f$) or \\p mb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p mb*block_dim elements (\\f$op(A) = A\\f$) or \\p nb*block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb, \\p nnzb, \\p block_dim or \\p size_of_mask is\n              invalid.\n  \\retval     rocsparse_status_invalid_value \\p size_of_mask is greater than \\p mb.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ind, \\p bsr_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p block_dim==1, \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrxmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        size_of_mask: rocsparse_int,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_mask_ptr: *const rocsparse_int,
        bsr_row_ptr: *const rocsparse_int,
        bsr_end_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrxmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        size_of_mask: rocsparse_int,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_mask_ptr: *const rocsparse_int,
        bsr_row_ptr: *const rocsparse_int,
        bsr_end_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrxmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        size_of_mask: rocsparse_int,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_mask_ptr: *const rocsparse_int,
        bsr_row_ptr: *const rocsparse_int,
        bsr_end_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrxmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        size_of_mask: rocsparse_int,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_mask_ptr: *const rocsparse_int,
        bsr_row_ptr: *const rocsparse_int,
        bsr_end_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsv_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_sbsrsv_solve(),\n  rocsparse_dbsrsv_solve(), rocsparse_cbsrsv_solve() or rocsparse_zbsrsv_solve()\n  computation. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position,\n  using same index base as the BSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_bsrsv_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_bsrsv_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsv_buffer_size returns the size of the temporary storage buffer that\n  is required by rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(),\n  rocsparse_cbsrsv_analysis(), rocsparse_zbsrsv_analysis(), rocsparse_sbsrsv_solve(),\n  rocsparse_dbsrsv_solve(), rocsparse_cbsrsv_solve() and rocsparse_zbsrsv_solve(). The\n  temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnz containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(),\n              rocsparse_cbsrsv_analysis(), rocsparse_zbsrsv_analysis(),\n              rocsparse_sbsrsv_solve(), rocsparse_dbsrsv_solve(),\n              rocsparse_cbsrsv_solve() and rocsparse_zbsrsv_solve().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrsv_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsv_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsv_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsv_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsv_analysis performs the analysis step for rocsparse_sbsrsv_solve(),\n  rocsparse_dbsrsv_solve(), rocsparse_cbsrsv_solve() and rocsparse_zbsrsv_solve(). It\n  is expected that this function will be executed only once for a given matrix and\n  particular operation type. The analysis meta data can be cleared by\n  rocsparse_bsrsv_clear().\n\n  \\p rocsparse_bsrsv_analysis can share its meta data with\n  rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(),\n  rocsparse_cbsrsm_analysis(), rocsparse_zbsrsm_analysis(),\n  rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(),\n  rocsparse_cbsrilu0_analysis(), rocsparse_zbsrilu0_analysis(),\n  rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(),\n  rocsparse_cbsric0_analysis() and rocsparse_zbsric0_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnz containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrsv_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsv_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsv_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsv_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrmv_ex_clear deallocates all memory that was allocated by\n  rocsparse_sbsrmv_ex_analysis(), rocsparse_dbsrmv_ex_analysis(), rocsparse_cbsrmv_ex_analysis()\n  or rocsparse_zbsrmv_ex_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required anymore for further computation, e.g. when\n  switching to another sparse matrix format.\n\n  \\note\n  Calling \\p rocsparse_bsrmv_ex_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer for the gathered information\n              could not be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_bsrmv_ex_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsv_clear deallocates all memory that was allocated by\n  rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(), rocsparse_cbsrsv_analysis()\n  or rocsparse_zbsrsv_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation, e.g. when switching to\n  another sparse matrix format. Calling \\p rocsparse_bsrsv_clear is optional. All\n  allocated resources will be cleared, when the opaque \\ref rocsparse_mat_info struct\n  is destroyed using rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_bsrsv_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsv_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in BSR storage format, a dense solution vector\n  \\f$y\\f$ and the right-hand side \\f$x\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot y = \\alpha \\cdot x,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_bsrsv_solve requires a user allocated temporary buffer. Its size is\n  returned by rocsparse_sbsrsv_buffer_size(), rocsparse_dbsrsv_buffer_size(),\n  rocsparse_cbsrsv_buffer_size() or rocsparse_zbsrsv_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_sbsrsv_analysis(),\n  rocsparse_dbsrsv_analysis(), rocsparse_cbsrsv_analysis() or\n  rocsparse_zbsrsv_analysis(). \\p rocsparse_bsrsv_solve reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be checked calling\n  rocsparse_bsrsv_zero_pivot(). If\n  \\ref rocsparse_diag_type == \\ref rocsparse_diag_type_unit, no zero pivot will be\n  reported, even if \\f$A_{j,j} = 0\\f$ for some \\f$j\\f$.\n\n  \\note\n  The sparse BSR matrix has to be sorted.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none and\n  \\p trans == \\ref rocsparse_operation_transpose is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnz containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim     block dimension of the sparse BSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  x           array of \\p m elements, holding the right-hand side.\n  @param[out]\n  y           array of \\p m elements, holding the solution.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p x or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the lower triangular \\f$m \\times m\\f$ matrix \\f$L\\f$, stored in BSR\n  storage format with unit diagonal. The following example solves \\f$L \\cdot y = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor\n      rocsparse_mat_descr descr;\n      rocsparse_create_mat_descr(&descr);\n      rocsparse_set_mat_fill_mode(descr, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr, rocsparse_diag_type_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size;\n      rocsparse_dbsrsv_buffer_size(handle,\n                                   rocsparse_direction_column,\n                                   rocsparse_operation_none,\n                                   mb,\n                                   nnzb,\n                                   descr,\n                                   bsr_val,\n                                   bsr_row_ptr,\n                                   bsr_col_ind,\n                                   block_dim,\n                                   info,\n                                   &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis step\n      rocsparse_dbsrsv_analysis(handle,\n                                rocsparse_direction_column,\n                                rocsparse_operation_none,\n                                mb,\n                                nnzb,\n                                descr,\n                                bsr_val,\n                                bsr_row_ptr,\n                                bsr_col_ind,\n                                block_dim,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Solve Ly = x\n      rocsparse_dbsrsv_solve(handle,\n                             rocsparse_direction_column,\n                             rocsparse_operation_none,\n                             mb,\n                             nnzb,\n                             &alpha,\n                             descr,\n                             bsr_val,\n                             bsr_row_ptr,\n                             bsr_col_ind,\n                             block_dim,\n                             info,\n                             x,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // No zero pivot should be found, with L having unit diagonal\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsrsv_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f32,
        y: *mut f32,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsv_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f64,
        y: *mut f64,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsv_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsv_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using COO storage format\n\n  \\details\n  \\p rocsparse_coomv multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix, defined in COO storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  The COO matrix has to be sorted by row indices. This can be achieved by using\n  rocsparse_coosort_by_row().\n\n  \\code{.c}\n      for(i = 0; i < m; ++i)\n      {\n          y[i] = beta * y[i];\n      }\n\n      for(i = 0; i < nnz; ++i)\n      {\n          y[coo_row_ind[i]] += alpha * coo_val[i] * x[coo_col_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse COO matrix.\n  @param[in]\n  n           number of columns of the sparse COO matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse COO matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse COO matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  coo_val     array of \\p nnz elements of the sparse COO matrix.\n  @param[in]\n  coo_row_ind array of \\p nnz elements containing the row indices of the sparse COO\n              matrix.\n  @param[in]\n  coo_col_ind array of \\p nnz elements containing the column indices of the sparse\n              COO matrix.\n  @param[in]\n  x           array of \\p n elements (\\f$op(A) = A\\f$) or \\p m elements\n              (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p m elements (\\f$op(A) = A\\f$) or \\p n elements\n              (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p coo_val,\n              \\p coo_row_ind, \\p coo_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scoomv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        coo_val: *const f32,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcoomv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        coo_val: *const f64,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccoomv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        coo_val: *const rocsparse_float_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcoomv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        coo_val: *const rocsparse_double_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrmv_analysis performs the analysis step for rocsparse_scsrmv(),\n  rocsparse_dcsrmv(), rocsparse_ccsrmv() and rocsparse_zcsrmv(). It is expected that\n  this function will be executed only once for a given matrix and particular operation\n  type. The gathered analysis meta data can be cleared by rocsparse_csrmv_clear().\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind or \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer for the gathered information\n              could not be allocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented if \\ref rocsparse_matrix_type is not one of\n              \\ref rocsparse_matrix_type_general, \\ref rocsparse_matrix_type_symmetric, or\n              \\ref rocsparse_matrix_type_triangular.\n/\n/**@{"]
    pub fn rocsparse_scsrmv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrmv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrmv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrmv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrmv_clear deallocates all memory that was allocated by\n  rocsparse_scsrmv_analysis(), rocsparse_dcsrmv_analysis(), rocsparse_ccsrmv_analysis()\n  or rocsparse_zcsrmv_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required anymore for further computation, e.g. when\n  switching to another sparse matrix format.\n\n  \\note\n  Calling \\p rocsparse_csrmv_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer for the gathered information\n              could not be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csrmv_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrmv multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix, defined in CSR storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  The \\p info parameter is optional and contains information collected by\n  rocsparse_scsrmv_analysis(), rocsparse_dcsrmv_analysis(), rocsparse_ccsrmv_analysis()\n  or rocsparse_zcsrmv_analysis(). If present, the information will be used to speed up\n  the \\p csrmv computation. If \\p info == \\p NULL, general \\p csrmv routine will be\n  used instead.\n\n  \\code{.c}\n      for(i = 0; i < m; ++i)\n      {\n          y[i] = beta * y[i];\n\n          for(j = csr_row_ptr[i]; j < csr_row_ptr[i + 1]; ++j)\n          {\n              y[i] = y[i] + alpha * csr_val[j] * x[csr_col_ind[j]];\n          }\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  info        information collected by rocsparse_scsrmv_analysis(),\n              rocsparse_dcsrmv_analysis(), rocsparse_ccsrmv_analysis() or\n              rocsparse_dcsrmv_analysis(), can be \\p NULL if no information is\n              available.\n  @param[in]\n  x           array of \\p n elements (\\f$op(A) == A\\f$) or \\p m elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p m elements (\\f$op(A) == A\\f$) or \\p n elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p x, \\p beta or \\p y pointer is\n              invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example performs a sparse matrix vector multiplication in CSR format\n  using additional meta data to improve performance.\n  \\code{.c}\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Perform analysis step to obtain meta data\n      rocsparse_scsrmv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                n,\n                                nnz,\n                                descr,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info);\n\n      // Compute y = Ax\n      rocsparse_scsrmv(handle,\n                       rocsparse_operation_none,\n                       m,\n                       n,\n                       nnz,\n                       &alpha,\n                       descr,\n                       csr_val,\n                       csr_row_ptr,\n                       csr_col_ind,\n                       info,\n                       x,\n                       &beta,\n                       y);\n\n      // Do more work\n      // ...\n\n      // Clean up\n      rocsparse_destroy_mat_info(info);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsv_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_scsrsv_solve(),\n  rocsparse_dcsrsv_solve(), rocsparse_ccsrsv_solve() or rocsparse_zcsrsv_solve()\n  computation. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position,\n  using same index base as the CSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_csrsv_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_csrsv_zero_pivot(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse iterative triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csritsv_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_csritsv_solve() and or rocsparse_csritsv_analysis(),\n  execution. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position,\n  using same index base as the CSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_csritsv_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_csritsv_zero_pivot(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsv_buffer_size returns the size of the temporary storage buffer that\n  is required by rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(),\n  rocsparse_ccsrsv_analysis(), rocsparse_zcsrsv_analysis(), rocsparse_scsrsv_solve(),\n  rocsparse_dcsrsv_solve(), rocsparse_ccsrsv_solve() and rocsparse_zcsrsv_solve(). The\n  temporary storage buffer must be allocated by the user. The size of the temporary\n  storage buffer is identical to the size returned by rocsparse_scsrilu0_buffer_size(),\n  rocsparse_dcsrilu0_buffer_size(), rocsparse_ccsrilu0_buffer_size() and\n  rocsparse_zcsrilu0_buffer_size() if the matrix sparsity pattern is identical. The\n  user allocated buffer can thus be shared between subsequent calls to those functions.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(),\n              rocsparse_ccsrsv_analysis(), rocsparse_zcsrsv_analysis(),\n              rocsparse_scsrsv_solve(), rocsparse_dcsrsv_solve(),\n              rocsparse_ccsrsv_solve() and rocsparse_zcsrsv_solve().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse iterative triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csritsv_buffer_size returns the size of the temporary storage buffer that\n  is required by rocsparse_scsritsv_analysis(), rocsparse_dcsritsv_analysis(),\n  rocsparse_ccsritsv_analysis(), rocsparse_zcsritsv_analysis(), rocsparse_scsritsv_solve(),\n  rocsparse_dcsritsv_solve(), rocsparse_ccsritsv_solve() and rocsparse_zcsritsv_solve(). The\n  temporary storage buffer must be allocated by the user.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsritsv_analysis(), rocsparse_dcsritsv_analysis(),\n              rocsparse_ccsritsv_analysis(), rocsparse_zcsritsv_analysis(),\n              rocsparse_scsritsv_solve(), rocsparse_dcsritsv_solve(),\n              rocsparse_ccsritsv_solve() and rocsparse_zcsritsv_solve().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general and \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_triangular.\n/\n/**@{"]
    pub fn rocsparse_scsritsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsritsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsritsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsritsv_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsv_analysis performs the analysis step for rocsparse_scsrsv_solve(),\n  rocsparse_dcsrsv_solve(), rocsparse_ccsrsv_solve() and rocsparse_zcsrsv_solve(). It\n  is expected that this function will be executed only once for a given matrix and\n  particular operation type. The analysis meta data can be cleared by\n  rocsparse_csrsv_clear().\n\n  \\p rocsparse_csrsv_analysis can share its meta data with\n  rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(),\n  rocsparse_ccsrsm_analysis(), rocsparse_zcsrsm_analysis(),\n  rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n  rocsparse_ccsrilu0_analysis(), rocsparse_zcsrilu0_analysis(),\n  rocsparse_scsric0_analysis(), rocsparse_dcsric0_analysis(),\n  rocsparse_ccsric0_analysis() and rocsparse_zcsric0_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse iterative triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csritsv_analysis performs the analysis step for rocsparse_scsritsv_solve(),\n  rocsparse_dcsritsv_solve(), rocsparse_ccsritsv_solve() and rocsparse_zcsritsv_solve(). It\n  is expected that this function will be executed only once for a given matrix and\n  particular operation type. The analysis meta data can be cleared by\n  rocsparse_csritsv_clear().\n\n   Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general and \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_triangular.\n/\n/**@{"]
    pub fn rocsparse_scsritsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsritsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsritsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsritsv_analysis(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsv_clear deallocates all memory that was allocated by\n  rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(), rocsparse_ccsrsv_analysis()\n  or rocsparse_zcsrsv_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation, e.g. when switching to\n  another sparse matrix format. Calling \\p rocsparse_csrsv_clear is optional. All\n  allocated resources will be cleared, when the opaque \\ref rocsparse_mat_info struct\n  is destroyed using rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csrsv_clear(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csritsv_clear deallocates all memory that was allocated by\n  rocsparse_scsritsv_analysis(), rocsparse_dcsritsv_analysis(), rocsparse_ccsritsv_analysis()\n  or rocsparse_zcsritsv_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation, e.g. when switching to\n  another sparse matrix format. Calling \\p rocsparse_csritsv_clear is optional. All\n  allocated resources will be cleared, when the opaque \\ref rocsparse_mat_info struct\n  is destroyed using rocsparse_destroy_mat_info().\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csritsv_clear(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsv_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR storage format, a dense solution vector\n  \\f$y\\f$ and the right-hand side \\f$x\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot y = \\alpha \\cdot x,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_csrsv_solve requires a user allocated temporary buffer. Its size is\n  returned by rocsparse_scsrsv_buffer_size(), rocsparse_dcsrsv_buffer_size(),\n  rocsparse_ccsrsv_buffer_size() or rocsparse_zcsrsv_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_scsrsv_analysis(),\n  rocsparse_dcsrsv_analysis(), rocsparse_ccsrsv_analysis() or\n  rocsparse_zcsrsv_analysis(). \\p rocsparse_csrsv_solve reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be checked calling\n  rocsparse_csrsv_zero_pivot(). If\n  \\ref rocsparse_diag_type == \\ref rocsparse_diag_type_unit, no zero pivot will be\n  reported, even if \\f$A_{j,j} = 0\\f$ for some \\f$j\\f$.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none and\n  \\p trans == \\ref rocsparse_operation_transpose is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  x           array of \\p m elements, holding the right-hand side.\n  @param[out]\n  y           array of \\p m elements, holding the solution.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p x or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the lower triangular \\f$m \\times m\\f$ matrix \\f$L\\f$, stored in CSR\n  storage format with unit diagonal. The following example solves \\f$L \\cdot y = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor\n      rocsparse_mat_descr descr;\n      rocsparse_create_mat_descr(&descr);\n      rocsparse_set_mat_fill_mode(descr, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr, rocsparse_diag_type_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size;\n      rocsparse_dcsrsv_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nnz,\n                                   descr,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis step\n      rocsparse_dcsrsv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                nnz,\n                                descr,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Solve Ly = x\n      rocsparse_dcsrsv_solve(handle,\n                             rocsparse_operation_none,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             x,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // No zero pivot should be found, with L having unit diagonal\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrsv_solve(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f32,
        y: *mut f32,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsv_solve(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f64,
        y: *mut f64,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsv_solve(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsv_solve(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse iterative triangular solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csritsv_solve solves iteratively with the use of the Jacobi method a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR storage format, a dense solution vector\n  \\f$y\\f$ and the right-hand side \\f$x\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot y = \\alpha \\cdot x,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_csritsv_solve requires a user allocated temporary buffer. Its size is\n  returned by rocsparse_scsritsv_buffer_size(), rocsparse_dcsritsv_buffer_size(),\n  rocsparse_ccsritsv_buffer_size() or rocsparse_zcsritsv_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_scsritsv_analysis(),\n  rocsparse_dcsritsv_analysis(), rocsparse_ccsritsv_analysis() or\n  rocsparse_zcsritsv_analysis(). \\p rocsparse_csritsv_solve reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be checked calling\n  rocsparse_csritsv_zero_pivot(). If\n  \\ref rocsparse_diag_type == \\ref rocsparse_diag_type_unit, no zero pivot will be\n  reported, even if \\f$A_{j,j} = 0\\f$ for some \\f$j\\f$.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  host_nmaxiter     maximum number of iteration on input and maximum number of iteration on output.\n  @param[in]\n  host_tol          if the pointer is null then loop will execute \\p nmaxiter[0] iterations.\n  @param[out]\n  host_history      (optional, record history)\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  x           array of \\p m elements, holding the right-hand side.\n  @param[out]\n  y           array of \\p m elements, holding the solution.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p x or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general and \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_triangular.\n\n  \\par Example\n  Consider the lower triangular \\f$m \\times m\\f$ matrix \\f$L\\f$, stored in CSR\n  storage format with unit diagonal. The following example solves \\f$L \\cdot y = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor\n      rocsparse_mat_descr descr;\n      rocsparse_create_mat_descr(&descr);\n      rocsparse_set_mat_fill_mode(descr, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr, rocsparse_diag_type_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size;\n      rocsparse_dcsritsv_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nnz,\n                                   descr,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis step\n      rocsparse_dcsritsv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                nnz,\n                                descr,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Solve Ly = x\n      rocsparse_int nmaxiter = 200;\n      rocsparse_int maxiter = nmaxiter;\n      tol = 1.0e-4;\n      history[200];\n      rocsparse_dcsritsv_solve(handle,\n                             &maxiter,\n                             &tol,\n                             history,\n                             rocsparse_operation_none,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             x,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      if (maxiter < nmaxiter) {} // convergence\n      else {} // non converged\n      for (int i=0;i<maxiter;++i) printf(\"iter = %d, max residual=%e\\n\", iter, history[i]);\n      // No zero pivot should be found, with L having unit diagonal\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsritsv_solve(
        handle: rocsparse_handle,
        host_nmaxiter: *mut rocsparse_int,
        host_tol: *const f32,
        host_history: *mut f32,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f32,
        y: *mut f32,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsritsv_solve(
        handle: rocsparse_handle,
        host_nmaxiter: *mut rocsparse_int,
        host_tol: *const f64,
        host_history: *mut f64,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const f64,
        y: *mut f64,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsritsv_solve(
        handle: rocsparse_handle,
        host_nmaxiter: *mut rocsparse_int,
        host_tol: *const f32,
        host_history: *mut f32,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsritsv_solve(
        handle: rocsparse_handle,
        host_nmaxiter: *mut rocsparse_int,
        host_tol: *const f64,
        host_history: *mut f64,
        trans: rocsparse_operation,
        m: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        x: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using ELL storage format\n\n  \\details\n  \\p rocsparse_ellmv multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix, defined in ELL storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < m; ++i)\n      {\n          y[i] = beta * y[i];\n\n          for(p = 0; p < ell_width; ++p)\n          {\n              idx = p * m + i;\n\n              if((ell_col_ind[idx] >= 0) && (ell_col_ind[idx] < n))\n              {\n                  y[i] = y[i] + alpha * ell_val[idx] * x[ell_col_ind[idx]];\n              }\n          }\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the sparse ELL matrix.\n  @param[in]\n  n           number of columns of the sparse ELL matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse ELL matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  ell_val     array that contains the elements of the sparse ELL matrix. Padded\n              elements should be zero.\n  @param[in]\n  ell_col_ind array that contains the column indices of the sparse ELL matrix.\n              Padded column indices should be -1.\n  @param[in]\n  ell_width   number of non-zero elements per row of the sparse ELL matrix.\n  @param[in]\n  x           array of \\p n elements (\\f$op(A) == A\\f$) or \\p m elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p m elements (\\f$op(A) == A\\f$) or \\p n elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ell_width is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p ell_val,\n              \\p ell_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sellmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        ell_val: *const f32,
        ell_col_ind: *const rocsparse_int,
        ell_width: rocsparse_int,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dellmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        ell_val: *const f64,
        ell_col_ind: *const rocsparse_int,
        ell_width: rocsparse_int,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cellmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        ell_val: *const rocsparse_float_complex,
        ell_col_ind: *const rocsparse_int,
        ell_width: rocsparse_int,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zellmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        ell_val: *const rocsparse_double_complex,
        ell_col_ind: *const rocsparse_int,
        ell_width: rocsparse_int,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using HYB storage format\n\n  \\details\n  \\p rocsparse_hybmv multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix, defined in HYB storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse HYB matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  hyb         matrix in HYB storage format.\n  @param[in]\n  x           array of \\p n elements (\\f$op(A) == A\\f$) or \\p m elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p m elements (\\f$op(A) == A\\f$) or \\p n elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p hyb structure was not initialized with\n              valid matrix sizes.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p hyb, \\p x,\n              \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_invalid_value \\p hyb structure was not initialized\n              with a valid partitioning type.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_memory_error the buffer could not be allocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_shybmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dhybmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_chybmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zhybmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Sparse matrix vector multiplication using GEBSR storage format\n\n  \\details\n  \\p rocsparse_gebsrmv multiplies the scalar \\f$\\alpha\\f$ with a sparse\n  \\f$(mb \\cdot \\text{row_block_dim}) \\times (nb \\cdot \\text{col_block_dim})\\f$\n  matrix, defined in GEBSR storage format, and the dense vector \\f$x\\f$ and adds the\n  result to the dense vector \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$,\n  such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of GEBSR blocks.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  mb          number of block rows of the sparse GEBSR matrix.\n  @param[in]\n  nb          number of block columns of the sparse GEBSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse GEBSR matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse GEBSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse GEBSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse GEBSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnz containing the block column indices of the sparse\n              GEBSR matrix.\n  @param[in]\n  row_block_dim row block dimension of the sparse GEBSR matrix.\n  @param[in]\n  col_block_dim column block dimension of the sparse GEBSR matrix.\n  @param[in]\n  x           array of \\p nb*col_block_dim elements (\\f$op(A) = A\\f$) or \\p mb*row_block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p mb*row_block_dim elements (\\f$op(A) = A\\f$) or \\p nb*col_block_dim\n              elements (\\f$op(A) = A^T\\f$ or \\f$op(A) = A^H\\f$).\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb, \\p nnzb, \\p row_block_dim\n              or \\p col_block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ind, \\p bsr_col_ind, \\p x, \\p beta or \\p y pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sgebsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        x: *const f32,
        beta: *const f32,
        y: *mut f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        x: *const f64,
        beta: *const f64,
        y: *mut f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        x: *const rocsparse_float_complex,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsrmv(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        x: *const rocsparse_double_complex,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Dense matrix sparse vector multiplication\n\n  \\details\n  \\p rocsparse_gemvi_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_sgemvi(), rocsparse_dgemvi(), rocsparse_cgemvi() or\n  rocsparse_zgemvi(). The temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the dense matrix.\n  @param[in]\n  n           number of columns of the dense matrix.\n  @param[in]\n  nnz         number of non-zero entries in the sparse vector.\n  @param[out]\n  buffer_size temporary storage buffer size.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n, or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sgemvi_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgemvi_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgemvi_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgemvi_buffer_size(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level2_module\n  \\brief Dense matrix sparse vector multiplication\n\n  \\details\n  \\p rocsparse_gemvi multiplies the scalar \\f$\\alpha\\f$ with a dense \\f$m \\times n\\f$\n  matrix \\f$A\\f$ and the sparse vector \\f$x\\f$ and adds the result to the dense vector\n  \\f$y\\f$ that is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_gemvi requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_sgemvi_buffer_size(), rocsparse_dgemvi_buffer_size(),\n  rocsparse_cgemvi_buffer_size() or rocsparse_zgemvi_buffer_size().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans       matrix operation type.\n  @param[in]\n  m           number of rows of the dense matrix.\n  @param[in]\n  n           number of columns of the dense matrix.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  A           pointer to the dense matrix.\n  @param[in]\n  lda         leading dimension of the dense matrix\n  @param[in]\n  nnz         number of non-zero entries in the sparse vector\n  @param[in]\n  x_val       array of \\p nnz elements containing the values of the sparse vector\n  @param[in]\n  x_ind       array of \\p nnz elements containing the indices of the sparse vector\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           array of \\p m elements (\\f$op(A) == A\\f$) or \\p n elements\n              (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n  @param[in]\n  idx_base    rocsparse_index_base_zero or rocsparse_index_base_one.\n  @param[in]\n  temp_buffer temporary storage buffer\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n, \\p lda or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p A, \\p x_val, \\p x_ind,\n              \\p beta, \\p y or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sgemvi(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocsparse_int,
        nnz: rocsparse_int,
        x_val: *const f32,
        x_ind: *const rocsparse_int,
        beta: *const f32,
        y: *mut f32,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgemvi(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocsparse_int,
        nnz: rocsparse_int,
        x_val: *const f64,
        x_ind: *const rocsparse_int,
        beta: *const f64,
        y: *mut f64,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgemvi(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        A: *const rocsparse_float_complex,
        lda: rocsparse_int,
        nnz: rocsparse_int,
        x_val: *const rocsparse_float_complex,
        x_ind: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        y: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgemvi(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        A: *const rocsparse_double_complex,
        lda: rocsparse_int,
        nnz: rocsparse_int,
        x_val: *const rocsparse_double_complex,
        x_ind: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        y: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse matrix dense matrix multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrmm multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$mb \\times kb\\f$\n  matrix \\f$A\\f$, defined in BSR storage format, and the dense \\f$k \\times n\\f$\n  matrix \\f$B\\f$ (where \\f$k = block\\_dim \\times kb\\f$) and adds the result to the dense\n  \\f$m \\times n\\f$ matrix \\f$C\\f$ (where \\f$m = block\\_dim \\times mb\\f$) that\n  is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot C,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         the storage format of the blocks. Can be \\ref rocsparse_direction_row or \\ref rocsparse_direction_column.\n  @param[in]\n  trans_A     matrix \\f$A\\f$ operation type. Currently, only \\ref rocsparse_operation_none is supported.\n  @param[in]\n  trans_B     matrix \\f$B\\f$ operation type. Currently, only \\ref rocsparse_operation_none and rocsparse_operation_transpose\n              are supported.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  n           number of columns of the dense matrix \\f$op(B)\\f$ and \\f$C\\f$.\n  @param[in]\n  kb          number of block columns of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix \\f$A\\f$. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb*block_dim*block_dim elements of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix \\f$A\\f$.\n  @param[in]\n  block_dim   size of the blocks in the sparse BSR matrix.\n  @param[in]\n  B           array of dimension \\f$ldb \\times n\\f$ (\\f$op(B) == B\\f$),\n              \\f$ldb \\times k\\f$ otherwise.\n  @param[in]\n  ldb         leading dimension of \\f$B\\f$, must be at least \\f$\\max{(1, k)}\\f$ (\\f$ op(B) == B\\f$) where \\f$k = block\\_dim \\times kb\\f$,\n  \\f$\\max{(1, n)}\\f$ otherwise.\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  C           array of dimension \\f$ldc \\times n\\f$.\n  @param[in]\n  ldc         leading dimension of \\f$C\\f$, must be at least \\f$\\max{(1, m)}\\f$ (\\f$ op(A) == A\\f$) where \\f$m = block\\_dim \\times mb\\f$,\n  \\f$\\max{(1, k)}\\f$ where \\f$k = block\\_dim \\times kb\\f$ otherwise.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p n, \\p kb, \\p nnzb, \\p ldb or \\p ldc\n              is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p B, \\p beta or \\p C pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A != \\ref rocsparse_operation_none or\n              \\p trans_B == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies a BSR matrix with a dense matrix.\n  \\code{.c}\n      //     1 2 0 3 0 0\n      // A = 0 4 5 0 0 0\n      //     0 0 0 7 8 0\n      //     0 0 1 2 4 1\n\n      rocsparse_int block_dim = 2;\n      rocsparse_int mb   = 2;\n      rocsparse_int kb   = 3;\n      rocsparse_int nnzb = 4;\n      rocsparse_direction dir = rocsparse_direction_row;\n\n      bsr_row_ptr[mb+1]                 = {0, 2, 4};                                        // device memory\n      bsr_col_ind[nnzb]                 = {0, 1, 1, 2};                                     // device memory\n      bsr_val[nnzb*block_dim*block_dim] = {1, 2, 0, 4, 0, 3, 5, 0, 0, 7, 1, 2, 8, 0, 4, 1}; // device memory\n\n      // Set dimension n of B\n      rocsparse_int n = 64;\n      rocsparse_int m = mb * block_dim;\n      rocsparse_int k = kb * block_dim;\n\n      // Allocate and generate dense matrix B\n      std::vector<float> hB(k * n);\n      for(rocsparse_int i = 0; i < k * n; ++i)\n      {\n          hB[i] = static_cast<float>(rand()) / RAND_MAX;\n      }\n\n      // Copy B to the device\n      float* B;\n      hipMalloc((void**)&B, sizeof(float) * k * n);\n      hipMemcpy(B, hB.data(), sizeof(float) * k * n, hipMemcpyHostToDevice);\n\n      // alpha and beta\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Allocate memory for the resulting matrix C\n      float* C;\n      hipMalloc((void**)&C, sizeof(float) * m * n);\n\n      // Perform the matrix multiplication\n      rocsparse_sbsrmm(handle,\n                       dir,\n                       rocsparse_operation_none,\n                       rocsparse_operation_none,\n                       mb,\n                       n,\n                       kb,\n                       nnzb,\n                       &alpha,\n                       descr,\n                       bsr_val,\n                       bsr_row_ptr,\n                       bsr_col_ind,\n                       block_dim,\n                       B,\n                       k,\n                       &beta,\n                       C,\n                       m);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        B: *const f32,
        ldb: rocsparse_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        B: *const f64,
        ldb: rocsparse_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_float_complex,
        C: *mut rocsparse_float_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_double_complex,
        C: *mut rocsparse_double_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse matrix dense matrix multiplication using GEneral BSR storage format\n\n  \\details\n  \\p rocsparse_gebsrmm multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$mb \\times kb\\f$\n  matrix \\f$A\\f$, defined in GEneral BSR storage format, and the dense \\f$k \\times n\\f$\n  matrix \\f$B\\f$ (where \\f$k = col_block\\_dim \\times kb\\f$) and adds the result to the dense\n  \\f$m \\times n\\f$ matrix \\f$C\\f$ (where \\f$m = row_block\\_dim \\times mb\\f$) that\n  is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot C,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         the storage format of the blocks. Can be \\ref rocsparse_direction_row or \\ref rocsparse_direction_column.\n  @param[in]\n  trans_A     matrix \\f$A\\f$ operation type. Currently, only \\ref rocsparse_operation_none is supported.\n  @param[in]\n  trans_B     matrix \\f$B\\f$ operation type. Currently, only \\ref rocsparse_operation_none and rocsparse_operation_transpose\n              are supported.\n  @param[in]\n  mb          number of block rows of the sparse GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  n           number of columns of the dense matrix \\f$op(B)\\f$ and \\f$C\\f$.\n  @param[in]\n  kb          number of block columns of the sparse GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse GEneral BSR matrix \\f$A\\f$. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb*row_block_dim*col_block_dim elements of the sparse GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              GEneral BSR matrix \\f$A\\f$.\n  @param[in]\n  row_block_dim   row size of the blocks in the sparse GEneral BSR matrix.\n  @param[in]\n  col_block_dim   column size of the blocks in the sparse GEneral BSR matrix.\n  @param[in]\n  B           array of dimension \\f$ldb \\times n\\f$ (\\f$op(B) == B\\f$),\n              \\f$ldb \\times k\\f$ otherwise.\n  @param[in]\n  ldb         leading dimension of \\f$B\\f$, must be at least \\f$\\max{(1, k)}\\f$ (\\f$ op(B) == B\\f$) where \\f$k = col\\_block\\_dim \\times kb\\f$,\n  \\f$\\max{(1, n)}\\f$ otherwise.\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  C           array of dimension \\f$ldc \\times n\\f$.\n  @param[in]\n  ldc         leading dimension of \\f$C\\f$, must be at least \\f$\\max{(1, m)}\\f$ (\\f$ op(A) == A\\f$) where \\f$m = row\\_block\\_dim \\times mb\\f$,\n  \\f$\\max{(1, k)}\\f$ where \\f$k = col\\_block\\_dim \\times kb\\f$ otherwise.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p n, \\p kb, \\p nnzb, \\p ldb, \\p ldc, \\p row_block_dim\n              or \\p col_block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p B, \\p beta or \\p C pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A != \\ref rocsparse_operation_none or\n              \\p trans_B == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies a GEneral BSR matrix with a dense matrix.\n  \\code{.c}\n      //     1 2 0 3 0 0\n      // A = 0 4 5 0 0 0\n      //     0 0 0 7 8 0\n      //     0 0 1 2 4 1\n\n      rocsparse_int row_block_dim = 2;\n      rocsparse_int col_block_dim = 3;\n      rocsparse_int mb   = 2;\n      rocsparse_int kb   = 2;\n      rocsparse_int nnzb = 4;\n      rocsparse_direction dir = rocsparse_direction_row;\n\n      bsr_row_ptr[mb+1]                 = {0, 2, 4};                                        // device memory\n      bsr_col_ind[nnzb]                 = {0, 1, 0, 1};                                     // device memory\n      bsr_val[nnzb*row_block_dim*col_block_dim] = {1, 2, 0, 0, 4, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 7, 8, 0, 2, 4, 1}; // device memory\n\n      // Set dimension n of B\n      rocsparse_int n = 64;\n      rocsparse_int m = mb * row_block_dim;\n      rocsparse_int k = kb * col_block_dim;\n\n      // Allocate and generate dense matrix B\n      std::vector<float> hB(k * n);\n      for(rocsparse_int i = 0; i < k * n; ++i)\n      {\n          hB[i] = static_cast<float>(rand()) / RAND_MAX;\n      }\n\n      // Copy B to the device\n      float* B;\n      hipMalloc((void**)&B, sizeof(float) * k * n);\n      hipMemcpy(B, hB.data(), sizeof(float) * k * n, hipMemcpyHostToDevice);\n\n      // alpha and beta\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Allocate memory for the resulting matrix C\n      float* C;\n      hipMalloc((void**)&C, sizeof(float) * m * n);\n\n      // Perform the matrix multiplication\n      rocsparse_sgebsrmm(handle,\n                         dir,\n                         rocsparse_operation_none,\n                         rocsparse_operation_none,\n                         mb,\n                         n,\n                         kb,\n                         nnzb,\n                         &alpha,\n                         descr,\n                         bsr_val,\n                         bsr_row_ptr,\n                         bsr_col_ind,\n                         row_block_dim,\n                         col_block_dim,\n                         B,\n                         k,\n                         &beta,\n                         C,\n                         m);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sgebsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        B: *const f32,
        ldb: rocsparse_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        B: *const f64,
        ldb: rocsparse_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_float_complex,
        C: *mut rocsparse_float_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsrmm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        n: rocsparse_int,
        kb: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_double_complex,
        C: *mut rocsparse_double_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse matrix dense matrix multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrmm multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times k\\f$\n  matrix \\f$A\\f$, defined in CSR storage format, and the dense \\f$k \\times n\\f$\n  matrix \\f$B\\f$ and adds the result to the dense \\f$m \\times n\\f$ matrix \\f$C\\f$ that\n  is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot C,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < ldc; ++i)\n      {\n          for(j = 0; j < n; ++j)\n          {\n              C[i][j] = beta * C[i][j];\n\n              for(k = csr_row_ptr[i]; k < csr_row_ptr[i + 1]; ++k)\n              {\n                  C[i][j] += alpha * csr_val[k] * B[csr_col_ind[k]][j];\n              }\n          }\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans_A     matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B     matrix \\f$B\\f$ operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  n           number of columns of the dense matrix \\f$op(B)\\f$ and \\f$C\\f$.\n  @param[in]\n  k           number of columns of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix \\f$A\\f$.\n  @param[in]\n  B           array of dimension \\f$ldb \\times n\\f$ (\\f$op(B) == B\\f$),\n              \\f$ldb \\times k\\f$ otherwise.\n  @param[in]\n  ldb         leading dimension of \\f$B\\f$, must be at least \\f$\\max{(1, k)}\\f$\n              (\\f$op(B) == B\\f$), \\f$\\max{(1, n)}\\f$ otherwise.\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  C           array of dimension \\f$ldc \\times n\\f$.\n  @param[in]\n  ldc         leading dimension of \\f$C\\f$, must be at least \\f$\\max{(1, m)}\\f$\n              (\\f$op(A) == A\\f$), \\f$\\max{(1, k)}\\f$ otherwise.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz, \\p ldb or \\p ldc\n              is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p alpha, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p B, \\p beta or \\p C pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies a CSR matrix with a dense matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m   = 3;\n      rocsparse_int k   = 5;\n      rocsparse_int nnz = 8;\n\n      csr_row_ptr[m+1] = {0, 3, 5, 8};             // device memory\n      csr_col_ind[nnz] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      csr_val[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8}; // device memory\n\n      // Set dimension n of B\n      rocsparse_int n = 64;\n\n      // Allocate and generate dense matrix B\n      std::vector<float> hB(k * n);\n      for(rocsparse_int i = 0; i < k * n; ++i)\n      {\n          hB[i] = static_cast<float>(rand()) / RAND_MAX;\n      }\n\n      // Copy B to the device\n      float* B;\n      hipMalloc((void**)&B, sizeof(float) * k * n);\n      hipMemcpy(B, hB.data(), sizeof(float) * k * n, hipMemcpyHostToDevice);\n\n      // alpha and beta\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Allocate memory for the resulting matrix C\n      float* C;\n      hipMalloc((void**)&C, sizeof(float) * m * n);\n\n      // Perform the matrix multiplication\n      rocsparse_scsrmm(handle,\n                       rocsparse_operation_none,\n                       rocsparse_operation_none,\n                       m,\n                       n,\n                       k,\n                       nnz,\n                       &alpha,\n                       descr,\n                       csr_val,\n                       csr_row_ptr,\n                       csr_col_ind,\n                       B,\n                       k,\n                       &beta,\n                       C,\n                       m);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrmm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f32,
        ldb: rocsparse_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrmm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f64,
        ldb: rocsparse_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrmm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_float_complex,
        C: *mut rocsparse_float_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrmm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        beta: *const rocsparse_double_complex,
        C: *mut rocsparse_double_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsm_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_scsrsm_solve(),\n  rocsparse_dcsrsm_solve(), rocsparse_ccsrsm_solve() or rocsparse_zcsrsm_solve()\n  computation. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position,\n  using same index base as the CSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_csrsm_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_csrsm_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsm_buffer_size returns the size of the temporary storage buffer that\n  is required by rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(),\n  rocsparse_ccsrsm_analysis(), rocsparse_zcsrsm_analysis(), rocsparse_scsrsm_solve(),\n  rocsparse_dcsrsm_solve(), rocsparse_ccsrsm_solve() and rocsparse_zcsrsm_solve(). The\n  temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_B     matrix B operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(B).\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix A.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix A.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix A.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix A.\n  @param[in]\n  B           array of \\p m \\f$\\times\\f$ \\p nrhs elements of the rhs matrix B.\n  @param[in]\n  ldb         leading dimension of rhs matrix B.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(),\n              rocsparse_ccsrsm_analysis(), rocsparse_zcsrsm_analysis(),\n              rocsparse_scsrsm_solve(), rocsparse_dcsrsm_solve(),\n              rocsparse_ccsrsm_solve() and rocsparse_zcsrsm_solve().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p nrhs or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p descr, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p B, \\p info or \\p buffer_size pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_B == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrsm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f32,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f64,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsm_analysis performs the analysis step for rocsparse_scsrsm_solve(),\n  rocsparse_dcsrsm_solve(), rocsparse_ccsrsm_solve() and rocsparse_zcsrsm_solve(). It\n  is expected that this function will be executed only once for a given matrix and\n  particular operation type. The analysis meta data can be cleared by\n  rocsparse_csrsm_clear().\n\n  \\p rocsparse_csrsm_analysis can share its meta data with\n  rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n  rocsparse_ccsrilu0_analysis(), rocsparse_zcsrilu0_analysis(),\n  rocsparse_scsric0_analysis(), rocsparse_dcsric0_analysis(),\n  rocsparse_ccsric0_analysis(), rocsparse_zcsric0_analysis(),\n  rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(),\n  rocsparse_ccsrsv_analysis() and rocsparse_zcsrsv_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_B     matrix B operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(B).\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix A.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix A.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix A.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix A.\n  @param[in]\n  B           array of \\p m \\f$\\times\\f$ \\p nrhs elements of the rhs matrix B.\n  @param[in]\n  ldb         leading dimension of rhs matrix B.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p nrhs or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p descr, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p B, \\p info or \\p temp_buffer pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_B == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrsm_analysis(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f32,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsm_analysis(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const f64,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsm_analysis(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsm_analysis(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsm_clear deallocates all memory that was allocated by\n  rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(), rocsparse_ccsrsm_analysis()\n  or rocsparse_zcsrsm_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation, e.g. when switching to\n  another sparse matrix format. Calling \\p rocsparse_csrsm_clear is optional. All\n  allocated resources will be cleared, when the opaque \\ref rocsparse_mat_info struct\n  is destroyed using rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csrsm_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using CSR storage format\n\n  \\details\n  \\p rocsparse_csrsm_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR storage format, a dense solution matrix\n  \\f$X\\f$ and the right-hand side matrix \\f$B\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot op(X) = \\alpha \\cdot op(B),\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  ,\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(X) = \\left\\{\n    \\begin{array}{ll}\n        X,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        X^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        X^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_csrsm_solve requires a user allocated temporary buffer. Its size is\n  returned by rocsparse_scsrsm_buffer_size(), rocsparse_dcsrsm_buffer_size(),\n  rocsparse_ccsrsm_buffer_size() or rocsparse_zcsrsm_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_scsrsm_analysis(),\n  rocsparse_dcsrsm_analysis(), rocsparse_ccsrsm_analysis() or\n  rocsparse_zcsrsm_analysis(). \\p rocsparse_csrsm_solve reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be checked calling\n  rocsparse_csrsm_zero_pivot(). If\n  \\ref rocsparse_diag_type == \\ref rocsparse_diag_type_unit, no zero pivot will be\n  reported, even if \\f$A_{j,j} = 0\\f$ for some \\f$j\\f$.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans_A != \\ref rocsparse_operation_conjugate_transpose and\n  \\p trans_B != \\ref rocsparse_operation_conjugate_transpose is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_B     matrix B operation type.\n  @param[in]\n  m           number of rows of the sparse CSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(B).\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix A.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix A.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix A.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix A.\n  @param[inout]\n  B           array of \\p m \\f$\\times\\f$ \\p nrhs elements of the rhs matrix B.\n  @param[in]\n  ldb         leading dimension of rhs matrix B.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p nrhs or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p descr, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p B, \\p info or \\p temp_buffer pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_B == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the lower triangular \\f$m \\times m\\f$ matrix \\f$L\\f$, stored in CSR\n  storage format with unit diagonal. The following example solves \\f$L \\cdot X = B\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor\n      rocsparse_mat_descr descr;\n      rocsparse_create_mat_descr(&descr);\n      rocsparse_set_mat_fill_mode(descr, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr, rocsparse_diag_type_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size;\n      rocsparse_dcsrsm_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nrhs,\n                                   nnz,\n                                   &alpha,\n                                   descr,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   B,\n                                   ldb,\n                                   info,\n                                   rocsparse_solve_policy_auto,\n                                   &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis step\n      rocsparse_dcsrsm_analysis(handle,\n                                rocsparse_operation_none,\n                                rocsparse_operation_none,\n                                m,\n                                nrhs,\n                                nnz,\n                                &alpha,\n                                descr,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                B,\n                                ldb,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Solve LX = B\n      rocsparse_dcsrsm_solve(handle,\n                             rocsparse_operation_none,\n                             rocsparse_operation_none,\n                             m,\n                             nrhs,\n                             nnz,\n                             &alpha,\n                             descr,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             B,\n                             ldb,\n                             info,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // No zero pivot should be found, with L having unit diagonal\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrsm_solve(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *mut f32,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrsm_solve(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *mut f64,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrsm_solve(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *mut rocsparse_float_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrsm_solve(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        nrhs: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        B: *mut rocsparse_double_complex,
        ldb: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsm_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_sbsrsm_solve(),\n  rocsparse_dbsrsm_solve(), rocsparse_cbsrsm_solve() or rocsparse_zbsrsm_solve()\n  computation. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position,\n  using same index base as the BSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_bsrsm_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_bsrsm_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsm_buffer_size returns the size of the temporary storage buffer that\n  is required by rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(),\n  rocsparse_cbsrsm_analysis(), rocsparse_zbsrsm_analysis(), rocsparse_sbsrsm_solve(),\n  rocsparse_dbsrsm_solve(), rocsparse_cbsrsm_solve() and rocsparse_zbsrsm_solve(). The\n  temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_X     matrix X operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(X).\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix A.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix A.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim   block dimension of the sparse BSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(),\n              rocsparse_cbsrsm_analysis(), rocsparse_zbsrsm_analysis(),\n              rocsparse_sbsrsm_solve(), rocsparse_dbsrsm_solve(),\n              rocsparse_cbsrsm_solve() and rocsparse_zbsrsm_solve().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nrhs, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p info or \\p buffer_size pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_X == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrsm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsm_analysis performs the analysis step for rocsparse_sbsrsm_solve(),\n  rocsparse_dbsrsm_solve(), rocsparse_cbsrsm_solve() and rocsparse_zbsrsm_solve(). It\n  is expected that this function will be executed only once for a given matrix and\n  particular operation type. The analysis meta data can be cleared by\n  rocsparse_bsrsm_clear().\n\n  \\p rocsparse_bsrsm_analysis can share its meta data with\n  rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(),\n  rocsparse_cbsrilu0_analysis(), rocsparse_zbsrilu0_analysis(),\n  rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(),\n  rocsparse_cbsric0_analysis(), rocsparse_zbsric0_analysis(),\n  rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(),\n  rocsparse_cbsrsv_analysis() and rocsparse_zbsrsv_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_X     matrix X operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(X).\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix A.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix A.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix A.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix A.\n  @param[in]\n  bsr_col_ind array of \\p nnzb containing the block column indices of the sparse\n              BSR matrix A.\n  @param[in]\n  block_dim   block dimension of the sparse BSR matrix A.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nrhs, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_X == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrsm_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsm_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsm_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsm_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsm_clear deallocates all memory that was allocated by\n  rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(), rocsparse_cbsrsm_analysis()\n  or rocsparse_zbsrsm_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation, e.g. when switching to\n  another sparse matrix format. Calling \\p rocsparse_bsrsm_clear is optional. All\n  allocated resources will be cleared, when the opaque \\ref rocsparse_mat_info struct\n  is destroyed using rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_bsrsm_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Sparse triangular system solve using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrsm_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in BSR storage format, a dense solution matrix\n  \\f$X\\f$ and the right-hand side matrix \\f$B\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot op(X) = \\alpha \\cdot op(B),\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  ,\n  \\f[\n    op(X) = \\left\\{\n    \\begin{array}{ll}\n        X,   & \\text{if trans_X == rocsparse_operation_none} \\\\\n        X^T, & \\text{if trans_X == rocsparse_operation_transpose} \\\\\n        X^H, & \\text{if trans_X == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\p rocsparse_bsrsm_solve requires a user allocated temporary buffer. Its size is\n  returned by rocsparse_sbsrsm_buffer_size(), rocsparse_dbsrsm_buffer_size(),\n  rocsparse_cbsrsm_buffer_size() or rocsparse_zbsrsm_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_sbsrsm_analysis(),\n  rocsparse_dbsrsm_analysis(), rocsparse_cbsrsm_analysis() or\n  rocsparse_zbsrsm_analysis(). \\p rocsparse_bsrsm_solve reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be checked calling\n  rocsparse_bsrsm_zero_pivot(). If\n  \\ref rocsparse_diag_type == \\ref rocsparse_diag_type_unit, no zero pivot will be\n  reported, even if \\f$A_{j,j} = 0\\f$ for some \\f$j\\f$.\n\n  \\note\n  The sparse BSR matrix has to be sorted.\n\n  \\note\n  Operation type of B and X must match, if \\f$op(B)=B, op(X)=X\\f$.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  Currently, only \\p trans_A != \\ref rocsparse_operation_conjugate_transpose and\n  \\p trans_X != \\ref rocsparse_operation_conjugate_transpose is supported.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         matrix storage of BSR blocks.\n  @param[in]\n  trans_A     matrix A operation type.\n  @param[in]\n  trans_X     matrix X operation type.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix A.\n  @param[in]\n  nrhs        number of columns of the dense matrix op(X).\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix A.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix A.\n  @param[in]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb containing the block column indices of the sparse\n              BSR matrix.\n  @param[in]\n  block_dim   block dimension of the sparse BSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  B           rhs matrix B with leading dimension \\p ldb.\n  @param[in]\n  ldb         leading dimension of rhs matrix B.\n  @param[out]\n  X           solution matrix X with leading dimension \\p ldx.\n  @param[in]\n  ldx         leading dimension of solution matrix X.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nrhs, \\p nnzb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p descr, \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p B, \\p X \\p info or \\p temp_buffer pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans_A == \\ref rocsparse_operation_conjugate_transpose,\n              \\p trans_X == \\ref rocsparse_operation_conjugate_transpose or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrsm_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f32,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        B: *const f32,
        ldb: rocsparse_int,
        X: *mut f32,
        ldx: rocsparse_int,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrsm_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const f64,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        B: *const f64,
        ldb: rocsparse_int,
        X: *mut f64,
        ldx: rocsparse_int,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrsm_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        X: *mut rocsparse_float_complex,
        ldx: rocsparse_int,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrsm_solve(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_X: rocsparse_operation,
        mb: rocsparse_int,
        nrhs: rocsparse_int,
        nnzb: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        X: *mut rocsparse_double_complex,
        ldx: rocsparse_int,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup level3_module\n  \\brief Dense matrix sparse matrix multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_gemmi multiplies the scalar \\f$\\alpha\\f$ with a dense \\f$m \\times k\\f$\n  matrix \\f$A\\f$ and the sparse \\f$k \\times n\\f$ matrix \\f$B\\f$, defined in CSR\n  storage format and adds the result to the dense \\f$m \\times n\\f$ matrix \\f$C\\f$ that\n  is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot C\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  trans_A     matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B     matrix \\f$B\\f$ operation type.\n  @param[in]\n  m           number of rows of the dense matrix \\f$A\\f$.\n  @param[in]\n  n           number of columns of the sparse CSR matrix \\f$op(B)\\f$ and \\f$C\\f$.\n  @param[in]\n  k           number of columns of the dense matrix \\f$A\\f$.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  A           array of dimension \\f$lda \\times k\\f$ (\\f$op(A) == A\\f$) or\n              \\f$lda \\times m\\f$ (\\f$op(A) == A^T\\f$ or \\f$op(A) == A^H\\f$).\n  @param[in]\n  lda         leading dimension of \\f$A\\f$, must be at least \\f$m\\f$\n              (\\f$op(A) == A\\f$) or \\f$k\\f$ (\\f$op(A) == A^T\\f$ or\n              \\f$op(A) == A^H\\f$).\n  @param[in]\n  descr       descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse CSR\n              matrix \\f$B\\f$.\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  C           array of dimension \\f$ldc \\times n\\f$ that holds the values of \\f$C\\f$.\n  @param[in]\n  ldc         leading dimension of \\f$C\\f$, must be at least \\f$m\\f$.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz, \\p lda or \\p ldc\n              is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p alpha, \\p A, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p beta or \\p C pointer is invalid.\n\n  \\par Example\n  This example multiplies a dense matrix with a CSC matrix.\n  \\code{.c}\n      rocsparse_int m   = 2;\n      rocsparse_int n   = 5;\n      rocsparse_int k   = 3;\n      rocsparse_int nnz = 8;\n      rocsparse_int lda = m;\n      rocsparse_int ldc = m;\n\n      // Matrix A (m x k)\n      // (  9.0  10.0  11.0 )\n      // ( 12.0  13.0  14.0 )\n\n      // Matrix B (k x n)\n      // ( 1.0  2.0  0.0  3.0  0.0 )\n      // ( 0.0  4.0  5.0  0.0  0.0 )\n      // ( 6.0  0.0  0.0  7.0  8.0 )\n\n      // Matrix C (m x n)\n      // ( 15.0  16.0  17.0  18.0  19.0 )\n      // ( 20.0  21.0  22.0  23.0  24.0 )\n\n      A[lda * k]           = {9.0, 12.0, 10.0, 13.0, 11.0, 14.0};      // device memory\n      csc_col_ptr_B[n + 1] = {0, 2, 4, 5, 7, 8};                       // device memory\n      csc_row_ind_B[nnz]   = {0, 0, 1, 1, 2, 3, 3, 4};                 // device memory\n      csc_val_B[nnz]       = {1.0, 6.0, 2.0, 4.0, 5.0, 3.0, 7.0, 8.0}; // device memory\n      C[ldc * n]           = {15.0, 20.0, 16.0, 21.0, 17.0, 22.0,      // device memory\n                              18.0, 23.0, 19.0, 24.0};\n\n      // alpha and beta\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Perform the matrix multiplication\n      rocsparse_sgemmi(handle,\n                       rocsparse_operation_none,\n                       rocsparse_operation_transpose,\n                       m,\n                       n,\n                       k,\n                       nnz,\n                       &alpha,\n                       A,\n                       lda,\n                       descr_B,\n                       csc_val_B,\n                       csc_col_ptr_B,\n                       csc_row_ind_B,\n                       &beta,\n                       C,\n                       ldc);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sgemmi(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f32,
        A: *const f32,
        lda: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        beta: *const f32,
        C: *mut f32,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgemmi(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const f64,
        A: *const f64,
        lda: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        beta: *const f64,
        C: *mut f64,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgemmi(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        A: *const rocsparse_float_complex,
        lda: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        C: *mut rocsparse_float_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgemmi(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        nnz: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        A: *const rocsparse_double_complex,
        lda: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        C: *mut rocsparse_double_complex,
        ldc: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix addition using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrgeam_nnz computes the total BSR non-zero elements and the BSR row\n  offsets, that point to the start of every row of the sparse BSR matrix, of the\n  resulting matrix C. It is assumed that \\p bsr_row_ptr_C has been allocated with\n  size \\p mb+1.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n                  \\ref rocsparse_direction_row in the BSR matrices \\f$A\\f$, \\f$B\\f$, and \\f$C\\f$.\n  @param[in]\n  mb              number of block rows in the sparse BSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  nb              number of block columns of the sparse BSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  block_dim       the block dimension of the BSR matrix \\f$A\\f$. Between 1 and m where \\p m=mb*block_dim.\n  @param[in]\n  descr_A         descriptor of the sparse BSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_A          number of non-zero block entries of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr_A   array of \\p mb+1 elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_col_ind_A   array of \\p nnzb_A elements containing the column indices of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse BSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_B          number of non-zero block entries of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_row_ptr_B   array of \\p mb+1 elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_col_ind_B   array of \\p nnzb_B elements containing the block column indices of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse BSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_row_ptr_C   array of \\p mb+1 elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$C\\f$.\n  @param[out]\n  nnzb_C          pointer to the number of non-zero block entries of the sparse BSR\n                  matrix \\f$C\\f$. \\p nnzb_C can be a host or device pointer.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p mb, \\p nb, \\p kb, \\p nnzb_A or \\p nnzb_B is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p descr_A, \\p bsr_row_ptr_A,\n          \\p bsr_col_ind_A, \\p descr_B, \\p bsr_row_ptr_B, \\p bsr_col_ind_B,\n          \\p descr_C, \\p bsr_row_ptr_C or \\p nnzb_C is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_bsrgeam_nnzb(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        block_dim: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_row_ptr_C: *mut rocsparse_int,
        nnzb_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix addition using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrgeam multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$m \\times n\\f$ matrix \\f$A\\f$, defined in BSR storage format, multiplies the\n  scalar \\f$\\beta\\f$ with the sparse \\f$mb \\times nb\\f$ matrix \\f$B\\f$, defined in BSR\n  storage format, and adds both resulting matrices to obtain the sparse\n  \\f$mb \\times nb\\f$ matrix \\f$C\\f$, defined in BSR storage format, such that\n  \\f[\n    C := \\alpha \\cdot A + \\beta \\cdot B.\n  \\f]\n\n  It is assumed that \\p bsr_row_ptr_C has already been filled and that \\p bsr_val_C and\n  \\p bsr_col_ind_C are allocated by the user. \\p bsr_row_ptr_C and allocation size of\n  \\p bsr_col_ind_C and \\p bsr_val_C is defined by the number of non-zero block elements of\n  the sparse BSR matrix C. Both can be obtained by rocsparse_bsrgeam_nnz().\n\n  \\note Both scalars \\f$\\alpha\\f$ and \\f$beta\\f$ have to be valid.\n\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n                  \\ref rocsparse_direction_row in the BSR matrices \\f$A\\f$, \\f$B\\f$, and \\f$C\\f$.\n  @param[in]\n  mb               number of rows of the sparse BSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  nb               number of columns of the sparse BSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  block_dim       the block dimension of the BSR matrix \\f$A\\f$. Between 1 and m where \\p m=mb*block_dim.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_A           number of non-zero block entries of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_val_A       array of \\p nnzb_A block elements of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr_A   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_col_ind_A   array of \\p nnzb_A block elements containing the block column indices of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse BSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_B          number of non-zero block entries of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_val_B       array of \\p nnzb_B block elements of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_row_ptr_B   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_col_ind_B   array of \\p nnzb_B block elements containing the block column indices of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse BSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_val_C       array of block elements of the sparse BSR matrix \\f$C\\f$.\n  @param[in]\n  bsr_row_ptr_C   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$C\\f$.\n  @param[out]\n  bsr_col_ind_C   array of block elements containing the block column indices of the\n                  sparse BSR matrix \\f$C\\f$.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p mb, \\p nb, \\p nnzb_A or \\p nnzb_B is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha, \\p descr_A, \\p bsr_val_A,\n          \\p bsr_row_ptr_A, \\p bsr_col_ind_A, \\p beta, \\p descr_B, \\p bsr_val_B,\n          \\p bsr_row_ptr_B, \\p bsr_col_ind_B, \\p descr_C, \\p csr_val_C,\n          \\p bsr_row_ptr_C or \\p bsr_col_ind_C is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example adds two CSR matrices.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 1.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Obtain number of total non-zero block entries in C and block row pointers of C\n  rocsparse_int nnzb_C;\n  hipMalloc((void**)&bsr_row_ptr_C, sizeof(rocsparse_int) * (mb + 1));\n\n  rocsparse_bsrgeam_nnzb(handle,\n                        dir,\n                        mb,\n                        nb,\n                        block_dim,\n                        descr_A,\n                        nnzb_A,\n                        bsr_row_ptr_A,\n                        bsr_col_ind_A,\n                        descr_B,\n                        nnzb_B,\n                        bsr_row_ptr_B,\n                        bsr_col_ind_B,\n                        descr_C,\n                        bsr_row_ptr_C,\n                        &nnzb_C);\n\n  // Compute block column indices and block values of C\n  hipMalloc((void**)&bsr_col_ind_C, sizeof(rocsparse_int) * nnzb_C);\n  hipMalloc((void**)&bsr_val_C, sizeof(float) * nnzb_C * block_dim * block_dim);\n\n  rocsparse_sbsrgeam(handle,\n                     dir,\n                     mb,\n                     nb,\n                     block_dim,\n                     &alpha,\n                     descr_A,\n                     nnzb_A,\n                     bsr_val_A,\n                     bsr_row_ptr_A,\n                     bsr_col_ind_A,\n                     &beta,\n                     descr_B,\n                     nnzb_B,\n                     bsr_val_B,\n                     bsr_row_ptr_B,\n                     bsr_col_ind_B,\n                     descr_C,\n                     bsr_val_C,\n                     bsr_row_ptr_C,\n                     bsr_col_ind_C);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsrgeam(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const f32,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        beta: *const f32,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const f32,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f32,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrgeam(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const f64,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        beta: *const f64,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const f64,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f64,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrgeam(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const rocsparse_float_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const rocsparse_float_complex,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_float_complex,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrgeam(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const rocsparse_double_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const rocsparse_double_complex,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_double_complex,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix addition using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgeam_nnz computes the total CSR non-zero elements and the CSR row\n  offsets, that point to the start of every row of the sparse CSR matrix, of the\n  resulting matrix C. It is assumed that \\p csr_row_ptr_C has been allocated with\n  size \\p m+1.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  nnz_C           pointer to the number of non-zero entries of the sparse CSR\n                  matrix \\f$C\\f$. \\p nnz_C can be a host or device pointer.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p nnz_A or \\p nnz_B is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p descr_A, \\p csr_row_ptr_A,\n          \\p csr_col_ind_A, \\p descr_B, \\p csr_row_ptr_B, \\p csr_col_ind_B,\n          \\p descr_C, \\p csr_row_ptr_C or \\p nnz_C is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_csrgeam_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix addition using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgeam multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$m \\times n\\f$ matrix \\f$A\\f$, defined in CSR storage format, multiplies the\n  scalar \\f$\\beta\\f$ with the sparse \\f$m \\times n\\f$ matrix \\f$B\\f$, defined in CSR\n  storage format, and adds both resulting matrices to obtain the sparse\n  \\f$m \\times n\\f$ matrix \\f$C\\f$, defined in CSR storage format, such that\n  \\f[\n    C := \\alpha \\cdot A + \\beta \\cdot B.\n  \\f]\n\n  It is assumed that \\p csr_row_ptr_C has already been filled and that \\p csr_val_C and\n  \\p csr_col_ind_C are allocated by the user. \\p csr_row_ptr_C and allocation size of\n  \\p csr_col_ind_C and \\p csr_val_C is defined by the number of non-zero elements of\n  the sparse CSR matrix C. Both can be obtained by rocsparse_csrgeam_nnz().\n\n  \\note Both scalars \\f$\\alpha\\f$ and \\f$beta\\f$ have to be valid.\n\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$A\\f$, \\f$B\\f$ and \\f$C\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_val_A       array of \\p nnz_A elements of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_val_B       array of \\p nnz_B elements of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val_C       array of elements of the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  csr_col_ind_C   array of elements containing the column indices of the\n                  sparse CSR matrix \\f$C\\f$.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p nnz_A or \\p nnz_B is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha, \\p descr_A, \\p csr_val_A,\n          \\p csr_row_ptr_A, \\p csr_col_ind_A, \\p beta, \\p descr_B, \\p csr_val_B,\n          \\p csr_row_ptr_B, \\p csr_col_ind_B, \\p descr_C, \\p csr_val_C,\n          \\p csr_row_ptr_C or \\p csr_col_ind_C is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example adds two CSR matrices.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 1.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Obtain number of total non-zero entries in C and row pointers of C\n  rocsparse_int nnz_C;\n  hipMalloc((void**)&csr_row_ptr_C, sizeof(rocsparse_int) * (m + 1));\n\n  rocsparse_csrgeam_nnz(handle,\n                        m,\n                        n,\n                        descr_A,\n                        nnz_A,\n                        csr_row_ptr_A,\n                        csr_col_ind_A,\n                        descr_B,\n                        nnz_B,\n                        csr_row_ptr_B,\n                        csr_col_ind_B,\n                        descr_C,\n                        csr_row_ptr_C,\n                        &nnz_C);\n\n  // Compute column indices and values of C\n  hipMalloc((void**)&csr_col_ind_C, sizeof(rocsparse_int) * nnz_C);\n  hipMalloc((void**)&csr_val_C, sizeof(float) * nnz_C);\n\n  rocsparse_scsrgeam(handle,\n                     m,\n                     n,\n                     &alpha,\n                     descr_A,\n                     nnz_A,\n                     csr_val_A,\n                     csr_row_ptr_A,\n                     csr_col_ind_A,\n                     &beta,\n                     descr_B,\n                     nnz_B,\n                     csr_val_B,\n                     csr_row_ptr_B,\n                     csr_col_ind_B,\n                     descr_C,\n                     csr_val_C,\n                     csr_row_ptr_C,\n                     csr_col_ind_C);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrgeam(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        beta: *const f32,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f32,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrgeam(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        beta: *const f64,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f64,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrgeam(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_float_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_float_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut rocsparse_float_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrgeam(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_double_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_double_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut rocsparse_double_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrgemm_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_bsrgemm_nnzb(), rocsparse_sbsrgemm(),\n  rocsparse_dbsrgemm(), rocsparse_cbsrgemm() and rocsparse_zbsrgemm(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  This function is blocking with respect to the host.\n  \\note\n  Currently, only \\p trans_A == \\p trans_B == \\ref rocsparse_operation_none is\n  supported.\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n                  \\ref rocsparse_direction_row in the BSR matrices \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  mb              number of block rows in the sparse BSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  nb              number of block columns of the sparse BSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  kb              number of block columns of the sparse BSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse BSR matrix \\f$op(B)\\f$.\n  @param[in]\n  block_dim       the block dimension of the BSR matrix \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse BSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_A          number of non-zero block entries of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr_A   array of \\p mb+1 elements (\\f$op(A) == A\\f$, \\p kb+1 otherwise)\n                  that point to the start of every block row of the sparse BSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  bsr_col_ind_A   array of \\p nnzb_A elements containing the block column indices of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse BSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_B          number of non-zero block entries of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_row_ptr_B   array of \\p kb+1 elements (\\f$op(B) == B\\f$, \\p mb+1 otherwise)\n                  that point to the start of every block row of the sparse BSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  bsr_col_ind_B   array of \\p nnzb_B elements containing the block column indices of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse BSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_D          number of non-zero block entries of the sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_row_ptr_D   array of \\p mb+1 elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_col_ind_D   array of \\p nnzb_D elements containing the block column indices of the sparse\n                  BSR matrix \\f$D\\f$.\n  @param[inout]\n  info_C          structure that holds meta data for the sparse BSR matrix \\f$C\\f$.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_bsrgemm_nnzb(), rocsparse_sbsrgemm(), rocsparse_dbsrgemm(),\n                  rocsparse_cbsrgemm() and rocsparse_zbsrgemm().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p mb, \\p nb, \\p kb, \\p block_dim, \\p nnzb_A, \\p nnzb_B or\n          \\p nnzb_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p descr_A, \\p bsr_row_ptr_A, \\p bsr_col_ind_A, \\p descr_B,\n          \\p bsr_row_ptr_B or \\p bsr_col_ind_B are invalid if \\p alpha is valid,\n          \\p descr_D, \\p bsr_row_ptr_D or \\p bsr_col_ind_D is invalid if \\p beta is\n          valid, \\p info_C or \\p buffer_size is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrgemm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const f32,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrgemm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const f64,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrgemm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrgemm_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrgemm_nnzb computes the total BSR non-zero block elements and the BSR block row\n  offsets, that point to the start of every block row of the sparse BSR matrix, of the\n  resulting multiplied matrix C. It is assumed that \\p bsr_row_ptr_C has been allocated\n  with size \\p mb+1.\n  The required buffer size can be obtained by rocsparse_sbsrgemm_buffer_size(),\n  rocsparse_dbsrgemm_buffer_size(), rocsparse_cbsrgemm_buffer_size() and\n  rocsparse_zbsrgemm_buffer_size(), respectively.\n\n  \\note\n  This function is blocking with respect to the host.\n  \\note\n  Currently, only \\p trans_A == \\p trans_B == \\ref rocsparse_operation_none is\n  supported.\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n                  \\ref rocsparse_direction_row in the BSR matrices \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  mb              number of block rows in the sparse BSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  nb              number of block columns of the sparse BSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  kb              number of block columns of the sparse BSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse BSR matrix \\f$op(B)\\f$.\n  @param[in]\n  block_dim       the block dimension of the BSR matrix \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse BSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_A          number of non-zero block entries of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr_A   array of \\p mb+1 block elements (\\f$op(A) == A\\f$, \\p kb+1 otherwise)\n                  that point to the start of every row of the sparse BSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  bsr_col_ind_A   array of \\p nnzb_A block elements containing the block column indices of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse BSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_B          number of non-zero block entries of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_row_ptr_B   array of \\p kb+1 block elements (\\f$op(B) == B\\f$, \\p mb+1 otherwise)\n                  that point to the start of every block row of the sparse BSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  bsr_col_ind_B   array of \\p nnzb_B block elements containing the block column indices of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse BSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_D          number of non-zero block entries of the sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_row_ptr_D   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_col_ind_D   array of \\p nnzb_D block elements containing the block column indices of the sparse\n                  BSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse BSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_row_ptr_C   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$C\\f$.\n  @param[out]\n  nnzb_C          pointer to the number of non-zero block entries of the sparse BSR\n                  matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse BSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_sbsrgemm_buffer_size(),\n                  rocsparse_dbsrgemm_buffer_size(), rocsparse_cbsrgemm_buffer_size() or\n                  rocsparse_zbsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p mb, \\p nb, \\p kb, \\p block_dim, \\p nnzb_A, \\p nnzb_B or\n          \\p nnzb_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p descr_A, \\p bsr_row_ptr_A,\n          \\p bsr_col_ind_A, \\p descr_B, \\p bsr_row_ptr_B, \\p bsr_col_ind_B,\n          \\p descr_D, \\p bsr_row_ptr_D, \\p bsr_col_ind_D, \\p descr_C,\n          \\p bsr_row_ptr_C, \\p nnzb_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_bsrgemm_nnzb(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_row_ptr_C: *mut rocsparse_int,
        nnzb_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using BSR storage format\n\n  \\details\n  \\p rocsparse_bsrgemm multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$mb \\times kb\\f$ matrix \\f$A\\f$, defined in BSR storage format, and the sparse\n  \\f$kb \\times nb\\f$ matrix \\f$B\\f$, defined in BSR storage format, and adds the result\n  to the sparse \\f$mb \\times nb\\f$ matrix \\f$D\\f$ that is multiplied by \\f$\\beta\\f$. The\n  final result is stored in the sparse \\f$mb \\times nb\\f$ matrix \\f$C\\f$, defined in BSR\n  storage format, such\n  that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot D,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  It is assumed that \\p bsr_row_ptr_C has already been filled and that \\p bsr_val_C and\n  \\p bsr_col_ind_C are allocated by the user. \\p bsr_row_ptr_C and allocation size of\n  \\p bsr_col_ind_C and \\p bsr_val_C is defined by the number of non-zero elements of\n  the sparse BSR matrix C. Both can be obtained by rocsparse_bsrgemm_nnzb(). The\n  required buffer size for the computation can be obtained by\n  rocsparse_sbsrgemm_buffer_size(), rocsparse_dbsrgemm_buffer_size(),\n  rocsparse_cbsrgemm_buffer_size() and rocsparse_zbsrgemm_buffer_size(), respectively.\n\n  \\note If \\f$\\alpha == 0\\f$, then \\f$C = \\beta \\cdot D\\f$ will be computed.\n  \\note If \\f$\\beta == 0\\f$, then \\f$C = \\alpha \\cdot op(A) \\cdot op(B)\\f$ will be computed.\n  \\note \\f$\\alpha == beta == 0\\f$ is invalid.\n  \\note Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\p trans_B == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n  \\note This function is blocking with respect to the host.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n                  \\ref rocsparse_direction_row in the BSR matrices \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  mb              number of block rows of the sparse BSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  nb              number of block columns of the sparse BSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  kb              number of block columns of the sparse BSR matrix \\f$op(A)\\f$ and number of\n                  block rows of the sparse BSR matrix \\f$op(B)\\f$.\n  @param[in]\n  block_dim       the block dimension of the BSR matrix \\f$A\\f$, \\f$B\\f$, \\f$C\\f$, and \\f$D\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse BSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_A          number of non-zero block entries of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_val_A       array of \\p nnzb_A block elements of the sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  bsr_row_ptr_A   array of \\p mb+1 block elements (\\f$op(A) == A\\f$, \\p kb+1 otherwise)\n                  that point to the start of every block row of the sparse BSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  bsr_col_ind_A   array of \\p nnzb_A block elements containing the block column indices of the\n                  sparse BSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse BSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_B          number of non-zero block entries of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_val_B       array of \\p nnzb_B block elements of the sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  bsr_row_ptr_B   array of \\p kb+1 block elements (\\f$op(B) == B\\f$, \\p mb+1 otherwise)\n                  that point to the start of every block row of the sparse BSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  bsr_col_ind_B   array of \\p nnzb_B block elements containing the block column indices of the\n                  sparse BSR matrix \\f$B\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse BSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnzb_D          number of non-zero block entries of the sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_val_D       array of \\p nnzb_D block elements of the sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_row_ptr_D   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  bsr_col_ind_D   array of \\p nnzb_D block elements containing the block column indices of the\n                  sparse BSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse BSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_val_C       array of \\p nnzb_C elements of the sparse BSR matrix \\f$C\\f$.\n  @param[in]\n  bsr_row_ptr_C   array of \\p mb+1 block elements that point to the start of every block row of the\n                  sparse BSR matrix \\f$C\\f$.\n  @param[out]\n  bsr_col_ind_C   array of \\p nnzb_C block elements containing the block column indices of the\n                  sparse BSR matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse BSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_sbsrgemm_buffer_size(),\n                  rocsparse_dbsrgemm_buffer_size(), rocsparse_cbsrgemm_buffer_size() or\n                  rocsparse_zbsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p mb, \\p nb, \\p kb, \\p block_dim, \\p nnzb_A, \\p nnzb_B or\n          \\p nnzb_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p descr_A, \\p bsr_val_A, \\p bsr_row_ptr_A, \\p bsr_col_ind_A, \\p descr_B,\n          \\p bsr_val_B, \\p bsr_row_ptr_B or \\p bsr_col_ind_B are invalid if \\p alpha\n          is valid, \\p descr_D, \\p bsr_val_D, \\p bsr_row_ptr_D or \\p bsr_col_ind_D is\n          invalid if \\p beta is valid, \\p bsr_val_C, \\p bsr_row_ptr_C,\n          \\p bsr_col_ind_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies two BSR matrices with a scalar alpha and adds the result to\n  another BSR matrix.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 2.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n  rocsparse_mat_descr descr_D;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n  rocsparse_create_mat_descr(&descr_D);\n\n  // Create matrix info structure\n  rocsparse_mat_info info_C;\n  rocsparse_create_mat_info(&info_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Query rocsparse for the required buffer size\n  size_t buffer_size;\n\n  rocsparse_sbsrgemm_buffer_size(handle,\n                                 rocsparse_direction_row,\n                                 rocsparse_operation_none,\n                                 rocsparse_operation_none,\n                                 mb,\n                                 nb,\n                                 kb,\n                                 block_dim,\n                                 &alpha,\n                                 descr_A,\n                                 nnzb_A,\n                                 bsr_row_ptr_A,\n                                 bsr_col_ind_A,\n                                 descr_B,\n                                 nnzb_B,\n                                 bsr_row_ptr_B,\n                                 bsr_col_ind_B,\n                                 &beta,\n                                 descr_D,\n                                 nnzb_D,\n                                 bsr_row_ptr_D,\n                                 bsr_col_ind_D,\n                                 info_C,\n                                 &buffer_size);\n\n  // Allocate buffer\n  void* buffer;\n  hipMalloc(&buffer, buffer_size);\n\n  // Obtain number of total non-zero block entries in C and block row pointers of C\n  rocsparse_int nnzb_C;\n  hipMalloc((void**)&bsr_row_ptr_C, sizeof(rocsparse_int) * (mb + 1));\n\n  rocsparse_bsrgemm_nnzb(handle,\n                        rocsparse_direction_row,\n                        rocsparse_operation_none,\n                        rocsparse_operation_none,\n                        mb,\n                        nb,\n                        kb,\n                        block_dim,\n                        descr_A,\n                        nnzb_A,\n                        bsr_row_ptr_A,\n                        bsr_col_ind_A,\n                        descr_B,\n                        nnzb_B,\n                        bsr_row_ptr_B,\n                        bsr_col_ind_B,\n                        descr_D,\n                        nnzb_D,\n                        bsr_row_ptr_D,\n                        bsr_col_ind_D,\n                        descr_C,\n                        bsr_row_ptr_C,\n                        &nnzb_C,\n                        info_C,\n                        buffer);\n\n  // Compute block column indices and values of C\n  hipMalloc((void**)&bsr_col_ind_C, sizeof(rocsparse_int) * nnzb_C);\n  hipMalloc((void**)&bsr_val_C, sizeof(float) * block_dim * block_dim *nnzb_C);\n\n  rocsparse_sbsrgemm(handle,\n                     rocsparse_direction_row,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     mb,\n                     nb,\n                     kb,\n                     block_dim,\n                     &alpha,\n                     descr_A,\n                     nnzb_A,\n                     bsr_val_A,\n                     bsr_row_ptr_A,\n                     bsr_col_ind_A,\n                     descr_B,\n                     nnzb_B,\n                     bsr_val_B,\n                     bsr_row_ptr_B,\n                     bsr_col_ind_B,\n                     &beta,\n                     descr_D,\n                     nnzb_D,\n                     bsr_val_D,\n                     bsr_row_ptr_D,\n                     bsr_col_ind_D,\n                     descr_C,\n                     bsr_val_C,\n                     bsr_row_ptr_C,\n                     bsr_col_ind_C,\n                     info_C,\n                     buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsrgemm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const f32,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const f32,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const f32,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_val_D: *const f32,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f32,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrgemm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const f64,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const f64,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const f64,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_val_D: *const f64,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f64,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrgemm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const rocsparse_float_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const rocsparse_float_complex,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_val_D: *const rocsparse_float_complex,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_float_complex,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrgemm(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        mb: rocsparse_int,
        nb: rocsparse_int,
        kb: rocsparse_int,
        block_dim: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnzb_A: rocsparse_int,
        bsr_val_A: *const rocsparse_double_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnzb_B: rocsparse_int,
        bsr_val_B: *const rocsparse_double_complex,
        bsr_row_ptr_B: *const rocsparse_int,
        bsr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_D: rocsparse_mat_descr,
        nnzb_D: rocsparse_int,
        bsr_val_D: *const rocsparse_double_complex,
        bsr_row_ptr_D: *const rocsparse_int,
        bsr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_double_complex,
        bsr_row_ptr_C: *const rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgemm_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_csrgemm_nnz(), rocsparse_scsrgemm(),\n  rocsparse_dcsrgemm(), rocsparse_ccsrgemm() and rocsparse_zcsrgemm(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  Please note, that for matrix products with more than 4096 non-zero entries per row,\n  additional temporary storage buffer is allocated by the algorithm.\n  \\note\n  Please note, that for matrix products with more than 8192 intermediate products per\n  row, additional temporary storage buffer is allocated by the algorithm.\n  \\note\n  Currently, only \\p trans_A == \\p trans_B == \\ref rocsparse_operation_none is\n  supported.\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  k               number of columns of the sparse CSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse CSR matrix \\f$op(B)\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements (\\f$op(A) == A\\f$, \\p k+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p k+1 elements (\\f$op(B) == B\\f$, \\p m+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse CSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_D           number of non-zero entries of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_row_ptr_D   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_col_ind_D   array of \\p nnz_D elements containing the column indices of the sparse\n                  CSR matrix \\f$D\\f$.\n  @param[inout]\n  info_C          structure that holds meta data for the sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_csrgemm_nnz(), rocsparse_scsrgemm(), rocsparse_dcsrgemm(),\n                  rocsparse_ccsrgemm() and rocsparse_zcsrgemm().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz_A, \\p nnz_B or\n          \\p nnz_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p descr_A, \\p csr_row_ptr_A, \\p csr_col_ind_A, \\p descr_B,\n          \\p csr_row_ptr_B or \\p csr_col_ind_B are invalid if \\p alpha is valid,\n          \\p descr_D, \\p csr_row_ptr_D or \\p csr_col_ind_D is invalid if \\p beta is\n          valid, \\p info_C or \\p buffer_size is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrgemm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f32,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrgemm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f64,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrgemm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrgemm_buffer_size(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgemm_nnz computes the total CSR non-zero elements and the CSR row\n  offsets, that point to the start of every row of the sparse CSR matrix, of the\n  resulting multiplied matrix C. It is assumed that \\p csr_row_ptr_C has been allocated\n  with size \\p m+1.\n  The required buffer size can be obtained by rocsparse_scsrgemm_buffer_size(),\n  rocsparse_dcsrgemm_buffer_size(), rocsparse_ccsrgemm_buffer_size() and\n  rocsparse_zcsrgemm_buffer_size(), respectively.\n\n  \\note\n  Please note, that for matrix products with more than 8192 intermediate products per\n  row, additional temporary storage buffer is allocated by the algorithm.\n  \\note\n  This function supports unsorted CSR matrices as input, while output will be sorted.\n  Please note that matrices B and D can only be unsorted up to 8192 intermediate\n  products per row. If this number is exceeded, \\ref rocsparse_status_requires_sorted_storage\n  will be returned.\n  \\note\n  This function is blocking with respect to the host.\n  \\note\n  Currently, only \\p trans_A == \\p trans_B == \\ref rocsparse_operation_none is\n  supported.\n  \\note\n  Currently, only \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  k               number of columns of the sparse CSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse CSR matrix \\f$op(B)\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements (\\f$op(A) == A\\f$, \\p k+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p k+1 elements (\\f$op(B) == B\\f$, \\p m+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse CSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_D           number of non-zero entries of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_row_ptr_D   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_col_ind_D   array of \\p nnz_D elements containing the column indices of the sparse\n                  CSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  nnz_C           pointer to the number of non-zero entries of the sparse CSR\n                  matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_scsrgemm_buffer_size(),\n                  rocsparse_dcsrgemm_buffer_size(), rocsparse_ccsrgemm_buffer_size() or\n                  rocsparse_zcsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz_A, \\p nnz_B or\n          \\p nnz_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p descr_A, \\p csr_row_ptr_A,\n          \\p csr_col_ind_A, \\p descr_B, \\p csr_row_ptr_B, \\p csr_col_ind_B,\n          \\p descr_D, \\p csr_row_ptr_D, \\p csr_col_ind_D, \\p descr_C,\n          \\p csr_row_ptr_C, \\p nnz_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_csrgemm_nnz(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgemm multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$m \\times k\\f$ matrix \\f$A\\f$, defined in CSR storage format, and the sparse\n  \\f$k \\times n\\f$ matrix \\f$B\\f$, defined in CSR storage format, and adds the result\n  to the sparse \\f$m \\times n\\f$ matrix \\f$D\\f$ that is multiplied by \\f$\\beta\\f$. The\n  final result is stored in the sparse \\f$m \\times n\\f$ matrix \\f$C\\f$, defined in CSR\n  storage format, such\n  that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot D,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  It is assumed that \\p csr_row_ptr_C has already been filled and that \\p csr_val_C and\n  \\p csr_col_ind_C are allocated by the user. \\p csr_row_ptr_C and allocation size of\n  \\p csr_col_ind_C and \\p csr_val_C is defined by the number of non-zero elements of\n  the sparse CSR matrix C. Both can be obtained by rocsparse_csrgemm_nnz(). The\n  required buffer size for the computation can be obtained by\n  rocsparse_scsrgemm_buffer_size(), rocsparse_dcsrgemm_buffer_size(),\n  rocsparse_ccsrgemm_buffer_size() and rocsparse_zcsrgemm_buffer_size(), respectively.\n\n  \\note If \\f$\\alpha == 0\\f$, then \\f$C = \\beta \\cdot D\\f$ will be computed.\n  \\note If \\f$\\beta == 0\\f$, then \\f$C = \\alpha \\cdot op(A) \\cdot op(B)\\f$ will be computed.\n  \\note \\f$\\alpha == beta == 0\\f$ is invalid.\n  \\note Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\p trans_B == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n  \\note Please note, that for matrix products with more than 4096 non-zero entries per\n  row, additional temporary storage buffer is allocated by the algorithm.\n  \\note\n  This function supports unsorted CSR matrices as input, while output will be sorted.\n  Please note that matrices B and D can only be unsorted up to 4096 non-zero entries\n  per row. If this number is exceeded, \\ref rocsparse_status_requires_sorted_storage\n  will be returned.\n  \\note\n  This function is blocking with respect to the host.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  k               number of columns of the sparse CSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse CSR matrix \\f$op(B)\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_val_A       array of \\p nnz_A elements of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements (\\f$op(A) == A\\f$, \\p k+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_val_B       array of \\p nnz_B elements of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p k+1 elements (\\f$op(B) == B\\f$, \\p m+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse CSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_D           number of non-zero entries of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_val_D       array of \\p nnz_D elements of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_row_ptr_D   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_col_ind_D   array of \\p nnz_D elements containing the column indices of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val_C       array of \\p nnz_C elements of the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  csr_col_ind_C   array of \\p nnz_C elements containing the column indices of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_scsrgemm_buffer_size(),\n                  rocsparse_dcsrgemm_buffer_size(), rocsparse_ccsrgemm_buffer_size() or\n                  rocsparse_zcsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz_A, \\p nnz_B or\n          \\p nnz_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p descr_A, \\p csr_val_A, \\p csr_row_ptr_A, \\p csr_col_ind_A, \\p descr_B,\n          \\p csr_val_B, \\p csr_row_ptr_B or \\p csr_col_ind_B are invalid if \\p alpha\n          is valid, \\p descr_D, \\p csr_val_D, \\p csr_row_ptr_D or \\p csr_col_ind_D is\n          invalid if \\p beta is valid, \\p csr_val_C, \\p csr_row_ptr_C,\n          \\p csr_col_ind_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies two CSR matrices with a scalar alpha and adds the result to\n  another CSR matrix.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 2.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n  rocsparse_mat_descr descr_D;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n  rocsparse_create_mat_descr(&descr_D);\n\n  // Create matrix info structure\n  rocsparse_mat_info info_C;\n  rocsparse_create_mat_info(&info_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Query rocsparse for the required buffer size\n  size_t buffer_size;\n\n  rocsparse_scsrgemm_buffer_size(handle,\n                                 rocsparse_operation_none,\n                                 rocsparse_operation_none,\n                                 m,\n                                 n,\n                                 k,\n                                 &alpha,\n                                 descr_A,\n                                 nnz_A,\n                                 csr_row_ptr_A,\n                                 csr_col_ind_A,\n                                 descr_B,\n                                 nnz_B,\n                                 csr_row_ptr_B,\n                                 csr_col_ind_B,\n                                 &beta,\n                                 descr_D,\n                                 nnz_D,\n                                 csr_row_ptr_D,\n                                 csr_col_ind_D,\n                                 info_C,\n                                 &buffer_size);\n\n  // Allocate buffer\n  void* buffer;\n  hipMalloc(&buffer, buffer_size);\n\n  // Obtain number of total non-zero entries in C and row pointers of C\n  rocsparse_int nnz_C;\n  hipMalloc((void**)&csr_row_ptr_C, sizeof(rocsparse_int) * (m + 1));\n\n  rocsparse_csrgemm_nnz(handle,\n                        rocsparse_operation_none,\n                        rocsparse_operation_none,\n                        m,\n                        n,\n                        k,\n                        descr_A,\n                        nnz_A,\n                        csr_row_ptr_A,\n                        csr_col_ind_A,\n                        descr_B,\n                        nnz_B,\n                        csr_row_ptr_B,\n                        csr_col_ind_B,\n                        descr_D,\n                        nnz_D,\n                        csr_row_ptr_D,\n                        csr_col_ind_D,\n                        descr_C,\n                        csr_row_ptr_C,\n                        &nnz_C,\n                        info_C,\n                        buffer);\n\n  // Compute column indices and values of C\n  hipMalloc((void**)&csr_col_ind_C, sizeof(rocsparse_int) * nnz_C);\n  hipMalloc((void**)&csr_val_C, sizeof(float) * nnz_C);\n\n  rocsparse_scsrgemm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     m,\n                     n,\n                     k,\n                     &alpha,\n                     descr_A,\n                     nnz_A,\n                     csr_val_A,\n                     csr_row_ptr_A,\n                     csr_col_ind_A,\n                     descr_B,\n                     nnz_B,\n                     csr_val_B,\n                     csr_row_ptr_B,\n                     csr_col_ind_B,\n                     &beta,\n                     descr_D,\n                     nnz_D,\n                     csr_val_D,\n                     csr_row_ptr_D,\n                     csr_col_ind_D,\n                     descr_C,\n                     csr_val_C,\n                     csr_row_ptr_C,\n                     csr_col_ind_C,\n                     info_C,\n                     buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrgemm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f32,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f32,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const f32,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrgemm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f64,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f64,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const f64,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrgemm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_float_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_float_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const rocsparse_float_complex,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut rocsparse_float_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrgemm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_double_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_double_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const rocsparse_double_complex,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        csr_val_C: *mut rocsparse_double_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix symbolic multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgemm_symbolic multiplies two sparsity patterns and add an extra one: \\f[ opA \\cdot op(B) + D \\f]\n  with \\f$m \\times k\\f$ matrix \\f$A\\f$, defined in CSR storage format, the sparse\n  \\f$k \\times n\\f$ matrix \\f$B\\f$, defined in CSR storage format and the sparse \\f$m \\times n\\f$ matrix \\f$D\\f$.\n  The *  final result is stored in the sparse \\f$m \\times n\\f$ matrix \\f$C\\f$, defined in CSR\n  storage format, such\n  that\n  \\f[\n    C := op(A) \\cdot op(B) + D,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  It is assumed that \\p csr_row_ptr_C has already been filled and that and\n  \\p csr_col_ind_C is allocated by the user. \\p csr_row_ptr_C and allocation size of\n  \\p csr_col_ind_C is defined by the number of non-zero elements of\n  the sparse CSR matrix C. Both can be obtained by rocsparse_csrgemm_nnz(). The\n  required buffer size for the computation can be obtained by\n  rocsparse_scsrgemm_buffer_size(), rocsparse_dcsrgemm_buffer_size(),\n  rocsparse_ccsrgemm_buffer_size() and rocsparse_zcsrgemm_buffer_size(), respectively.\n\n  \\note Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\p trans_B == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n  \\note Please note, that for matrix products with more than 4096 non-zero entries per\n  row, additional temporary storage buffer is allocated by the algorithm.\n  \\note This function is blocking with respect to the host.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  k               number of columns of the sparse CSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse CSR matrix \\f$op(B)\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements (\\f$op(A) == A\\f$, \\p k+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p k+1 elements (\\f$op(B) == B\\f$, \\p m+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse CSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_D           number of non-zero entries of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_row_ptr_D   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_col_ind_D   array of \\p nnz_D elements containing the column indices of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_C           number of non-zero entries of the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  csr_col_ind_C   array of \\p nnz_C elements containing the column indices of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_scsrgemm_buffer_size(),\n                  rocsparse_dcsrgemm_buffer_size(), rocsparse_ccsrgemm_buffer_size() or\n                  rocsparse_zcsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz_A, \\p nnz_B or\n          \\p nnz_D is invalid.\n  \\retval rocsparse_status_invalid_pointer\n          \\p descr_A, \\p csr_row_ptr_A, \\p csr_col_ind_A, \\p descr_B,\n          \\p csr_row_ptr_B or \\p csr_col_ind_B, \\p descr_D, \\p csr_row_ptr_D, \\p csr_col_ind_D\n          \\p csr_row_ptr_C,\n          \\p csr_col_ind_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies symbolically two CSR matrices and adds the result to\n  another CSR matrix.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 2.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n  rocsparse_mat_descr descr_D;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n  rocsparse_create_mat_descr(&descr_D);\n\n  // Create matrix info structure\n  rocsparse_mat_info info_C;\n  rocsparse_create_mat_info(&info_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Query rocsparse for the required buffer size\n  size_t buffer_size;\n\n  rocsparse_scsrgemm_buffer_size(handle,\n                                 rocsparse_operation_none,\n                                 rocsparse_operation_none,\n                                 m,\n                                 n,\n                                 k,\n                                 &alpha,\n                                 descr_A,\n                                 nnz_A,\n                                 csr_row_ptr_A,\n                                 csr_col_ind_A,\n                                 descr_B,\n                                 nnz_B,\n                                 csr_row_ptr_B,\n                                 csr_col_ind_B,\n                                 &beta,\n                                 descr_D,\n                                 nnz_D,\n                                 csr_row_ptr_D,\n                                 csr_col_ind_D,\n                                 info_C,\n                                 &buffer_size);\n\n  // Allocate buffer\n  void* buffer;\n  hipMalloc(&buffer, buffer_size);\n\n  // Obtain number of total non-zero entries in C and row pointers of C\n  rocsparse_int nnz_C;\n  hipMalloc((void**)&csr_row_ptr_C, sizeof(rocsparse_int) * (m + 1));\n\n  rocsparse_csrgemm_nnz(handle,\n                        rocsparse_operation_none,\n                        rocsparse_operation_none,\n                        m,\n                        n,\n                        k,\n                        descr_A,\n                        nnz_A,\n                        csr_row_ptr_A,\n                        csr_col_ind_A,\n                        descr_B,\n                        nnz_B,\n                        csr_row_ptr_B,\n                        csr_col_ind_B,\n                        descr_D,\n                        nnz_D,\n                        csr_row_ptr_D,\n                        csr_col_ind_D,\n                        descr_C,\n                        csr_row_ptr_C,\n                        &nnz_C,\n                        info_C,\n                        buffer);\n\n  // Compute column indices of C\n  hipMalloc((void**)&csr_col_ind_C, sizeof(rocsparse_int) * nnz_C);\n\n  rocsparse_csrgemm_symbolic(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     m,\n                     n,\n                     k,\n                     descr_A,\n                     nnz_A,\n                     csr_row_ptr_A,\n                     csr_col_ind_A,\n                     descr_B,\n                     nnz_B,\n                     csr_row_ptr_B,\n                     csr_col_ind_B,\n                     descr_D,\n                     nnz_D,\n                     csr_row_ptr_D,\n                     csr_col_ind_D,\n                     descr_C,\n                     nnz_C,\n                     csr_row_ptr_C,\n                     csr_col_ind_C,\n                     info_C,\n                     buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_csrgemm_symbolic(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        nnz_C: rocsparse_int,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup extra_module\n  \\brief Sparse matrix sparse matrix numeric multiplication using CSR storage format\n\n  \\details\n  \\p rocsparse_csrgemm_numeric multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$m \\times k\\f$ matrix \\f$A\\f$, defined in CSR storage format, and the sparse\n  \\f$k \\times n\\f$ matrix \\f$B\\f$, defined in CSR storage format, and adds the result\n  to the sparse \\f$m \\times n\\f$ matrix \\f$D\\f$ that is multiplied by \\f$\\beta\\f$. The\n  final result is stored in the sparse \\f$m \\times n\\f$ matrix \\f$C\\f$, predefined in CSR\n  storage format, such\n  that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot D,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  The symbolic part of the csr matrix C can be obtained by rocsparse_csrgemm_symbolic().\n  It is assumed that \\p csr_row_ptr_C and \\p csr_col_ind_C have already been filled and that \\p csr_val_C is allocated by the user. \\p csr_row_ptr_C and allocation size of\n  \\p csr_col_ind_C and \\p csr_val_C is defined by the number of non-zero elements of\n  the sparse CSR matrix C. Both can be obtained by rocsparse_csrgemm_nnz(). The\n  required buffer size for the computation can be obtained by\n  rocsparse_scsrgemm_buffer_size(), rocsparse_dcsrgemm_buffer_size(),\n  rocsparse_ccsrgemm_buffer_size() and rocsparse_zcsrgemm_buffer_size(), respectively.\n\n  \\note If \\f$\\alpha == 0\\f$, then \\f$C = \\beta \\cdot D\\f$ will be computed.\n  \\note If \\f$\\beta == 0\\f$, then \\f$C = \\alpha \\cdot op(A) \\cdot op(B)\\f$ will be computed.\n  \\note \\f$\\alpha == beta == 0\\f$ is invalid.\n  \\note Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\p trans_B == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\ref rocsparse_matrix_type_general is supported.\n  \\note Please note, that for matrix products with more than 4096 non-zero entries per\n  row, additional temporary storage buffer is allocated by the algorithm.\n  \\note This function is blocking with respect to the host.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  trans_A         matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B         matrix \\f$B\\f$ operation type.\n  @param[in]\n  m               number of rows of the sparse CSR matrix \\f$op(A)\\f$ and \\f$C\\f$.\n  @param[in]\n  n               number of columns of the sparse CSR matrix \\f$op(B)\\f$ and\n                  \\f$C\\f$.\n  @param[in]\n  k               number of columns of the sparse CSR matrix \\f$op(A)\\f$ and number of\n                  rows of the sparse CSR matrix \\f$op(B)\\f$.\n  @param[in]\n  alpha           scalar \\f$\\alpha\\f$.\n  @param[in]\n  descr_A         descriptor of the sparse CSR matrix \\f$A\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_A           number of non-zero entries of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_val_A       array of \\p nnz_A elements of the sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  csr_row_ptr_A   array of \\p m+1 elements (\\f$op(A) == A\\f$, \\p k+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(A)\\f$.\n  @param[in]\n  csr_col_ind_A   array of \\p nnz_A elements containing the column indices of the\n                  sparse CSR matrix \\f$A\\f$.\n  @param[in]\n  descr_B         descriptor of the sparse CSR matrix \\f$B\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_B           number of non-zero entries of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_val_B       array of \\p nnz_B elements of the sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  csr_row_ptr_B   array of \\p k+1 elements (\\f$op(B) == B\\f$, \\p m+1 otherwise)\n                  that point to the start of every row of the sparse CSR matrix\n                  \\f$op(B)\\f$.\n  @param[in]\n  csr_col_ind_B   array of \\p nnz_B elements containing the column indices of the\n                  sparse CSR matrix \\f$B\\f$.\n  @param[in]\n  beta            scalar \\f$\\beta\\f$.\n  @param[in]\n  descr_D         descriptor of the sparse CSR matrix \\f$D\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_D           number of non-zero entries of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_val_D       array of \\p nnz_D elements of the sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_row_ptr_D   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  csr_col_ind_D   array of \\p nnz_D elements containing the column indices of the\n                  sparse CSR matrix \\f$D\\f$.\n  @param[in]\n  descr_C         descriptor of the sparse CSR matrix \\f$C\\f$. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  nnz_C           number of non-zero entries of the sparse CSR matrix \\f$C\\f$.\n  @param[out]\n  csr_val_C       array of \\p nnz_C elements of the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  csr_row_ptr_C   array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  csr_col_ind_C   array of \\p nnz_C elements containing the column indices of the\n                  sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  info_C          structure that holds meta data for the sparse CSR matrix \\f$C\\f$.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned\n                  by rocsparse_scsrgemm_buffer_size(),\n                  rocsparse_dcsrgemm_buffer_size(), rocsparse_ccsrgemm_buffer_size() or\n                  rocsparse_zcsrgemm_buffer_size().\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m, \\p n, \\p k, \\p nnz_A, \\p nnz_B or\n          \\p nnz_D is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p descr_A, \\p csr_val_A, \\p csr_row_ptr_A, \\p csr_col_ind_A, \\p descr_B,\n          \\p csr_val_B, \\p csr_row_ptr_B or \\p csr_col_ind_B are invalid if \\p alpha\n          is valid, \\p descr_D, \\p csr_val_D, \\p csr_row_ptr_D or \\p csr_col_ind_D is\n          invalid if \\p beta is valid, \\p csr_val_C, \\p csr_row_ptr_C,\n          \\p csr_col_ind_C, \\p info_C or \\p temp_buffer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none,\n          \\p trans_B != \\ref rocsparse_operation_none, or\n          \\p rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example multiplies two CSR matrices with a scalar alpha and adds the result to\n  another CSR matrix.\n  \\code{.c}\n  // Initialize scalar multipliers\n  float alpha = 2.0f;\n  float beta  = 1.0f;\n\n  // Create matrix descriptors\n  rocsparse_mat_descr descr_A;\n  rocsparse_mat_descr descr_B;\n  rocsparse_mat_descr descr_C;\n  rocsparse_mat_descr descr_D;\n\n  rocsparse_create_mat_descr(&descr_A);\n  rocsparse_create_mat_descr(&descr_B);\n  rocsparse_create_mat_descr(&descr_C);\n  rocsparse_create_mat_descr(&descr_D);\n\n  // Create matrix info structure\n  rocsparse_mat_info info_C;\n  rocsparse_create_mat_info(&info_C);\n\n  // Set pointer mode\n  rocsparse_set_pointer_mode(handle, rocsparse_pointer_mode_host);\n\n  // Query rocsparse for the required buffer size\n  size_t buffer_size;\n\n  rocsparse_scsrgemm_buffer_size(handle,\n                                 rocsparse_operation_none,\n                                 rocsparse_operation_none,\n                                 m,\n                                 n,\n                                 k,\n                                 &alpha,\n                                 descr_A,\n                                 nnz_A,\n                                 csr_row_ptr_A,\n                                 csr_col_ind_A,\n                                 descr_B,\n                                 nnz_B,\n                                 csr_row_ptr_B,\n                                 csr_col_ind_B,\n                                 &beta,\n                                 descr_D,\n                                 nnz_D,\n                                 csr_row_ptr_D,\n                                 csr_col_ind_D,\n                                 info_C,\n                                 &buffer_size);\n\n  // Allocate buffer\n  void* buffer;\n  hipMalloc(&buffer, buffer_size);\n\n  // Obtain number of total non-zero entries in C and row pointers of C\n  rocsparse_int nnz_C;\n  hipMalloc((void**)&csr_row_ptr_C, sizeof(rocsparse_int) * (m + 1));\n\n  rocsparse_csrgemm_nnz(handle,\n                        rocsparse_operation_none,\n                        rocsparse_operation_none,\n                        m,\n                        n,\n                        k,\n                        descr_A,\n                        nnz_A,\n                        csr_row_ptr_A,\n                        csr_col_ind_A,\n                        descr_B,\n                        nnz_B,\n                        csr_row_ptr_B,\n                        csr_col_ind_B,\n                        descr_D,\n                        nnz_D,\n                        csr_row_ptr_D,\n                        csr_col_ind_D,\n                        descr_C,\n                        csr_row_ptr_C,\n                        &nnz_C,\n                        info_C,\n                        buffer);\n\n  // Compute column indices and values of C\n  hipMalloc((void**)&csr_col_ind_C, sizeof(rocsparse_int) * nnz_C);\n  rocsparse_csrgemm_symbolic(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     m,\n                     n,\n                     k,\n                     descr_A,\n                     nnz_A,\n                     csr_row_ptr_A,\n                     csr_col_ind_A,\n                     descr_B,\n                     nnz_B,\n                     csr_row_ptr_B,\n                     csr_col_ind_B,\n                     descr_D,\n                     nnz_D,\n                     csr_row_ptr_D,\n                     csr_col_ind_D,\n                     descr_C,\n                     nnz_C,\n                     csr_row_ptr_C,\n                     csr_col_ind_C,\n                     info_C,\n                     buffer);\n  hipMalloc((void**)&csr_val_C, sizeof(float) * nnz_C);\n\n  rocsparse_scsrgemm_numeric(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     m,\n                     n,\n                     k,\n                     &alpha,\n                     descr_A,\n                     nnz_A,\n                     csr_val_A,\n                     csr_row_ptr_A,\n                     csr_col_ind_A,\n                     descr_B,\n                     nnz_B,\n                     csr_val_B,\n                     csr_row_ptr_B,\n                     csr_col_ind_B,\n                     &beta,\n                     descr_D,\n                     nnz_D,\n                     csr_val_D,\n                     csr_row_ptr_D,\n                     csr_col_ind_D,\n                     descr_C,\n                     nnz_C,\n                     csr_val_C,\n                     csr_row_ptr_C,\n                     csr_col_ind_C,\n                     info_C,\n                     buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrgemm_numeric(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f32,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f32,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f32,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const f32,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        nnz_C: rocsparse_int,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrgemm_numeric(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const f64,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const f64,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const f64,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const f64,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        nnz_C: rocsparse_int,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrgemm_numeric(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_float_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_float_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_float_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_float_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const rocsparse_float_complex,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        nnz_C: rocsparse_int,
        csr_val_C: *mut rocsparse_float_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrgemm_numeric(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        m: rocsparse_int,
        n: rocsparse_int,
        k: rocsparse_int,
        alpha: *const rocsparse_double_complex,
        descr_A: rocsparse_mat_descr,
        nnz_A: rocsparse_int,
        csr_val_A: *const rocsparse_double_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        descr_B: rocsparse_mat_descr,
        nnz_B: rocsparse_int,
        csr_val_B: *const rocsparse_double_complex,
        csr_row_ptr_B: *const rocsparse_int,
        csr_col_ind_B: *const rocsparse_int,
        beta: *const rocsparse_double_complex,
        descr_D: rocsparse_mat_descr,
        nnz_D: rocsparse_int,
        csr_val_D: *const rocsparse_double_complex,
        csr_row_ptr_D: *const rocsparse_int,
        csr_col_ind_D: *const rocsparse_int,
        descr_C: rocsparse_mat_descr,
        nnz_C: rocsparse_int,
        csr_val_C: *mut rocsparse_double_complex,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info_C: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR\n  storage format\n\n  \\details\n  \\p rocsparse_bsric0_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_sbsric0(),\n  rocsparse_dbsric0(), rocsparse_cbsric0() or rocsparse_zbsric0() computation.\n  The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position, using same\n  index base as the BSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note\n  If a zero pivot is found, \\p position=j means that either the diagonal block \\p A(j,j)\n  is missing (structural zero) or the diagonal block \\p A(j,j) is not positive definite\n  (numerical zero).\n\n  \\note \\p rocsparse_bsric0_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_bsric0_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR\n  storage format\n\n  \\details\n  \\p rocsparse_bsric0_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(),\n  rocsparse_cbsric0_analysis(), rocsparse_zbsric0_analysis(), rocsparse_sbsric0(),\n  rocsparse_dbsric0(), rocsparse_sbsric0() and rocsparse_dbsric0(). The temporary\n  storage buffer must be allocated by the user. The size of the temporary storage\n  buffer is identical to the size returned by rocsparse_sbsrsv_buffer_size(),\n  rocsparse_dbsrsv_buffer_size(), rocsparse_cbsrsv_buffer_size(), rocsparse_zbsrsv_buffer_size(),\n  rocsparse_sbsrilu0_buffer_size(), rocsparse_dbsrilu0_buffer_size(), rocsparse_cbsrilu0_buffer_size()\n  and rocsparse_zbsrilu0_buffer_size() if the matrix sparsity pattern is identical. The user\n  allocated buffer can thus be shared between subsequent calls to those functions.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(),\n              rocsparse_cbsric0_analysis(), rocsparse_zbsric0_analysis(),\n              rocsparse_sbsric0(), rocsparse_dbsric0(), rocsparse_cbsric0()\n              and rocsparse_zbsric0().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsric0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsric0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsric0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsric0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR\n  storage format\n\n  \\details\n  \\p rocsparse_bsric0_analysis performs the analysis step for rocsparse_sbsric0()\n  rocsparse_dbsric0(), rocsparse_cbsric0(), and rocsparse_zbsric0(). It is expected\n  that this function will be executed only once for a given matrix and particular\n  operation type. The analysis meta data can be cleared by rocsparse_bsric0_clear().\n\n  \\p rocsparse_bsric0_analysis can share its meta data with\n  rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(),\n  rocsparse_cbsrilu0_analysis(), rocsparse_zbsrilu0_analysis(),\n  rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(),\n  rocsparse_cbsrsv_analysis(), rocsparse_zbsrsv_analysis(),\n  rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(),\n  rocsparse_cbsrsm_analysis() and rocsparse_zbsrsm_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsric0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsric0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsric0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsric0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR\n  storage format\n\n  \\details\n  \\p rocsparse_bsric0_clear deallocates all memory that was allocated by\n  rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(), rocsparse_cbsric0_analysis()\n  or rocsparse_zbsric0_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation.\n\n  \\note\n  Calling \\p rocsparse_bsric0_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_bsric0_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using BSR\n  storage format\n\n  \\details\n  \\p rocsparse_bsric0 computes the incomplete Cholesky factorization with 0 fill-ins\n  and no pivoting of a sparse \\f$mb \\times mb\\f$ BSR matrix \\f$A\\f$, such that\n  \\f[\n    A \\approx LL^T\n  \\f]\n\n  \\p rocsparse_bsric0 requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_sbsric0_buffer_size(), rocsparse_dbsric0_buffer_size(),\n  rocsparse_cbsric0_buffer_size() or rocsparse_zbsric0_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_sbsric0_analysis(),\n  rocsparse_dbsric0_analysis(), rocsparse_cbsric0_analysis() or rocsparse_zbsric0_analysis().\n  \\p rocsparse_bsric0 reports the first zero pivot (either numerical or structural zero).\n  The zero pivot status can be obtained by calling rocsparse_bsric0_zero_pivot().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir             direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[inout]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr\n              or \\p bsr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the sparse \\f$m \\times m\\f$ matrix \\f$A\\f$, stored in BSR\n  storage format. The following example computes the incomplete Cholesky factorization\n  \\f$M \\approx LL^T\\f$ and solves the preconditioned system \\f$My = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor for M\n      rocsparse_mat_descr descr_M;\n      rocsparse_create_mat_descr(&descr_M);\n\n      // Create matrix descriptor for L\n      rocsparse_mat_descr descr_L;\n      rocsparse_create_mat_descr(&descr_L);\n      rocsparse_set_mat_fill_mode(descr_L, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr_L, rocsparse_diag_type_unit);\n\n      // Create matrix descriptor for L'\n      rocsparse_mat_descr descr_Lt;\n      rocsparse_create_mat_descr(&descr_Lt);\n      rocsparse_set_mat_fill_mode(descr_Lt, rocsparse_fill_mode_upper);\n      rocsparse_set_mat_diag_type(descr_Lt, rocsparse_diag_type_non_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size_M;\n      size_t buffer_size_L;\n      size_t buffer_size_Lt;\n      rocsparse_dbsric0_buffer_size(handle,\n                                     rocsparse_direction_row,\n                                     mb,\n                                     nnzb,\n                                     descr_M,\n                                     bsr_val,\n                                     bsr_row_ptr,\n                                     bsr_col_ind,\n                                     block_dim,\n                                     info,\n                                     &buffer_size_M);\n      rocsparse_dbsrsv_buffer_size(handle,\n                                   rocsparse_direction_row,\n                                   rocsparse_operation_none,\n                                   mb,\n                                   nnzb,\n                                   descr_L,\n                                   bsr_val,\n                                   bsr_row_ptr,\n                                   bsr_col_ind,\n                                   block_dim,\n                                   info,\n                                   &buffer_size_L);\n      rocsparse_dbsrsv_buffer_size(handle,\n                                   rocsparse_direction_row,\n                                   rocsparse_operation_transpose,\n                                   mb,\n                                   nnzb,\n                                   descr_Lt,\n                                   bsr_val,\n                                   bsr_row_ptr,\n                                   bsr_col_ind,\n                                   block_dim,\n                                   info,\n                                   &buffer_size_Lt);\n\n      size_t buffer_size = max(buffer_size_M, max(buffer_size_L, buffer_size_Lt));\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis steps, using rocsparse_analysis_policy_reuse to improve\n      // computation performance\n      rocsparse_dbsric0_analysis(handle,\n                                  rocsparse_direction_row,\n                                  mb,\n                                  nnzb,\n                                  descr_M,\n                                  bsr_val,\n                                  bsr_row_ptr,\n                                  bsr_col_ind,\n                                  block_dim,\n                                  info,\n                                  rocsparse_analysis_policy_reuse,\n                                  rocsparse_solve_policy_auto,\n                                  temp_buffer);\n      rocsparse_dbsrsv_analysis(handle,\n                                rocsparse_direction_row,\n                                rocsparse_operation_none,\n                                mb,\n                                nnzb,\n                                descr_L,\n                                bsr_val,\n                                bsr_row_ptr,\n                                bsr_col_ind,\n                                block_dim,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n      rocsparse_dbsrsv_analysis(handle,\n                                rocsparse_direction_row,\n                                rocsparse_operation_transpose,\n                                mb,\n                                nnzb,\n                                descr_Lt,\n                                bsr_val,\n                                bsr_row_ptr,\n                                bsr_col_ind,\n                                block_dim,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Check for zero pivot\n      rocsparse_int position;\n      if(rocsparse_status_zero_pivot == rocsparse_bsric0_zero_pivot(handle,\n                                                                    info,\n                                                                    &position))\n      {\n          printf(\"A has structural zero at A(%d,%d)\\n\", position, position);\n      }\n\n      // Compute incomplete Cholesky factorization M = LL'\n      rocsparse_dbsric0(handle,\n                         rocsparse_direction_row,\n                         mb,\n                         nnzb,\n                         descr_M,\n                         bsr_val,\n                         bsr_row_ptr,\n                         bsr_col_ind,\n                         block_dim,\n                         info,\n                         rocsparse_solve_policy_auto,\n                         temp_buffer);\n\n      // Check for zero pivot\n      if(rocsparse_status_zero_pivot == rocsparse_bsric0_zero_pivot(handle,\n                                                                     info,\n                                                                     &position))\n      {\n          printf(\"L has structural and/or numerical zero at L(%d,%d)\\n\",\n                 position,\n                 position);\n      }\n\n      // Solve Lz = x\n      rocsparse_dbsrsv_solve(handle,\n                             rocsparse_direction_row,\n                             rocsparse_operation_none,\n                             mb,\n                             nnzb,\n                             &alpha,\n                             descr_L,\n                             bsr_val,\n                             bsr_row_ptr,\n                             bsr_col_ind,\n                             block_dim,\n                             info,\n                             x,\n                             z,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Solve L'y = z\n      rocsparse_dbsrsv_solve(handle,\n                             rocsparse_direction_row,\n                             rocsparse_operation_transpose,\n                             mb,\n                             nnzb,\n                             &alpha,\n                             descr_Lt,\n                             bsr_val,\n                             bsr_row_ptr,\n                             bsr_col_ind,\n                             block_dim,\n                             info,\n                             z,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr_M);\n      rocsparse_destroy_mat_descr(descr_L);\n      rocsparse_destroy_mat_descr(descr_Lt);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsric0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsric0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsric0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsric0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_sbsrilu0(),\n  rocsparse_dbsrilu0(), rocsparse_cbsrilu0() or rocsparse_zbsrilu0() computation.\n  The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position, using same\n  index base as the BSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note\n  If a zero pivot is found, \\p position \\f$=j\\f$ means that either the diagonal block\n  \\f$A_{j,j}\\f$ is missing (structural zero) or the diagonal block \\f$A_{j,j}\\f$ is not\n  invertible (numerical zero).\n\n  \\note \\p rocsparse_bsrilu0_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_bsrilu0_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0_numeric_boost enables the user to replace a numerical value in\n  an incomplete LU factorization. \\p tol is used to determine whether a numerical value\n  is replaced by \\p boost_val, such that \\f$A_{j,j} = \\text{boost_val}\\f$ if\n  \\f$\\text{tol} \\ge \\left|A_{j,j}\\right|\\f$.\n\n  \\note The boost value is enabled by setting \\p enable_boost to 1 or disabled by\n  setting \\p enable_boost to 0.\n\n  \\note \\p tol and \\p boost_val can be in host or device memory.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  info            structure that holds the information collected during the analysis step.\n  @param[in]\n  enable_boost    enable/disable numeric boost.\n  @param[in]\n  boost_tol       tolerance to determine whether a numerical value is replaced or not.\n  @param[in]\n  boost_val       boost value to replace a numerical value.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info, \\p tol or \\p boost_val pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f32,
        boost_val: *const f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f32,
        boost_val: *const rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dsbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcbsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(),\n  rocsparse_cbsrilu0_analysis(), rocsparse_zbsrilu0_analysis(), rocsparse_sbsrilu0(),\n  rocsparse_dbsrilu0(), rocsparse_sbsrilu0() and rocsparse_dbsrilu0(). The temporary\n  storage buffer must be allocated by the user. The size of the temporary storage\n  buffer is identical to the size returned by rocsparse_sbsrsv_buffer_size(),\n  rocsparse_dbsrsv_buffer_size(), rocsparse_cbsrsv_buffer_size(), rocsparse_zbsrsv_buffer_size(),\n  rocsparse_sbsric0_buffer_size(), rocsparse_dbsric0_buffer_size(), rocsparse_cbsric0_buffer_size()\n  and rocsparse_zbsric0_buffer_size() if the matrix sparsity pattern is identical. The user\n  allocated buffer can thus be shared between subsequent calls to those functions.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         direction that specifies whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(),\n              rocsparse_cbsrilu0_analysis(), rocsparse_zbsrilu0_analysis(),\n              rocsparse_sbsrilu0(), rocsparse_dbsrilu0(), rocsparse_cbsrilu0()\n              and rocsparse_zbsrilu0().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrilu0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrilu0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrilu0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrilu0_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0_analysis performs the analysis step for rocsparse_sbsrilu0()\n  rocsparse_dbsrilu0(), rocsparse_cbsrilu0(), and rocsparse_zbsrilu0(). It is expected\n  that this function will be executed only once for a given matrix. The analysis meta\n  data can be cleared by rocsparse_bsrilu0_clear().\n\n  \\p rocsparse_bsrilu0_analysis can share its meta data with\n  rocsparse_sbsric0_analysis(), rocsparse_dbsric0_analysis(),\n  rocsparse_cbsric0_analysis(), rocsparse_zbsric0_analysis(),\n  rocsparse_sbsrsv_analysis(), rocsparse_dbsrsv_analysis(),\n  rocsparse_cbsrsv_analysis(), rocsparse_zbsrsv_analysis(),\n  rocsparse_sbsrsm_analysis(), rocsparse_dbsrsm_analysis(),\n  rocsparse_cbsrsm_analysis() and rocsparse_zbsrsm_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         direction that specified whether to count nonzero elements by\n              \\ref rocsparse_direction_row or by \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[in]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_sbsrilu0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrilu0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrilu0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrilu0_analysis(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0_clear deallocates all memory that was allocated by\n  rocsparse_sbsrilu0_analysis(), rocsparse_dbsrilu0_analysis(), rocsparse_cbsrilu0_analysis()\n  or rocsparse_zbsrilu0_analysis(). This is especially useful, if memory is an issue and\n  the analysis data is not required for further computation.\n\n  \\note\n  Calling \\p rocsparse_bsrilu0_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_bsrilu0_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using BSR storage\n  format\n\n  \\details\n  \\p rocsparse_bsrilu0 computes the incomplete LU factorization with 0 fill-ins and no\n  pivoting of a sparse \\f$mb \\times mb\\f$ BSR matrix \\f$A\\f$, such that\n  \\f[\n    A \\approx LU\n  \\f]\n\n  \\p rocsparse_bsrilu0 requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_sbsrilu0_buffer_size(), rocsparse_dbsrilu0_buffer_size(),\n  rocsparse_cbsrilu0_buffer_size() or rocsparse_zbsrilu0_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_sbsrilu0_analysis(),\n  rocsparse_dbsrilu0_analysis(), rocsparse_cbsrilu0_analysis() or\n  rocsparse_zbsrilu0_analysis(). \\p rocsparse_bsrilu0 reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be obtained by\n  calling rocsparse_bsrilu0_zero_pivot().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         direction that specified whether to count nonzero elements by\n              \\ref rocsparse_direction_row or by \\ref rocsparse_direction_row.\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero block entries of the sparse BSR matrix.\n  @param[in]\n  descr       descriptor of the sparse BSR matrix.\n  @param[inout]\n  bsr_val     array of length \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and m where \\p m=mb*block_dim.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nnzb, or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p bsr_val, \\p bsr_row_ptr\n              or \\p bsr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the sparse \\f$m \\times m\\f$ matrix \\f$A\\f$, stored in BSR\n  storage format. The following example computes the incomplete LU factorization\n  \\f$M \\approx LU\\f$ and solves the preconditioned system \\f$My = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor for M\n      rocsparse_mat_descr descr_M;\n      rocsparse_create_mat_descr(&descr_M);\n\n      // Create matrix descriptor for L\n      rocsparse_mat_descr descr_L;\n      rocsparse_create_mat_descr(&descr_L);\n      rocsparse_set_mat_fill_mode(descr_L, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr_L, rocsparse_diag_type_unit);\n\n      // Create matrix descriptor for U\n      rocsparse_mat_descr descr_U;\n      rocsparse_create_mat_descr(&descr_U);\n      rocsparse_set_mat_fill_mode(descr_U, rocsparse_fill_mode_upper);\n      rocsparse_set_mat_diag_type(descr_U, rocsparse_diag_type_non_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size_M;\n      size_t buffer_size_L;\n      size_t buffer_size_U;\n      rocsparse_dbsrilu0_buffer_size(handle,\n                                     rocsparse_direction_row,\n                                     mb,\n                                     nnzb,\n                                     descr_M,\n                                     bsr_val,\n                                     bsr_row_ptr,\n                                     bsr_col_ind,\n                                     block_dim,\n                                     info,\n                                     &buffer_size_M);\n      rocsparse_dbsrsv_buffer_size(handle,\n                                   rocsparse_direction_row,\n                                   rocsparse_operation_none,\n                                   mb,\n                                   nnzb,\n                                   descr_L,\n                                   bsr_val,\n                                   bsr_row_ptr,\n                                   bsr_col_ind,\n                                   block_dim,\n                                   info,\n                                   &buffer_size_L);\n      rocsparse_dbsrsv_buffer_size(handle,\n                                   rocsparse_direction_row,\n                                   rocsparse_operation_none,\n                                   mb,\n                                   nnzb,\n                                   descr_U,\n                                   bsr_val,\n                                   bsr_row_ptr,\n                                   bsr_col_ind,\n                                   block_dim,\n                                   info,\n                                   &buffer_size_U);\n\n      size_t buffer_size = max(buffer_size_M, max(buffer_size_L, buffer_size_U));\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis steps, using rocsparse_analysis_policy_reuse to improve\n      // computation performance\n      rocsparse_dbsrilu0_analysis(handle,\n                                  rocsparse_direction_row,\n                                  mb,\n                                  nnzb,\n                                  descr_M,\n                                  bsr_val,\n                                  bsr_row_ptr,\n                                  bsr_col_ind,\n                                  block_dim,\n                                  info,\n                                  rocsparse_analysis_policy_reuse,\n                                  rocsparse_solve_policy_auto,\n                                  temp_buffer);\n      rocsparse_dbsrsv_analysis(handle,\n                                rocsparse_direction_row,\n                                rocsparse_operation_none,\n                                mb,\n                                nnzb,\n                                descr_L,\n                                bsr_val,\n                                bsr_row_ptr,\n                                bsr_col_ind,\n                                block_dim,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n      rocsparse_dbsrsv_analysis(handle,\n                                rocsparse_direction_row,\n                                rocsparse_operation_none,\n                                mb,\n                                nnzb,\n                                descr_U,\n                                bsr_val,\n                                bsr_row_ptr,\n                                bsr_col_ind,\n                                block_dim,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Check for zero pivot\n      rocsparse_int position;\n      if(rocsparse_status_zero_pivot == rocsparse_bsrilu0_zero_pivot(handle,\n                                                                    info,\n                                                                    &position))\n      {\n          printf(\"A has structural zero at A(%d,%d)\\n\", position, position);\n      }\n\n      // Compute incomplete LU factorization M = LU\n      rocsparse_dbsrilu0(handle,\n                         rocsparse_direction_row,\n                         mb,\n                         nnzb,\n                         descr_M,\n                         bsr_val,\n                         bsr_row_ptr,\n                         bsr_col_ind,\n                         block_dim,\n                         info,\n                         rocsparse_solve_policy_auto,\n                         temp_buffer);\n\n      // Check for zero pivot\n      if(rocsparse_status_zero_pivot == rocsparse_bsrilu0_zero_pivot(handle,\n                                                                     info,\n                                                                     &position))\n      {\n          printf(\"L has structural and/or numerical zero at L(%d,%d)\\n\",\n                 position,\n                 position);\n      }\n\n      // Solve Lz = x\n      rocsparse_dbsrsv_solve(handle,\n                             rocsparse_direction_row,\n                             rocsparse_operation_none,\n                             mb,\n                             nnzb,\n                             &alpha,\n                             descr_L,\n                             bsr_val,\n                             bsr_row_ptr,\n                             bsr_col_ind,\n                             block_dim,\n                             info,\n                             x,\n                             z,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Solve Uy = z\n      rocsparse_dbsrsv_solve(handle,\n                             rocsparse_direction_row,\n                             rocsparse_operation_none,\n                             mb,\n                             nnzb,\n                             &alpha,\n                             descr_U,\n                             bsr_val,\n                             bsr_row_ptr,\n                             bsr_col_ind,\n                             block_dim,\n                             info,\n                             z,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr_M);\n      rocsparse_destroy_mat_descr(descr_L);\n      rocsparse_destroy_mat_descr(descr_U);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsrilu0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrilu0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrilu0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrilu0(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csric_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_scsric0() or\n  rocsparse_dcsric0() computation. The first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$\n  is stored in \\p position, using same index base as the CSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_csric0_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_csric0_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csric0_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_scsric0_analysis(), rocsparse_dcsric0_analysis(),\n  rocsparse_scsric0() and rocsparse_dcsric0(). The temporary storage buffer must\n  be allocated by the user. The size of the temporary storage buffer is identical to\n  the size returned by rocsparse_scsrsv_buffer_size(), rocsparse_dcsrsv_buffer_size(),\n  rocsparse_scsrilu0_buffer_size() and rocsparse_dcsrilu0_buffer_size() if the matrix\n  sparsity pattern is identical. The user allocated buffer can thus be shared between\n  subsequent calls to those functions.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsric0_analysis(), rocsparse_dcsric0_analysis(),\n              rocsparse_scsric0() and rocsparse_dcsric0().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsric0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsric0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsric0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsric0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csric0_analysis performs the analysis step for rocsparse_scsric0()\n  and rocsparse_dcsric0(). It is expected that this function will be executed only\n  once for a given matrix and particular operation type. The analysis meta data can be\n  cleared by rocsparse_csric0_clear().\n\n  \\p rocsparse_csric0_analysis can share its meta data with\n  rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n  rocsparse_ccsrilu0_analysis(), rocsparse_zcsrilu0_analysis(),\n  rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(),\n  rocsparse_ccsrsv_analysis(), rocsparse_zcsrsv_analysis(),\n  rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(),\n  rocsparse_scsrsm_analysis() and rocsparse_dcsrsm_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsric0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsric0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsric0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsric0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csric0_clear deallocates all memory that was allocated by\n  rocsparse_scsric0_analysis() or rocsparse_dcsric0_analysis(). This is especially\n  useful, if memory is an issue and the analysis data is not required for further\n  computation.\n\n  \\note\n  Calling \\p rocsparse_csric0_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csric0_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete Cholesky factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csric0 computes the incomplete Cholesky factorization with 0 fill-ins\n  and no pivoting of a sparse \\f$m \\times m\\f$ CSR matrix \\f$A\\f$, such that\n  \\f[\n    A \\approx LL^T\n  \\f]\n\n  \\p rocsparse_csric0 requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_scsric0_buffer_size() or rocsparse_dcsric0_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_scsric0_analysis()\n  or rocsparse_dcsric0_analysis(). \\p rocsparse_csric0 reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be obtained by\n  calling rocsparse_csric0_zero_pivot().\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[inout]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr\n              or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the sparse \\f$m \\times m\\f$ matrix \\f$A\\f$, stored in CSR\n  storage format. The following example computes the incomplete Cholesky factorization\n  \\f$M \\approx LL^T\\f$ and solves the preconditioned system \\f$My = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor for M\n      rocsparse_mat_descr descr_M;\n      rocsparse_create_mat_descr(&descr_M);\n\n      // Create matrix descriptor for L\n      rocsparse_mat_descr descr_L;\n      rocsparse_create_mat_descr(&descr_L);\n      rocsparse_set_mat_fill_mode(descr_L, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr_L, rocsparse_diag_type_unit);\n\n      // Create matrix descriptor for L'\n      rocsparse_mat_descr descr_Lt;\n      rocsparse_create_mat_descr(&descr_Lt);\n      rocsparse_set_mat_fill_mode(descr_Lt, rocsparse_fill_mode_upper);\n      rocsparse_set_mat_diag_type(descr_Lt, rocsparse_diag_type_non_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size_M;\n      size_t buffer_size_L;\n      size_t buffer_size_Lt;\n      rocsparse_dcsric0_buffer_size(handle,\n                                    m,\n                                    nnz,\n                                    descr_M,\n                                    csr_val,\n                                    csr_row_ptr,\n                                    csr_col_ind,\n                                    info,\n                                    &buffer_size_M);\n      rocsparse_dcsrsv_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nnz,\n                                   descr_L,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size_L);\n      rocsparse_dcsrsv_buffer_size(handle,\n                                   rocsparse_operation_transpose,\n                                   m,\n                                   nnz,\n                                   descr_Lt,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size_Lt);\n\n      size_t buffer_size = max(buffer_size_M, max(buffer_size_L, buffer_size_Lt));\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis steps, using rocsparse_analysis_policy_reuse to improve\n      // computation performance\n      rocsparse_dcsric0_analysis(handle,\n                                 m,\n                                 nnz,\n                                 descr_M,\n                                 csr_val,\n                                 csr_row_ptr,\n                                 csr_col_ind,\n                                 info,\n                                 rocsparse_analysis_policy_reuse,\n                                 rocsparse_solve_policy_auto,\n                                 temp_buffer);\n      rocsparse_dcsrsv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                nnz,\n                                descr_L,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n      rocsparse_dcsrsv_analysis(handle,\n                                rocsparse_operation_transpose,\n                                m,\n                                nnz,\n                                descr_Lt,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Check for zero pivot\n      rocsparse_int position;\n      if(rocsparse_status_zero_pivot == rocsparse_csric0_zero_pivot(handle,\n                                                                    info,\n                                                                    &position))\n      {\n          printf(\"A has structural zero at A(%d,%d)\\n\", position, position);\n      }\n\n      // Compute incomplete Cholesky factorization M = LL'\n      rocsparse_dcsric0(handle,\n                        m,\n                        nnz,\n                        descr_M,\n                        csr_val,\n                        csr_row_ptr,\n                        csr_col_ind,\n                        info,\n                        rocsparse_solve_policy_auto,\n                        temp_buffer);\n\n      // Check for zero pivot\n      if(rocsparse_status_zero_pivot == rocsparse_csric0_zero_pivot(handle,\n                                                                    info,\n                                                                    &position))\n      {\n          printf(\"L has structural and/or numerical zero at L(%d,%d)\\n\",\n                 position,\n                 position);\n      }\n\n      // Solve Lz = x\n      rocsparse_dcsrsv_solve(handle,\n                             rocsparse_operation_none,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr_L,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             x,\n                             z,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Solve L'y = z\n      rocsparse_dcsrsv_solve(handle,\n                             rocsparse_operation_transpose,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr_Lt,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             z,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr_M);\n      rocsparse_destroy_mat_descr(descr_L);\n      rocsparse_destroy_mat_descr(descr_Lt);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsric0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsric0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsric0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsric0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csrilu0_zero_pivot returns \\ref rocsparse_status_zero_pivot, if either a\n  structural or numerical zero has been found during rocsparse_scsrilu0(),\n  rocsparse_dcsrilu0(), rocsparse_ccsrilu0() or rocsparse_zcsrilu0() computation. The\n  first zero pivot \\f$j\\f$ at \\f$A_{j,j}\\f$ is stored in \\p position, using same index\n  base as the CSR matrix.\n\n  \\p position can be in host or device memory. If no zero pivot has been found,\n  \\p position is set to -1 and \\ref rocsparse_status_success is returned instead.\n\n  \\note \\p rocsparse_csrilu0_zero_pivot is a blocking function. It might influence\n  performance negatively.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[inout]\n  position    pointer to zero pivot \\f$j\\f$, can be in host or device memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info or \\p position pointer is\n              invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot zero pivot has been found."]
    pub fn rocsparse_csrilu0_zero_pivot(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        position: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR storage\n  format\n\n  \\details\n  \\p rocsparse_csrilu0_numeric_boost enables the user to replace a numerical value in\n  an incomplete LU factorization. \\p tol is used to determine whether a numerical value\n  is replaced by \\p boost_val, such that \\f$A_{j,j} = \\text{boost_val}\\f$ if\n  \\f$\\text{tol} \\ge \\left|A_{j,j}\\right|\\f$.\n\n  \\note The boost value is enabled by setting \\p enable_boost to 1 or disabled by\n  setting \\p enable_boost to 0.\n\n  \\note \\p tol and \\p boost_val can be in host or device memory.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  info            structure that holds the information collected during the analysis step.\n  @param[in]\n  enable_boost    enable/disable numeric boost.\n  @param[in]\n  boost_tol       tolerance to determine whether a numerical value is replaced or not.\n  @param[in]\n  boost_val       boost value to replace a numerical value.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info, \\p tol or \\p boost_val pointer\n              is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_scsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f32,
        boost_val: *const f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f32,
        boost_val: *const rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dscsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dccsrilu0_numeric_boost(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
        enable_boost: ::std::os::raw::c_int,
        boost_tol: *const f64,
        boost_val: *const rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csrilu0_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n  rocsparse_ccsrilu0_analysis(), rocsparse_zcsrilu0_analysis(), rocsparse_scsrilu0(),\n  rocsparse_dcsrilu0(), rocsparse_ccsrilu0() and rocsparse_zcsrilu0(). The temporary\n  storage buffer must be allocated by the user. The size of the temporary storage\n  buffer is identical to the size returned by rocsparse_scsrsv_buffer_size(),\n  rocsparse_dcsrsv_buffer_size(), rocsparse_ccsrsv_buffer_size() and\n  rocsparse_zcsrsv_buffer_size() if the matrix sparsity pattern is identical. The user\n  allocated buffer can thus be shared between subsequent calls to those functions.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during the analysis step.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n              rocsparse_ccsrilu0_analysis(), rocsparse_zcsrilu0_analysis(),\n              rocsparse_scsrilu0(), rocsparse_dcsrilu0(), rocsparse_ccsrilu0() and\n              rocsparse_zcsrilu0().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrilu0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrilu0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrilu0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrilu0_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csrilu0_analysis performs the analysis step for rocsparse_scsrilu0(),\n  rocsparse_dcsrilu0(), rocsparse_ccsrilu0() and rocsparse_zcsrilu0(). It is expected\n  that this function will be executed only once for a given matrix and particular\n  operation type. The analysis meta data can be cleared by rocsparse_csrilu0_clear().\n\n  \\p rocsparse_csrilu0_analysis can share its meta data with\n  rocsparse_scsric0_analysis(), rocsparse_dcsric0_analysis(),\n  rocsparse_ccsric0_analysis(), rocsparse_zcsric0_analysis(),\n  rocsparse_scsrsv_analysis(), rocsparse_dcsrsv_analysis(),\n  rocsparse_ccsrsv_analysis(), rocsparse_zcsrsv_analysis(),\n  rocsparse_scsrsm_analysis(), rocsparse_dcsrsm_analysis(),\n  rocsparse_scsrsm_analysis() and rocsparse_dcsrsm_analysis(). Selecting\n  \\ref rocsparse_analysis_policy_reuse policy can greatly improve computation\n  performance of meta data. However, the user need to make sure that the sparsity\n  pattern remains unchanged. If this cannot be assured,\n  \\ref rocsparse_analysis_policy_force has to be used.\n\n  \\note\n  If the matrix sparsity pattern changes, the gathered information will become invalid.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  info        structure that holds the information collected during\n              the analysis step.\n  @param[in]\n  analysis    \\ref rocsparse_analysis_policy_reuse or\n              \\ref rocsparse_analysis_policy_force.\n  @param[in]\n  solve       \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p info or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n/\n/**@{"]
    pub fn rocsparse_scsrilu0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrilu0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrilu0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrilu0_analysis(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        analysis: rocsparse_analysis_policy,
        solve: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csrilu0_clear deallocates all memory that was allocated by\n  rocsparse_scsrilu0_analysis(), rocsparse_dcsrilu0_analysis(),\n  rocsparse_ccsrilu0_analysis() or rocsparse_zcsrilu0_analysis(). This is especially\n  useful, if memory is an issue and the analysis data is not required for further\n  computation.\n\n  \\note\n  Calling \\p rocsparse_csrilu0_clear is optional. All allocated resources will be\n  cleared, when the opaque \\ref rocsparse_mat_info struct is destroyed using\n  rocsparse_destroy_mat_info().\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[inout]\n  info        structure that holds the information collected during the analysis step.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p info pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer holding the meta data could not\n              be deallocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csrilu0_clear(
        handle: rocsparse_handle,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format\n\n  \\details\n  \\p rocsparse_csrilu0 computes the incomplete LU factorization with 0 fill-ins and no\n  pivoting of a sparse \\f$m \\times m\\f$ CSR matrix \\f$A\\f$, such that\n  \\f[\n    A \\approx LU\n  \\f]\n\n  \\p rocsparse_csrilu0 requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_scsrilu0_buffer_size(), rocsparse_dcsrilu0_buffer_size(),\n  rocsparse_ccsrilu0_buffer_size() or rocsparse_zcsrilu0_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_scsrilu0_analysis(),\n  rocsparse_dcsrilu0_analysis(), rocsparse_ccsrilu0_analysis() or\n  rocsparse_zcsrilu0_analysis(). \\p rocsparse_csrilu0 reports the first zero pivot\n  (either numerical or structural zero). The zero pivot status can be obtained by\n  calling rocsparse_csrilu0_zero_pivot().\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr       descriptor of the sparse CSR matrix.\n  @param[inout]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  info        structure that holds the information collected during the analysis step.\n  @param[in]\n  policy      \\ref rocsparse_solve_policy_auto.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr\n              or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\p trans != \\ref rocsparse_operation_none or\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  Consider the sparse \\f$m \\times m\\f$ matrix \\f$A\\f$, stored in CSR\n  storage format. The following example computes the incomplete LU factorization\n  \\f$M \\approx LU\\f$ and solves the preconditioned system \\f$My = x\\f$.\n  \\code{.c}\n      // Create rocSPARSE handle\n      rocsparse_handle handle;\n      rocsparse_create_handle(&handle);\n\n      // Create matrix descriptor for M\n      rocsparse_mat_descr descr_M;\n      rocsparse_create_mat_descr(&descr_M);\n\n      // Create matrix descriptor for L\n      rocsparse_mat_descr descr_L;\n      rocsparse_create_mat_descr(&descr_L);\n      rocsparse_set_mat_fill_mode(descr_L, rocsparse_fill_mode_lower);\n      rocsparse_set_mat_diag_type(descr_L, rocsparse_diag_type_unit);\n\n      // Create matrix descriptor for U\n      rocsparse_mat_descr descr_U;\n      rocsparse_create_mat_descr(&descr_U);\n      rocsparse_set_mat_fill_mode(descr_U, rocsparse_fill_mode_upper);\n      rocsparse_set_mat_diag_type(descr_U, rocsparse_diag_type_non_unit);\n\n      // Create matrix info structure\n      rocsparse_mat_info info;\n      rocsparse_create_mat_info(&info);\n\n      // Obtain required buffer size\n      size_t buffer_size_M;\n      size_t buffer_size_L;\n      size_t buffer_size_U;\n      rocsparse_dcsrilu0_buffer_size(handle,\n                                    m,\n                                    nnz,\n                                    descr_M,\n                                    csr_val,\n                                    csr_row_ptr,\n                                    csr_col_ind,\n                                    info,\n                                    &buffer_size_M);\n      rocsparse_dcsrsv_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nnz,\n                                   descr_L,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size_L);\n      rocsparse_dcsrsv_buffer_size(handle,\n                                   rocsparse_operation_none,\n                                   m,\n                                   nnz,\n                                   descr_U,\n                                   csr_val,\n                                   csr_row_ptr,\n                                   csr_col_ind,\n                                   info,\n                                   &buffer_size_U);\n\n      size_t buffer_size = max(buffer_size_M, max(buffer_size_L, buffer_size_U));\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Perform analysis steps, using rocsparse_analysis_policy_reuse to improve\n      // computation performance\n      rocsparse_dcsrilu0_analysis(handle,\n                                  m,\n                                  nnz,\n                                  descr_M,\n                                  csr_val,\n                                  csr_row_ptr,\n                                  csr_col_ind,\n                                  info,\n                                  rocsparse_analysis_policy_reuse,\n                                  rocsparse_solve_policy_auto,\n                                  temp_buffer);\n      rocsparse_dcsrsv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                nnz,\n                                descr_L,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n      rocsparse_dcsrsv_analysis(handle,\n                                rocsparse_operation_none,\n                                m,\n                                nnz,\n                                descr_U,\n                                csr_val,\n                                csr_row_ptr,\n                                csr_col_ind,\n                                info,\n                                rocsparse_analysis_policy_reuse,\n                                rocsparse_solve_policy_auto,\n                                temp_buffer);\n\n      // Check for zero pivot\n      rocsparse_int position;\n      if(rocsparse_status_zero_pivot == rocsparse_csrilu0_zero_pivot(handle,\n                                                                     info,\n                                                                     &position))\n      {\n          printf(\"A has structural zero at A(%d,%d)\\n\", position, position);\n      }\n\n      // Compute incomplete LU factorization\n      rocsparse_dcsrilu0(handle,\n                         m,\n                         nnz,\n                         descr_M,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind,\n                         info,\n                         rocsparse_solve_policy_auto,\n                         temp_buffer);\n\n      // Check for zero pivot\n      if(rocsparse_status_zero_pivot == rocsparse_csrilu0_zero_pivot(handle,\n                                                                     info,\n                                                                     &position))\n      {\n          printf(\"U has structural and/or numerical zero at U(%d,%d)\\n\",\n                 position,\n                 position);\n      }\n\n      // Solve Lz = x\n      rocsparse_dcsrsv_solve(handle,\n                             rocsparse_operation_none,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr_L,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             x,\n                             z,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Solve Uy = z\n      rocsparse_dcsrsv_solve(handle,\n                             rocsparse_operation_none,\n                             m,\n                             nnz,\n                             &alpha,\n                             descr_U,\n                             csr_val,\n                             csr_row_ptr,\n                             csr_col_ind,\n                             info,\n                             z,\n                             y,\n                             rocsparse_solve_policy_auto,\n                             temp_buffer);\n\n      // Clean up\n      hipFree(temp_buffer);\n      rocsparse_destroy_mat_info(info);\n      rocsparse_destroy_mat_descr(descr_M);\n      rocsparse_destroy_mat_descr(descr_L);\n      rocsparse_destroy_mat_descr(descr_U);\n      rocsparse_destroy_handle(handle);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsrilu0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrilu0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrilu0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrilu0(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        policy: rocsparse_solve_policy,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Iterative Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format.\n\n  \\details\n  \\p rocsparse_csritilu0_buffer_size computes the size in bytes of the buffer that has to be allocated by the user.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         algorithm to use, \\ref rocsparse_itilu0_alg\n  @param[in]\n  option      combination of enumeration values from \\ref rocsparse_itilu0_option.\n  @param[in]\n  nmaxiter     maximum number of iterations.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  datatype    Type of numerical values, \\ref rocsparse_datatype.\n  @param[out]\n  buffer_size size of the temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_value \\p alg, \\p base or datatype is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr\n              or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_zero_pivot if nnz is zero.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csritilu0_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: rocsparse_int,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        datatype: rocsparse_datatype,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Iterative Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format.\n\n  \\details\n  \\p rocsparse_csritilu0_preprocess computes the information required to run \\ref rocsparse_scsritilu0_compute,\n  \\ref rocsparse_dcsritilu0_compute, \\ref rocsparse_ccsritilu0_compute, or \\ref rocsparse_zcsritilu0_compute,\n  and stores it in the buffer.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         algorithm to use, \\ref rocsparse_itilu0_alg\n  @param[in]\n  option      combination of enumeration values from \\ref rocsparse_itilu0_option.\n  @param[in]\n  nmaxiter     maximum number of iterations.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  datatype    Type of numerical values, \\ref rocsparse_datatype.\n  @param[in]\n  buffer_size size of the storage buffer allocated by the user.\n  @param[in]\n  buffer      storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_value \\p alg, \\p base or datatype is invalid.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr\n              or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_zero_pivot if missing diagonal element is detected."]
    pub fn rocsparse_csritilu0_preprocess(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: rocsparse_int,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        idx_base: rocsparse_index_base,
        datatype: rocsparse_datatype,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Iterative Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format.\n\n  \\details\n  \\p rocsparse_csritilu0_compute computes iteratively the incomplete LU factorization with 0 fill-ins and no\n  pivoting of a sparse \\f$m \\times m\\f$ CSR matrix \\f$A\\f$, such that\n  \\f[\n    A \\approx LU\n  \\f]\n\n  \\p rocsparse_csritilu0 requires a user allocated temporary buffer. Its size is returned\n  by rocsparse_csritilu0_buffer_size(). Furthermore,\n  analysis meta data is required. It can be obtained by rocsparse_csritlu0_preprocess().\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         algorithm to use, \\ref rocsparse_itilu0_alg\n  @param[in]\n  option      combination of enumeration values from \\ref rocsparse_itilu0_option.\n  @param[inout]\n  nmaxiter     maximum number of iterations.\n  @param[in]\n  tol tolerance to use for stopping criteria.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start\n              of every row of the sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[inout]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[out]\n  ilu0        incomplete factorization.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  buffer_size size of the storage buffer allocated by the user.\n  @param[in]\n  buffer      storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_value \\p alg or \\p base is invalid.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr\n              or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n/\n/**@{"]
    pub fn rocsparse_scsritilu0_compute(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: *mut rocsparse_int,
        tol: f32,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csr_val: *const f32,
        ilu0: *mut f32,
        idx_base: rocsparse_index_base,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsritilu0_compute(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: *mut rocsparse_int,
        tol: f64,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csr_val: *const f64,
        ilu0: *mut f64,
        idx_base: rocsparse_index_base,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsritilu0_compute(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: *mut rocsparse_int,
        tol: f32,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csr_val: *const rocsparse_float_complex,
        ilu0: *mut rocsparse_float_complex,
        idx_base: rocsparse_index_base,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsritilu0_compute(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        option: rocsparse_int,
        nmaxiter: *mut rocsparse_int,
        tol: f64,
        m: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csr_val: *const rocsparse_double_complex,
        ilu0: *mut rocsparse_double_complex,
        idx_base: rocsparse_index_base,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Iterative Incomplete LU factorization with 0 fill-ins and no pivoting using CSR\n  storage format.\n\n  \\details\n  \\p rocsparse_csritilu0_history fetches convergence history data.\n\n  \\note\n  The sparse CSR matrix has to be sorted. This can be achieved by calling\n  rocsparse_csrsort().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         algorithm to use, \\ref rocsparse_itilu0_alg\n  @param[out]\n  niter       number of performed iterations.\n  @param[out]\n  data        norms.\n  @param[in]\n  buffer_size size of the buffer allocated by the user.\n  @param[in]\n  buffer buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p niter or \\p data is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n/\n/**@{"]
    pub fn rocsparse_scsritilu0_history(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        niter: *mut rocsparse_int,
        data: *mut f32,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsritilu0_history(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        niter: *mut rocsparse_int,
        data: *mut f64,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsritilu0_history(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        niter: *mut rocsparse_int,
        data: *mut f32,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsritilu0_history(
        handle: rocsparse_handle,
        alg: rocsparse_itilu0_alg,
        niter: *mut rocsparse_int,
        data: *mut f64,
        buffer_size: usize,
        buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Tridiagonal solver with pivoting\n\n  \\details\n  \\p rocsparse_gtsv_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sgtsv(), rocsparse_dgtsv(),\n  rocsparse_cgtsv() and rocsparse_zgtsv(). The temporary storage buffer\n  must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system (must be >= 2).\n  @param[in]\n  n           number of columns in the dense matrix B.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. First entry must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. Last entry must be zero.\n  @param[in]\n  B           Dense matrix of size ( \\p ldb, \\p n ).\n  @param[in]\n  ldb         Leading dimension of B. Must satisfy \\p ldb >= max(1, m).\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sgtsv(), rocsparse_dgtsv(), rocsparse_cgtsv()\n              and rocsparse_zgtsv().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ldb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d, \\p du,\n              \\p B or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        B: *const f32,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        B: *const f64,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Tridiagonal solver with pivoting\n\n  \\details\n  \\p rocsparse_gtsv solves a tridiagonal system for multiple right hand sides using pivoting.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system (must be >= 2).\n  @param[in]\n  n           number of columns in the dense matrix B.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. First entry must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. Last entry must be zero.\n  @param[inout]\n  B           Dense matrix of size ( \\p ldb, \\p n ).\n  @param[in]\n  ldb         Leading dimension of B. Must satisfy \\p ldb >= max(1, m).\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ldb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d,\n              \\p du, \\p B or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        B: *mut f32,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        B: *mut f64,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        B: *mut rocsparse_float_complex,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        B: *mut rocsparse_double_complex,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Tridiagonal solver (no pivoting)\n\n  \\details\n  \\p rocsparse_gtsv_no_pivot_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sgtsv_no_pivot(), rocsparse_dgtsv_no_pivot(),\n  rocsparse_cgtsv_no_pivot() and rocsparse_zgtsv_no_pivot(). The temporary storage buffer\n  must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system (must be >= 2).\n  @param[in]\n  n           number of columns in the dense matrix B.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. First entry must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. Last entry must be zero.\n  @param[in]\n  B           Dense matrix of size ( \\p ldb, \\p n ).\n  @param[in]\n  ldb         Leading dimension of B. Must satisfy \\p ldb >= max(1, m).\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sgtsv_no_pivot(), rocsparse_dgtsv_no_pivot(), rocsparse_cgtsv_no_pivot()\n              and rocsparse_zgtsv_no_pivot().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ldb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d, \\p du,\n              \\p B or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_no_pivot_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        B: *const f32,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_no_pivot_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        B: *const f64,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_no_pivot_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        B: *const rocsparse_float_complex,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_no_pivot_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        B: *const rocsparse_double_complex,
        ldb: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Tridiagonal solver (no pivoting)\n\n  \\details\n  \\p rocsparse_gtsv_no_pivot  solves a tridiagonal linear system for multiple right-hand sides\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system (must be >= 2).\n  @param[in]\n  n           number of columns in the dense matrix B.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. First entry must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. Last entry must be zero.\n  @param[inout]\n  B           Dense matrix of size ( \\p ldb, \\p n ).\n  @param[in]\n  ldb         Leading dimension of B. Must satisfy \\p ldb >= max(1, m).\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ldb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d,\n              \\p du, \\p B or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_no_pivot(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        B: *mut f32,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_no_pivot(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        B: *mut f64,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_no_pivot(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        B: *mut rocsparse_float_complex,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_no_pivot(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        B: *mut rocsparse_double_complex,
        ldb: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Strided Batch tridiagonal solver (no pivoting)\n\n  \\details\n  \\p rocsparse_gtsv_no_pivot_strided_batch_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sgtsv_no_pivot_strided_batch(), rocsparse_dgtsv_no_pivot_strided_batch(),\n  rocsparse_cgtsv_no_pivot_strided_batch() and rocsparse_zgtsv_no_pivot_strided_batch(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system where the ith system lower diagonal starts at \\p dl+batch_stride*i.\n  @param[in]\n  d           main diagonal of tri-diagonal system where the ith system diagonal starts at \\p d+batch_stride*i.\n  @param[in]\n  du          upper diagonal of tri-diagonal system where the ith system upper diagonal starts at \\p du+batch_stride*i.\n  @param[inout]\n  x           Dense array of righthand-sides where the ith righthand-side starts at \\p x+batch_stride*i.\n  @param[in]\n  batch_count The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate each system. Must satisfy \\p batch_stride >= m.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sgtsv_no_pivot_strided_batch(), rocsparse_dgtsv_no_pivot_strided_batch(), rocsparse_cgtsv_no_pivot_strided_batch()\n              and rocsparse_zgtsv_no_pivot_strided_batch().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p batch_count or \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d, \\p du,\n              \\p x or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_no_pivot_strided_batch_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        x: *const f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_no_pivot_strided_batch_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        x: *const f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_no_pivot_strided_batch_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        x: *const rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_no_pivot_strided_batch_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        x: *const rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Strided Batch tridiagonal solver (no pivoting)\n\n  \\details\n  \\p rocsparse_gtsv_no_pivot_strided_batch  solves a batched tridiagonal linear system\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           size of the tri-diagonal linear system (must be >= 2).\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. First entry must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. Last entry must be zero.\n  @param[inout]\n  x           Dense array of righthand-sides where the ith righthand-side starts at \\p x+batch_stride*i.\n  @param[in]\n  batch_count The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate each system. Must satisfy \\p batch_stride >= m.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p batch_count or \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d,\n              \\p du, \\p x or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_no_pivot_strided_batch(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        x: *mut f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_no_pivot_strided_batch(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        x: *mut f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_no_pivot_strided_batch(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        x: *mut rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_no_pivot_strided_batch(
        handle: rocsparse_handle,
        m: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        x: *mut rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Interleaved Batch tridiagonal solver\n\n  \\details\n  \\p rocsparse_gtsv_interleaved_batch_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sgtsv_interleaved_batch(), rocsparse_dgtsv_interleaved_batch(),\n  rocsparse_cgtsv_interleaved_batch() and rocsparse_zgtsv_interleaved_batch(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         Algorithm to use when solving tridiagonal systems. Options are thomas ( \\p rocsparse_gtsv_interleaved_thomas ),\n              LU ( \\p rocsparse_gtsv_interleaved_lu ), or QR ( \\p rocsparse_gtsv_interleaved_qr ). Passing\n              \\p rocsparse_gtsv_interleaved_default defaults the algorithm to use QR. Thomas algorithm is the fastest but is not\n              stable while LU and QR are slower but are stable.\n  @param[in]\n  m           size of the tri-diagonal linear system.\n  @param[in]\n  dl          lower diagonal of tri-diagonal system. The first element of the lower diagonal must be zero.\n  @param[in]\n  d           main diagonal of tri-diagonal system.\n  @param[in]\n  du          upper diagonal of tri-diagonal system. The last element of the upper diagonal must be zero.\n  @param[inout]\n  x           Dense array of righthand-sides with dimension \\p batch_stride by \\p m.\n  @param[in]\n  batch_count The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate consecutive elements in a system. Must satisfy \\p batch_stride >= batch_count.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sgtsv_interleaved_batch(), rocsparse_dgtsv_interleaved_batch(), rocsparse_cgtsv_interleaved_batch()\n              and rocsparse_zgtsv_interleaved_batch().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p batch_count, \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d, \\p du,\n              \\p x or \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        x: *const f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        x: *const f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        x: *const rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        x: *const rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Interleaved Batch tridiagonal solver\n\n  \\details\n  \\p rocsparse_gtsv_interleaved_batch  solves a batched tridiagonal linear system. The routine requires a temporary storage\n  buffer that must be allocated by the user. The size of this buffer can be determined by first calling\n  \\p rocsparse_gtsv_interleaved_batch_buffer_size. The user can specify different algorithms for \\p rocsparse_gtsv_interleaved_batch\n  to use. Options are thomas ( \\p rocsparse_gtsv_interleaved_thomas ), LU ( \\p rocsparse_gtsv_interleaved_lu ),\n  or QR ( \\p rocsparse_gtsv_interleaved_qr ). Passing \\p rocsparse_gtsv_interleaved_default defaults the algorithm to use QR.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alg         Algorithm to use when solving tridiagonal systems. Options are thomas ( \\p rocsparse_gtsv_interleaved_thomas ),\n              LU ( \\p rocsparse_gtsv_interleaved_lu ), or QR ( \\p rocsparse_gtsv_interleaved_qr ). Passing\n              \\p rocsparse_gtsv_interleaved_default defaults the algorithm to use QR. Thomas algorithm is the fastest but is not\n              stable while LU and QR are slower but are stable.\n  @param[in]\n  m           size of the tri-diagonal linear system.\n  @param[inout]\n  dl          lower diagonal of tri-diagonal system. The first element of the lower diagonal must be zero.\n  @param[inout]\n  d           main diagonal of tri-diagonal system.\n  @param[inout]\n  du          upper diagonal of tri-diagonal system. The last element of the upper diagonal must be zero.\n  @param[inout]\n  x           Dense array of righthand-sides with dimension \\p batch_stride by \\p m.\n  @param[in]\n  batch_count The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate consecutive elements in a system. Must satisfy \\p batch_stride >= batch_count.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p batch_count or \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p dl, \\p d,\n              \\p du, \\p x or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgtsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        x: *mut f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgtsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        x: *mut f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgtsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *mut rocsparse_float_complex,
        d: *mut rocsparse_float_complex,
        du: *mut rocsparse_float_complex,
        x: *mut rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgtsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gtsv_interleaved_alg,
        m: rocsparse_int,
        dl: *mut rocsparse_double_complex,
        d: *mut rocsparse_double_complex,
        du: *mut rocsparse_double_complex,
        x: *mut rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Batched Pentadiagonal solver\n\n  \\details\n  \\p rocsparse_gpsv_interleaved_batch_buffer_size calculates the required buffer size\n  for rocsparse_gpsv_interleaved_batch(). It is the users responsibility to allocate\n  this buffer.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  alg          algorithm to solve the linear system.\n  @param[in]\n  m            size of the pentadiagonal linear system.\n  @param[in]\n  ds           lower diagonal (distance 2) of pentadiagonal system. First two entries\n               must be zero.\n  @param[in]\n  dl           lower diagonal of pentadiagonal system. First entry must be zero.\n  @param[in]\n  d            main diagonal of pentadiagonal system.\n  @param[in]\n  du           upper diagonal of pentadiagonal system. Last entry must be zero.\n  @param[in]\n  dw           upper diagonal (distance 2) of pentadiagonal system. Last two entries\n               must be zero.\n  @param[in]\n  x            Dense array of right-hand-sides with dimension \\p batch_stride by \\p m.\n  @param[in]\n  batch_count  The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate consecutive elements in a system.\n               Must satisfy \\p batch_stride >= batch_count.\n  @param[out]\n  buffer_size  Number of bytes of the temporary storage buffer required.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p alg, \\p batch_count or\n              \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p ds, \\p dl, \\p d, \\p du, \\p dw, \\p x\n              or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgpsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *const f32,
        dl: *const f32,
        d: *const f32,
        du: *const f32,
        dw: *const f32,
        x: *const f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgpsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *const f64,
        dl: *const f64,
        d: *const f64,
        du: *const f64,
        dw: *const f64,
        x: *const f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgpsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *const rocsparse_float_complex,
        dl: *const rocsparse_float_complex,
        d: *const rocsparse_float_complex,
        du: *const rocsparse_float_complex,
        dw: *const rocsparse_float_complex,
        x: *const rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgpsv_interleaved_batch_buffer_size(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *const rocsparse_double_complex,
        dl: *const rocsparse_double_complex,
        d: *const rocsparse_double_complex,
        du: *const rocsparse_double_complex,
        dw: *const rocsparse_double_complex,
        x: *const rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup precond_module\n  \\brief Batched Pentadiagonal solver\n\n  \\details\n  \\p rocsparse_gpsv_interleaved_batch  solves a batch of pentadiagonal linear systems.\n  The coefficient matrix of each pentadiagonal linear system is defined by five vectors\n  for the lower part (ds, dl), main diagonal (d) and upper part (du, dw).\n\n  The function requires a temporary buffer. The size of the required buffer is returned\n  by rocsparse_gpsv_interleaved_batch_buffer_size().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  The routine is numerically stable because it uses QR to solve the linear systems.\n\n  \\note\n  m need to be at least 3, to be a valid pentadiagonal matrix.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  alg          algorithm to solve the linear system.\n  @param[in]\n  m            size of the pentadiagonal linear system.\n  @param[inout]\n  ds           lower diagonal (distance 2) of pentadiagonal system. First two entries\n               must be zero.\n  @param[inout]\n  dl           lower diagonal of pentadiagonal system. First entry must be zero.\n  @param[inout]\n  d            main diagonal of pentadiagonal system.\n  @param[inout]\n  du           upper diagonal of pentadiagonal system. Last entry must be zero.\n  @param[inout]\n  dw           upper diagonal (distance 2) of pentadiagonal system. Last two entries\n               must be zero.\n  @param[inout]\n  x            Dense array of right-hand-sides with dimension \\p batch_stride by \\p m.\n  @param[in]\n  batch_count  The number of systems to solve.\n  @param[in]\n  batch_stride The number of elements that separate consecutive elements in a system.\n               Must satisfy \\p batch_stride >= batch_count.\n  @param[in]\n  temp_buffer  Temporary storage buffer allocated by the user.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p alg, \\p batch_count or\n              \\p batch_stride is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p ds, \\p dl, \\p d, \\p du, \\p dw, \\p x\n              or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgpsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *mut f32,
        dl: *mut f32,
        d: *mut f32,
        du: *mut f32,
        dw: *mut f32,
        x: *mut f32,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgpsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *mut f64,
        dl: *mut f64,
        d: *mut f64,
        du: *mut f64,
        dw: *mut f64,
        x: *mut f64,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgpsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *mut rocsparse_float_complex,
        dl: *mut rocsparse_float_complex,
        d: *mut rocsparse_float_complex,
        du: *mut rocsparse_float_complex,
        dw: *mut rocsparse_float_complex,
        x: *mut rocsparse_float_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgpsv_interleaved_batch(
        handle: rocsparse_handle,
        alg: rocsparse_gpsv_interleaved_alg,
        m: rocsparse_int,
        ds: *mut rocsparse_double_complex,
        dl: *mut rocsparse_double_complex,
        d: *mut rocsparse_double_complex,
        du: *mut rocsparse_double_complex,
        dw: *mut rocsparse_double_complex,
        x: *mut rocsparse_double_complex,
        batch_count: rocsparse_int,
        batch_stride: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the number of nonzero elements per row or column and the total number of nonzero elements in a dense matrix.\n  \\details\n  The routine does support asynchronous execution if the pointer mode is set to device.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir        direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by \\ref rocsparse_direction_row.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[in]\n  ld         leading dimension of dense array \\p A.\n\n  @param[out]\n  nnz_per_row_columns\n              array of size \\p m or \\p n containing the number of nonzero elements per row or column, respectively.\n  @param[out]\n  nnz_total_dev_host_ptr\n              total number of nonzero elements in device or host memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p nnz_per_row_columns or \\p nnz_total_dev_host_ptr\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_snnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f32,
        ld: rocsparse_int,
        nnz_per_row_columns: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dnnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f64,
        ld: rocsparse_int,
        nnz_per_row_columns: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cnnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_float_complex,
        ld: rocsparse_int,
        nnz_per_row_columns: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_znnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_double_complex,
        ld: rocsparse_int,
        nnz_per_row_columns: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the matrix A in dense format into a sparse matrix in CSR format.\n  All the parameters are assumed to have been pre-allocated by the user and the arrays are filled in based on nnz_per_row, which can be pre-computed with rocsparse_xnnz().\n\n  \\note\n  This function is blocking with respect to the host.\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[in]\n  ld         leading dimension of dense array \\p A.\n\n  @param[in]\n  nnz_per_rows   array of size \\p n containing the number of non-zero elements per row.\n\n  @param[out]\n  csr_val\n              array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[out]\n  csr_row_ptr\n              integer array of m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[out]\n  csr_col_ind\n              integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p nnz_per_rows or \\p csr_val \\p csr_row_ptr or \\p csr_col_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sdense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f32,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        csr_val: *mut f32,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ddense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f64,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        csr_val: *mut f64,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cdense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_float_complex,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zdense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_double_complex,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the the size of the user allocated temporary storage buffer used when converting and pruning\n  a dense matrix to a CSR matrix.\n\n  \\details\n  \\p rocsparse_prune_dense2csr_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_sprune_dense2csr_nnz(), rocsparse_dprune_dense2csr_nnz(),\n  rocsparse_sprune_dense2csr(), and rocsparse_dprune_dense2csr(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  threshold   pointer to the pruning non-negative threshold which can exist in either host or device memory.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  csr_val\n              array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[in]\n  csr_row_ptr\n              integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[in]\n  csr_col_ind\n              integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sprune_dense2csr_nnz(), rocsparse_dprune_dense2csr_nnz(),\n              rocsparse_sprune_dense2csr() and rocsparse_dprune_dense2csr().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        threshold: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        threshold: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the number of nonzero elements per row and the total number of nonzero elements in a dense matrix once\n  elements less than the threshold are pruned from the matrix.\n\n  \\details\n  The routine does support asynchronous execution if the pointer mode is set to device.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  threshold   pointer to the pruning non-negative threshold which can exist in either host or device memory.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A.\n\n  @param[out]\n  csr_row_ptr\n              integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[out]\n  nnz_total_dev_host_ptr\n              total number of nonzero elements in device or host memory.\n\n  @param[out]\n  temp_buffer\n              buffer allocated by the user whose size is determined by calling rocsparse_xprune_dense2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p lda is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p threshold or \\p descr or \\p csr_row_ptr\n              or \\p nnz_total_dev_host_ptr or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        threshold: *const f32,
        descr: rocsparse_mat_descr,
        csr_row_ptr: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        threshold: *const f64,
        descr: rocsparse_mat_descr,
        csr_row_ptr: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the matrix A in dense format into a sparse matrix in CSR format while pruning values\n  that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.\n\n  \\details\n  The user first allocates \\p csr_row_ptr to have \\p m+1 elements and then calls rocsparse_xprune_dense2csr_nnz()\n  which fills in the \\p csr_row_ptr array and stores the number of elements that are larger than the pruning threshold\n  in \\p nnz_total_dev_host_ptr. The user then allocates \\p csr_col_ind and \\p csr_val to have size \\p nnz_total_dev_host_ptr\n  and completes the conversion by calling rocsparse_xprune_dense2csr(). A temporary storage buffer is used by both\n  rocsparse_xprune_dense2csr_nnz() and rocsparse_xprune_dense2csr() and must be allocated by the user and whose size is determined\n  by rocsparse_xprune_dense2csr_buffer_size().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  threshold   pointer to the non-negative pruning threshold which can exist in either host or device memory.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[out]\n  csr_val\n              array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[in]\n  csr_row_ptr\n              integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[out]\n  csr_col_ind\n              integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user, size is returned by\n              rocsparse_xprune_dense2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p lda is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p descr or \\p threshold or \\p csr_val\n              or \\p csr_row_ptr or \\p csr_col_ind or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        threshold: *const f32,
        descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        threshold: *const f64,
        descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the size of the user allocated temporary storage buffer used when converting and pruning by percentage a\n  dense matrix to a CSR matrix.\n\n  \\details\n  When converting and pruning a dense matrix A to a CSR matrix by percentage the following steps are performed. First the user\n  calls \\p rocsparse_prune_dense2csr_by_percentage_buffer_size which determines the size of the temporary storage buffer. Once\n  determined, this buffer must be allocated by the user. Next the user allocates the csr_row_ptr array to have \\p m+1 elements\n  and calls \\p rocsparse_prune_dense2csr_nnz_by_percentage. Finally the user finishes the conversion by allocating the csr_col_ind\n  and csr_val arrays (whos size is determined by the value at nnz_total_dev_host_ptr) and calling \\p rocsparse_prune_dense2csr_by_percentage.\n\n  The pruning by percentage works by first sorting the absolute values of the dense matrix \\p A. We then determine a position in this\n  sorted array by\n  \\f[\n    pos = ceil(m*n*(percentage/100)) - 1\n    pos = min(pos, m*n-1)\n    pos = max(pos, 0)\n    threshold = sorted_A[pos]\n  \\f]\n  Once we have this threshold we prune values in the dense matrix \\p A as in \\p rocsparse_prune_dense2csr.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  percentage  percentage >= 0 and percentage <= 100.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  csr_val    array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n\n  @param[in]\n  csr_row_ptr integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n\n  @param[in]\n  csr_col_ind integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[in]\n  info prune information structure\n\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sprune_dense2csr_nnz_by_percentage(), rocsparse_dprune_dense2csr_nnz_by_percentage(),\n              rocsparse_sprune_dense2csr_by_percentage() and rocsparse_dprune_dense2csr_by_percentage().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr_by_percentage_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        percentage: f32,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr_by_percentage_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        percentage: f64,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the number of nonzero elements per row and the total number of nonzero elements in a dense matrix\n  when converting and pruning by percentage a dense matrix to a CSR matrix.\n\n  \\details\n  When converting and pruning a dense matrix A to a CSR matrix by percentage the following steps are performed. First the user\n  calls \\p rocsparse_prune_dense2csr_by_percentage_buffer_size which determines the size of the temporary storage buffer. Once\n  determined, this buffer must be allocated by the user. Next the user allocates the csr_row_ptr array to have \\p m+1 elements\n  and calls \\p rocsparse_prune_dense2csr_nnz_by_percentage. Finally the user finishes the conversion by allocating the csr_col_ind\n  and csr_val arrays (whos size is determined by the value at nnz_total_dev_host_ptr) and calling \\p rocsparse_prune_dense2csr_by_percentage.\n\n  The pruning by percentage works by first sorting the absolute values of the dense matrix \\p A. We then determine a position in this\n  sorted array by\n  \\f[\n    pos = ceil(m*n*(percentage/100)) - 1\n    pos = min(pos, m*n-1)\n    pos = max(pos, 0)\n    threshold = sorted_A[pos]\n  \\f]\n  Once we have this threshold we prune values in the dense matrix \\p A as in \\p rocsparse_prune_dense2csr.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  percentage  percentage >= 0 and percentage <= 100.\n\n  @param[in]\n  descr       the descriptor of the dense matrix \\p A.\n\n  @param[out]\n  csr_row_ptr integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n\n  @param[out]\n  nnz_total_dev_host_ptr total number of nonzero elements in device or host memory.\n\n  @param[in]\n  info prune information structure\n\n  @param[out]\n  temp_buffer buffer allocated by the user whose size is determined by calling rocsparse_xprune_dense2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p lda or \\p percentage is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p descr or \\p info or \\p csr_row_ptr\n              or \\p nnz_total_dev_host_ptr or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr_nnz_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        percentage: f32,
        descr: rocsparse_mat_descr,
        csr_row_ptr: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr_nnz_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        percentage: f64,
        descr: rocsparse_mat_descr,
        csr_row_ptr: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the matrix A in dense format into a sparse matrix in CSR format while pruning values\n  based on percentage.\n\n  \\details\n  When converting and pruning a dense matrix A to a CSR matrix by percentage the following steps are performed. First the user\n  calls \\p rocsparse_prune_dense2csr_by_percentage_buffer_size which determines the size of the temporary storage buffer. Once\n  determined, this buffer must be allocated by the user. Next the user allocates the csr_row_ptr array to have \\p m+1 elements\n  and calls \\p rocsparse_prune_dense2csr_nnz_by_percentage. Finally the user finishes the conversion by allocating the csr_col_ind\n  and csr_val arrays (whos size is determined by the value at nnz_total_dev_host_ptr) and calling \\p rocsparse_prune_dense2csr_by_percentage.\n\n  The pruning by percentage works by first sorting the absolute values of the dense matrix \\p A. We then determine a position in this\n  sorted array by\n  \\f[\n    pos = ceil(m*n*(percentage/100)) - 1\n    pos = min(pos, m*n-1)\n    pos = max(pos, 0)\n    threshold = sorted_A[pos]\n  \\f]\n  Once we have this threshold we prune values in the dense matrix \\p A as in \\p rocsparse_prune_dense2csr.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  A           array of dimensions (\\p lda, \\p n)\n\n  @param[in]\n  lda         leading dimension of dense array \\p A.\n\n  @param[in]\n  percentage  percentage >= 0 and percentage <= 100.\n\n  @param[in]\n  descr       the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[out]\n  csr_val array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n\n  @param[in]\n  csr_row_ptr integer array of \\p m+1 elements that contains the start of every row and the end of the last row plus one.\n\n  @param[out]\n  csr_col_ind integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[in]\n  info prune information structure\n\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user, size is returned by\n              rocsparse_xprune_dense2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p lda or \\p percentage is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p descr or \\p info or \\p csr_val\n              or \\p csr_row_ptr or \\p csr_col_ind or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_dense2csr_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f32,
        lda: rocsparse_int,
        percentage: f32,
        descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_dense2csr_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        A: *const f64,
        lda: rocsparse_int,
        percentage: f64,
        descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n\n  This function converts the matrix A in dense format into a sparse matrix in CSC format.\n  All the parameters are assumed to have been pre-allocated by the user and the arrays are\n  filled in based on nnz_per_columns, which can be pre-computed with rocsparse_xnnz().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[in]\n  ld         leading dimension of dense array \\p A.\n\n  @param[in]\n  nnz_per_columns   array of size \\p n containing the number of non-zero elements per column.\n\n  @param[out]\n  csc_val\n              array of nnz ( = \\p csc_col_ptr[m] - \\p csc_col_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[out]\n  csc_col_ptr\n              integer array of m+1 elements that contains the start of every column and the end of the last column plus one.\n  @param[out]\n  csc_row_ind\n              integer array of nnz ( = \\p csc_col_ptr[m] - csc_col_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p nnz_per_columns or \\p csc_val \\p csc_col_ptr or \\p csc_row_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sdense2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f32,
        ld: rocsparse_int,
        nnz_per_columns: *const rocsparse_int,
        csc_val: *mut f32,
        csc_col_ptr: *mut rocsparse_int,
        csc_row_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ddense2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f64,
        ld: rocsparse_int,
        nnz_per_columns: *const rocsparse_int,
        csc_val: *mut f64,
        csc_col_ptr: *mut rocsparse_int,
        csc_row_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cdense2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_float_complex,
        ld: rocsparse_int,
        nnz_per_columns: *const rocsparse_int,
        csc_val: *mut rocsparse_float_complex,
        csc_col_ptr: *mut rocsparse_int,
        csc_row_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zdense2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_double_complex,
        ld: rocsparse_int,
        nnz_per_columns: *const rocsparse_int,
        csc_val: *mut rocsparse_double_complex,
        csc_col_ptr: *mut rocsparse_int,
        csc_row_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n\n  This function converts the matrix A in dense format into a sparse matrix in COO format.\n  All the parameters are assumed to have been pre-allocated by the user and the arrays are\n  filled in based on nnz_per_rows, which can be pre-computed with rocsparse_xnnz().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr      the descriptor of the dense matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[in]\n  ld         leading dimension of dense array \\p A.\n\n  @param[in]\n  nnz_per_rows   array of size \\p n containing the number of non-zero elements per row.\n\n  @param[out]\n  coo_val\n              array of nnz nonzero elements of matrix \\p A.\n  @param[out]\n  coo_row_ind\n              integer array of nnz row indices of the non-zero elements of matrix \\p A.\n  @param[out]\n  coo_col_ind integer array of nnz column indices of the non-zero elements of matrix \\p A.\n\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p nnz_per_rows or \\p coo_val \\p coo_col_ind or \\p coo_row_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sdense2coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f32,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        coo_val: *mut f32,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ddense2coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const f64,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        coo_val: *mut f64,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cdense2coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_float_complex,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        coo_val: *mut rocsparse_float_complex,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zdense2coo(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        A: *const rocsparse_double_complex,
        ld: rocsparse_int,
        nnz_per_rows: *const rocsparse_int,
        coo_val: *mut rocsparse_double_complex,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the sparse matrix in CSR format into a dense matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr       the descriptor of the dense matrix \\p A, the supported matrix type is \\ref rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  csr_val     array of nnz ( = \\p csr_row_ptr[m] - \\p csr_row_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[in]\n  csr_row_ptr integer array of m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[in]\n  csr_col_ind integer array of nnz ( = \\p csr_row_ptr[m] - csr_row_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[out]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[out]\n  ld          leading dimension of dense array \\p A.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p csr_val \\p csr_row_ptr or \\p csr_col_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_scsr2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        A: *mut f32,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        A: *mut f64,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        A: *mut rocsparse_float_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        A: *mut rocsparse_double_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the sparse matrix in CSC format into a dense matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  descr       the descriptor of the dense matrix \\p A, the supported matrix type is \\ref rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  csc_val     array of nnz ( = \\p csc_col_ptr[m] - \\p csc_col_ptr[0] ) nonzero elements of matrix \\p A.\n  @param[in]\n  csc_col_ptr integer array of m+1 elements that contains the start of every row and the end of the last row plus one.\n  @param[in]\n  csc_row_ind integer array of nnz ( = \\p csc_col_ptr[m] - csc_col_ptr[0] ) column indices of the non-zero elements of matrix \\p A.\n\n  @param[out]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[out]\n  ld          leading dimension of dense array \\p A.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p csc_val \\p csc_col_ptr or \\p csc_row_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_scsc2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csc_val: *const f32,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        A: *mut f32,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsc2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csc_val: *const f64,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        A: *mut f64,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsc2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csc_val: *const rocsparse_float_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        A: *mut rocsparse_float_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsc2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csc_val: *const rocsparse_double_complex,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        A: *mut rocsparse_double_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the sparse matrix in COO format into a dense matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  m           number of rows of the dense matrix \\p A.\n\n  @param[in]\n  n           number of columns of the dense matrix \\p A.\n\n  @param[in]\n  nnz         number of non-zero entries of the sparse COO matrix.\n  @param[in]\n  descr       the descriptor of the dense matrix \\p A, the supported matrix type is \\ref rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  coo_val     array of nnz nonzero elements of matrix \\p A.\n  @param[in]\n  coo_row_ind integer array of nnz row indices of the non-zero elements of matrix \\p A.\n\n  @param[in]\n  coo_col_ind integer array of nnz column indices of the non-zero elements of matrix \\p A.\n  @param[out]\n  A           array of dimensions (\\p ld, \\p n)\n\n  @param[out]\n  ld          leading dimension of dense array \\p A.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p nnz or \\p ld is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p A or \\p coo_val \\p coo_col_ind or \\p coo_row_ind\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_scoo2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        coo_val: *const f32,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        A: *mut f32,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcoo2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        coo_val: *const f64,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        A: *mut f64,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccoo2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        coo_val: *const rocsparse_float_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        A: *mut rocsparse_float_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcoo2dense(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        coo_val: *const rocsparse_double_complex,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        A: *mut rocsparse_double_complex,
        ld: rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  Given a sparse CSR matrix and a non-negative tolerance, this function computes how many entries would be left\n  in each row of the matrix if elements less than the tolerance were removed. It also computes the total number\n  of remaining elements in the matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n\n  @param[in]\n  m             number of rows of the sparse CSR matrix.\n\n  @param[in]\n  descr_A       the descriptor of the sparse CSR matrix.\n\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                uncompressed sparse CSR matrix.\n  @param[out]\n  nnz_per_row   array of length \\p m containing the number of entries that will be kept per row in\n                the final compressed CSR matrix.\n  @param[out]\n  nnz_C         number of elements in the column indices and values arrays of the compressed\n                sparse CSR matrix. Can be either host or device pointer.\n  @param[in]\n  tol           the non-negative tolerance used for compression. If \\p tol is complex then only the magnitude\n                of the real part is used. Entries in the input uncompressed CSR array that are below the tolerance\n                are removed in output compressed CSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n is invalid.\n  \\retval     rocsparse_status_invalid_value \\p tol is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_val_A or \\p csr_row_ptr_A or \\p nnz_per_row or \\p nnz_C\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_snnz_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        nnz_per_row: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
        tol: f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dnnz_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        nnz_per_row: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
        tol: f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cnnz_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const rocsparse_float_complex,
        csr_row_ptr_A: *const rocsparse_int,
        nnz_per_row: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
        tol: rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_znnz_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const rocsparse_double_complex,
        csr_row_ptr_A: *const rocsparse_int,
        nnz_per_row: *mut rocsparse_int,
        nnz_C: *mut rocsparse_int,
        tol: rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse COO matrix\n\n  \\details\n  \\p rocsparse_csr2coo converts the CSR array containing the row offsets, that point\n  to the start of every row, into a COO array of row indices.\n\n  \\note\n  It can also be used to convert a CSC array containing the column offsets into a COO\n  array of column indices.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row\n              of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[out]\n  coo_row_ind array of \\p nnz elements containing the row indices of the sparse COO\n              matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr or \\p coo_row_ind\n              pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n\n  \\par Example\n  This example converts a CSR matrix into a COO matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 5;\n      rocsparse_int nnz = 8;\n\n      csr_row_ptr[m+1] = {0, 3, 5, 8};             // device memory\n      csr_col_ind[nnz] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      csr_val[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8}; // device memory\n\n      // Allocate COO matrix arrays\n      rocsparse_int* coo_row_ind;\n      rocsparse_int* coo_col_ind;\n      float* coo_val;\n\n      hipMalloc((void**)&coo_row_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&coo_col_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&coo_val, sizeof(float) * nnz);\n\n      // Convert the csr row offsets into coo row indices\n      rocsparse_csr2coo(handle,\n                        csr_row_ptr,\n                        nnz,\n                        m,\n                        coo_row_ind,\n                        rocsparse_index_base_zero);\n\n      // Copy the column and value arrays\n      hipMemcpy(coo_col_ind,\n                csr_col_ind,\n                sizeof(rocsparse_int) * nnz,\n                hipMemcpyDeviceToDevice);\n\n      hipMemcpy(coo_val,\n                csr_val,\n                sizeof(float) * nnz,\n                hipMemcpyDeviceToDevice);\n  \\endcode"]
    pub fn rocsparse_csr2coo(
        handle: rocsparse_handle,
        csr_row_ptr: *const rocsparse_int,
        nnz: rocsparse_int,
        m: rocsparse_int,
        coo_row_ind: *mut rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse CSC matrix\n\n  \\details\n  \\p rocsparse_csr2csc_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_scsr2csc(), rocsparse_dcsr2csc(), rocsparse_ccsr2csc() and\n  rocsparse_zcsr2csc(). The temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  copy_values \\ref rocsparse_action_symbolic or \\ref rocsparse_action_numeric.\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_scsr2csc(), rocsparse_dcsr2csc(), rocsparse_ccsr2csc() and\n              rocsparse_zcsr2csc().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr, \\p csr_col_ind or\n              \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_csr2csc_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        copy_values: rocsparse_action,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse CSC matrix\n\n  \\details\n  \\p rocsparse_csr2csc converts a CSR matrix into a CSC matrix. \\p rocsparse_csr2csc\n  can also be used to convert a CSC matrix into a CSR matrix. \\p copy_values decides\n  whether \\p csc_val is being filled during conversion (\\ref rocsparse_action_numeric)\n  or not (\\ref rocsparse_action_symbolic).\n\n  \\p rocsparse_csr2csc requires extra temporary storage buffer that has to be allocated\n  by the user. Storage buffer size can be determined by rocsparse_csr2csc_buffer_size().\n\n  \\note\n  The resulting matrix can also be seen as the transpose of the input matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[out]\n  csc_val     array of \\p nnz elements of the sparse CSC matrix.\n  @param[out]\n  csc_row_ind array of \\p nnz elements containing the row indices of the sparse CSC\n              matrix.\n  @param[out]\n  csc_col_ptr array of \\p n+1 elements that point to the start of every column of the\n              sparse CSC matrix.\n  @param[in]\n  copy_values \\ref rocsparse_action_symbolic or \\ref rocsparse_action_numeric.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user, size is returned by\n              rocsparse_csr2csc_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_val, \\p csr_row_ptr,\n              \\p csr_col_ind, \\p csc_val, \\p csc_row_ind, \\p csc_col_ptr or\n              \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n  \\par Example\n  This example computes the transpose of a CSR matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m_A   = 3;\n      rocsparse_int n_A   = 5;\n      rocsparse_int nnz_A = 8;\n\n      csr_row_ptr_A[m+1] = {0, 3, 5, 8};             // device memory\n      csr_col_ind_A[nnz] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      csr_val_A[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8}; // device memory\n\n      // Allocate memory for transposed CSR matrix\n      rocsparse_int m_T   = n_A;\n      rocsparse_int n_T   = m_A;\n      rocsparse_int nnz_T = nnz_A;\n\n      rocsparse_int* csr_row_ptr_T;\n      rocsparse_int* csr_col_ind_T;\n      float* csr_val_T;\n\n      hipMalloc((void**)&csr_row_ptr_T, sizeof(rocsparse_int) * (m_T + 1));\n      hipMalloc((void**)&csr_col_ind_T, sizeof(rocsparse_int) * nnz_T);\n      hipMalloc((void**)&csr_val_T, sizeof(float) * nnz_T);\n\n      // Obtain the temporary buffer size\n      size_t buffer_size;\n      rocsparse_csr2csc_buffer_size(handle,\n                                    m_A,\n                                    n_A,\n                                    nnz_A,\n                                    csr_row_ptr_A,\n                                    csr_col_ind_A,\n                                    rocsparse_action_numeric,\n                                    &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      rocsparse_scsr2csc(handle,\n                         m_A,\n                         n_A,\n                         nnz_A,\n                         csr_val_A,\n                         csr_row_ptr_A,\n                         csr_col_ind_A,\n                         csr_val_T,\n                         csr_col_ind_T,\n                         csr_row_ptr_T,\n                         rocsparse_action_numeric,\n                         rocsparse_index_base_zero,\n                         temp_buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csc_val: *mut f32,
        csc_row_ind: *mut rocsparse_int,
        csc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csc_val: *mut f64,
        csc_row_ind: *mut rocsparse_int,
        csc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csc_val: *mut rocsparse_float_complex,
        csc_row_ind: *mut rocsparse_int,
        csc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2csc(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        csc_val: *mut rocsparse_double_complex,
        csc_row_ind: *mut rocsparse_int,
        csc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse GEneral BSR matrix into a sparse GEneral BSC matrix\n\n  \\details\n  \\p rocsparse_gebsr2gebsc_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_sgebsr2gebsc(), rocsparse_dgebsr2gebsc(), rocsparse_cgebsr2gebsc() and\n  rocsparse_zgebsr2gebsc(). The temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  mb           number of rows of the sparse GEneral BSR matrix.\n  @param[in]\n  nb           number of columns of the sparse GEneral BSR matrix.\n  @param[in]\n  nnzb         number of non-zero entries of the sparse GEneral BSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb*row_block_dim*col_block_dim containing the values of the sparse GEneral BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every row of the\n              sparse GEneral BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the column indices of the sparse\n              GEneral BSR matrix.\n  @param[in]\n  row_block_dim   row size of the blocks in the sparse general BSR matrix.\n  @param[in]\n  col_block_dim   col size of the blocks in the sparse general BSR matrix.\n\n  @param[out]\n  p_buffer_size number of bytes of the temporary storage buffer required by\n              rocsparse_sgebsr2gebsc(), rocsparse_dgebsr2gebsc(), rocsparse_cgebsr2gebsc() and\n              rocsparse_zgebsr2gebsc().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb or \\p nnzb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_row_ptr, \\p bsr_col_ind or\n              \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n/\n/**@{"]
    pub fn rocsparse_sgebsr2gebsc_buffer_size(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        p_buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsr2gebsc_buffer_size(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        p_buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsr2gebsc_buffer_size(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        p_buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsr2gebsc_buffer_size(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        p_buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse GEneral BSR matrix into a sparse GEneral BSC matrix\n\n  \\details\n  \\p rocsparse_gebsr2gebsc converts a GEneral BSR matrix into a GEneral BSC matrix. \\p rocsparse_gebsr2gebsc\n  can also be used to convert a GEneral BSC matrix into a GEneral BSR matrix. \\p copy_values decides\n  whether \\p bsc_val is being filled during conversion (\\ref rocsparse_action_numeric)\n  or not (\\ref rocsparse_action_symbolic).\n\n  \\p rocsparse_gebsr2gebsc requires extra temporary storage buffer that has to be allocated\n  by the user. Storage buffer size can be determined by rocsparse_gebsr2gebsc_buffer_size().\n\n  \\note\n  The resulting matrix can also be seen as the transpose of the input matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  mb          number of rows of the sparse GEneral BSR matrix.\n  @param[in]\n  nb          number of columns of the sparse GEneral BSR matrix.\n  @param[in]\n  nnzb        number of non-zero entries of the sparse GEneral BSR matrix.\n  @param[in]\n  bsr_val     array of \\p nnzb * \\p row_block_dim * \\p col_block_dim  elements of the sparse GEneral BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse GEneral BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              GEneral BSR matrix.\n  @param[in]\n  row_block_dim   row size of the blocks in the sparse general BSR matrix.\n  @param[in]\n  col_block_dim   col size of the blocks in the sparse general BSR matrix.\n  @param[out]\n  bsc_val     array of \\p nnz elements of the sparse BSC matrix.\n  @param[out]\n  bsc_row_ind array of \\p nnz elements containing the row indices of the sparse BSC\n              matrix.\n  @param[out]\n  bsc_col_ptr array of \\p n+1 elements that point to the start of every column of the\n              sparse BSC matrix.\n  @param[in]\n  copy_values \\ref rocsparse_action_symbolic or \\ref rocsparse_action_numeric.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n  @param[in]\n  temp_buffer temporary storage buffer allocated by the user, size is returned by\n              rocsparse_gebsr2gebsc_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb, \\p nb or \\p nnzb is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_val, \\p bsr_row_ptr,\n              \\p bsr_col_ind, \\p bsc_val, \\p bsc_row_ind, \\p bsc_col_ptr or\n              \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_arch_mismatch the device is not supported.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n  \\par Example\n  This example computes the transpose of a GEneral BSR matrix.\n  \\code{.c}\n      //     1 2 0 3\n      // A = 0 4 5 0\n      //     6 0 0 7\n      //     1 2 3 4\n\n      rocsparse_int mb_A   = 2;\n      rocsparse_int row_block_dim = 2;\n      rocsparse_int col_block_dim = 2;\n      rocsparse_int nb_A   = 2;\n      rocsparse_int nnzb_A = 4;\n\n      bsr_row_ptr_A[mb_A+1] = {0, 2, 4};               // device memory\n      bsr_col_ind_A[nnzb_A] = {0, 1, 0, 1}; // device memory\n      bsr_val_A[nnzb_A]     = {1, 0, 2, 4, 0, 5, 3, 0, 6, 1, 0, 2, 0, 3, 7, 4}; // device memory\n\n      // Allocate memory for transposed BSR matrix\n      rocsparse_int mb_T   = nb_A;\n      rocsparse_int nb_T   = mb_A;\n      rocsparse_int nnzb_T = nnzb_A;\n\n      rocsparse_int* bsr_row_ptr_T;\n      rocsparse_int* bsr_col_ind_T;\n      float* bsr_val_T;\n\n      hipMalloc((void**)&bsr_row_ptr_T, sizeof(rocsparse_int) * (mb_T + 1));\n      hipMalloc((void**)&bsr_col_ind_T, sizeof(rocsparse_int) * nnzb_T);\n      hipMalloc((void**)&bsr_val_T, sizeof(float) * nnzb_T);\n\n      // Obtain the temporary buffer size\n      size_t buffer_size;\n      rocsparse_gebsr2gebsc_buffer_size(handle,\n                                    mb_A,\n                                    nb_A,\n                                    nnzb_A,\n                                    bsr_row_ptr_A,\n                                    bsr_col_ind_A,\n                                    rocsparse_action_numeric,\n                                    &buffer_size);\n\n      // Allocate temporary buffer\n      void* temp_buffer;\n      hipMalloc(&temp_buffer, buffer_size);\n\n      rocsparse_sgebsr2gebsc(handle,\n                         mb_A,\n                         nb_A,\n                         nnzb_A,\n                         bsr_val_A,\n                         bsr_row_ptr_A,\n                         bsr_col_ind_A,\n                         row_block_dim,\n                         col_block_dim,\n                         bsr_val_T,\n                         bsr_col_ind_T,\n                         bsr_row_ptr_T,\n                         rocsparse_action_numeric,\n                         rocsparse_index_base_zero,\n                         temp_buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sgebsr2gebsc(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *mut f32,
        bsc_row_ind: *mut rocsparse_int,
        bsc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsr2gebsc(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *mut f64,
        bsc_row_ind: *mut rocsparse_int,
        bsc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsr2gebsc(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *mut rocsparse_float_complex,
        bsc_row_ind: *mut rocsparse_int,
        bsc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsr2gebsc(
        handle: rocsparse_handle,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsc_val: *mut rocsparse_double_complex,
        bsc_row_ind: *mut rocsparse_int,
        bsc_col_ptr: *mut rocsparse_int,
        copy_values: rocsparse_action,
        idx_base: rocsparse_index_base,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse ELL matrix\n\n  \\details\n  \\p rocsparse_csr2ell_width computes the maximum of the per row non-zero elements\n  over all rows, the ELL \\p width, for a given CSR matrix.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  ell_descr   descriptor of the sparse ELL matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  ell_width   pointer to the number of non-zero elements per row in ELL storage\n              format.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_descr, \\p csr_row_ptr, or\n              \\p ell_width pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_csr2ell_width(
        handle: rocsparse_handle,
        m: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_row_ptr: *const rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse ELL matrix\n\n  \\details\n  \\p rocsparse_csr2ell converts a CSR matrix into an ELL matrix. It is assumed,\n  that \\p ell_val and \\p ell_col_ind are allocated. Allocation size is computed by the\n  number of rows times the number of ELL non-zero elements per row, such that\n  \\f$\\text{nnz}_{\\text{ELL}} = m \\cdot \\text{ell_width}\\f$. The number of ELL\n  non-zero elements per row is obtained by rocsparse_csr2ell_width().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val     array containing the values of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array containing the column indices of the sparse CSR matrix.\n  @param[in]\n  ell_descr   descriptor of the sparse ELL matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  ell_width   number of non-zero elements per row in ELL storage format.\n  @param[out]\n  ell_val     array of \\p m times \\p ell_width elements of the sparse ELL matrix.\n  @param[out]\n  ell_col_ind array of \\p m times \\p ell_width elements containing the column indices\n              of the sparse ELL matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p ell_width is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_descr, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p ell_descr, \\p ell_val or\n              \\p ell_col_ind pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example converts a CSR matrix into an ELL matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 5;\n      rocsparse_int nnz = 8;\n\n      csr_row_ptr[m+1] = {0, 3, 5, 8};             // device memory\n      csr_col_ind[nnz] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      csr_val[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8}; // device memory\n\n      // Create ELL matrix descriptor\n      rocsparse_mat_descr ell_descr;\n      rocsparse_create_mat_descr(&ell_descr);\n\n      // Obtain the ELL width\n      rocsparse_int ell_width;\n      rocsparse_csr2ell_width(handle,\n                              m,\n                              csr_descr,\n                              csr_row_ptr,\n                              ell_descr,\n                              &ell_width);\n\n      // Compute ELL non-zero entries\n      rocsparse_int ell_nnz = m * ell_width;\n\n      // Allocate ELL column and value arrays\n      rocsparse_int* ell_col_ind;\n      hipMalloc((void**)&ell_col_ind, sizeof(rocsparse_int) * ell_nnz);\n\n      float* ell_val;\n      hipMalloc((void**)&ell_val, sizeof(float) * ell_nnz);\n\n      // Format conversion\n      rocsparse_scsr2ell(handle,\n                         m,\n                         csr_descr,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind,\n                         ell_descr,\n                         ell_width,\n                         ell_val,\n                         ell_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *mut f32,
        ell_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *mut f64,
        ell_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *mut rocsparse_float_complex,
        ell_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2ell(
        handle: rocsparse_handle,
        m: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *mut rocsparse_double_complex,
        ell_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse HYB matrix\n\n  \\details\n  \\p rocsparse_csr2hyb converts a CSR matrix into a HYB matrix. It is assumed\n  that \\p hyb has been initialized with rocsparse_create_hyb_mat().\n\n  \\note\n  This function requires a significant amount of storage for the HYB matrix,\n  depending on the matrix structure.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSR matrix.\n  @param[in]\n  n               number of columns of the sparse CSR matrix.\n  @param[in]\n  descr           descriptor of the sparse CSR matrix. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val         array containing the values of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr     array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix.\n  @param[in]\n  csr_col_ind     array containing the column indices of the sparse CSR matrix.\n  @param[out]\n  hyb             sparse matrix in HYB format.\n  @param[in]\n  user_ell_width  width of the ELL part of the HYB matrix (only required if\n                  \\p partition_type == \\ref rocsparse_hyb_partition_user).\n  @param[in]\n  partition_type  \\ref rocsparse_hyb_partition_auto (recommended),\n                  \\ref rocsparse_hyb_partition_user or\n                  \\ref rocsparse_hyb_partition_max.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p user_ell_width is invalid.\n  \\retval     rocsparse_status_invalid_value \\p partition_type is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p hyb, \\p csr_val,\n              \\p csr_row_ptr or \\p csr_col_ind pointer is invalid.\n  \\retval     rocsparse_status_memory_error the buffer for the HYB matrix could not be\n              allocated.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example converts a CSR matrix into a HYB matrix using user defined partitioning.\n  \\code{.c}\n      // Create HYB matrix structure\n      rocsparse_hyb_mat hyb;\n      rocsparse_create_hyb_mat(&hyb);\n\n      // User defined ell width\n      rocsparse_int user_ell_width = 5;\n\n      // Perform the conversion\n      rocsparse_scsr2hyb(handle,\n                         m,\n                         n,\n                         descr,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind,\n                         hyb,\n                         user_ell_width,\n                         rocsparse_hyb_partition_user);\n\n      // Do some work\n\n      // Clean up\n      rocsparse_destroy_hyb_mat(hyb);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2hyb(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        hyb: rocsparse_hyb_mat,
        user_ell_width: rocsparse_int,
        partition_type: rocsparse_hyb_partition,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2hyb(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        hyb: rocsparse_hyb_mat,
        user_ell_width: rocsparse_int,
        partition_type: rocsparse_hyb_partition,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2hyb(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        hyb: rocsparse_hyb_mat,
        user_ell_width: rocsparse_int,
        partition_type: rocsparse_hyb_partition,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2hyb(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        hyb: rocsparse_hyb_mat,
        user_ell_width: rocsparse_int,
        partition_type: rocsparse_hyb_partition,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse\n  BSR matrix given a sparse CSR matrix as input.\n\n  \\details\n  The routine does support asynchronous execution if the pointer mode is set to device.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n\n  @param[in]\n  csr_descr    descriptor of the sparse CSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_row_ptr integer array containing \\p m+1 elements that point to the start of each row of the CSR matrix\n\n  @param[in]\n  csr_col_ind integer array of the column indices for each non-zero element in the CSR matrix\n\n  @param[in]\n  block_dim   the block dimension of the BSR matrix. Between 1 and min(m, n)\n\n  @param[in]\n  bsr_descr    descriptor of the sparse BSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_row_ptr integer array containing \\p mb+1 elements that point to the start of each block row of the BSR matrix\n\n  @param[out]\n  bsr_nnz     total number of nonzero elements in device or host memory.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr or \\p csr_col_ind or \\p bsr_row_ptr or \\p bsr_nnz\n              pointer is invalid."]
    pub fn rocsparse_csr2bsr_nnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_nnz: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse BSR matrix\n\n  \\details\n  \\p rocsparse_csr2bsr converts a CSR matrix into a BSR matrix. It is assumed,\n  that \\p bsr_val, \\p bsr_col_ind and \\p bsr_row_ptr are allocated. Allocation size\n  for \\p bsr_row_ptr is computed as \\p mb+1 where \\p mb is the number of block rows in\n  the BSR matrix. Allocation size for \\p bsr_val and \\p bsr_col_ind is computed using\n  \\p csr2bsr_nnz() which also fills in \\p bsr_row_ptr.\n\n  \\p rocsparse_csr2bsr requires extra temporary storage that is allocated internally if \\p block_dim>16\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  dir          the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n  @param[in]\n  m            number of rows in the sparse CSR matrix.\n  @param[in]\n  n            number of columns in the sparse CSR matrix.\n  @param[in]\n  csr_descr    descriptor of the sparse CSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val      array of \\p nnz elements containing the values of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr  array of \\p m+1 elements that point to the start of every row of the\n               sparse CSR matrix.\n  @param[in]\n  csr_col_ind  array of \\p nnz elements containing the column indices of the sparse CSR matrix.\n  @param[in]\n  block_dim    size of the blocks in the sparse BSR matrix.\n  @param[in]\n  bsr_descr    descriptor of the sparse BSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_val      array of \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[out]\n  bsr_row_ptr  array of \\p mb+1 elements that point to the start of every block row of the\n               sparse BSR matrix.\n  @param[out]\n  bsr_col_ind  array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p csr_val, \\p csr_row_ptr or\n              \\p csr_col_ind pointer is invalid.\n\n  \\par Example\n  This example converts a CSR matrix into an BSR matrix.\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      rocsparse_int m   = 4;\n      rocsparse_int n   = 6;\n      rocsparse_int block_dim = 2;\n      rocsparse_int nnz = 9;\n      rocsparse_int mb = (m + block_dim - 1) / block_dim;\n      rocsparse_int nb = (n + block_dim - 1) / block_dim;\n\n      csr_row_ptr[m+1]  = {0, 2, 4, 7, 9};             // device memory\n      csr_col_ind[nnz]  = {0, 1, 1, 2, 0, 3, 4, 2, 4}; // device memory\n      csr_val[nnz]      = {1, 4, 2, 3, 5, 7, 8, 9, 6}; // device memory\n\n      hipMalloc(&bsr_row_ptr, sizeof(rocsparse_int) *(mb + 1));\n      rocsparse_int nnzb;\n      rocsparse_int* nnzTotalHostPtr = &nnzb;\n      csr2bsr_nnz(handle,\n                  rocsparse_direction_row,\n                  m,\n                  n,\n                  csr_descr,\n                  csr_row_ptr,\n                  csr_col_ind,\n                  block_dim,\n                  bsr_descr,\n                  bsr_row_ptr,\n                  nnzTotalHostPtr);\n      nnzb = *nnzTotalDevHostPtr;\n      hipMalloc(&bsr_col_ind, sizeof(int)*nnzb);\n      hipMalloc(&bsr_val, sizeof(float)*(block_dim * block_dim) * nnzb);\n      scsr2bsr(handle,\n               rocsparse_direction_row,\n               m,\n               n,\n               csr_descr,\n               csr_val,\n               csr_row_ptr,\n               csr_col_ind,\n               block_dim,\n               bsr_descr,\n               bsr_val,\n               bsr_row_ptr,\n               bsr_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2bsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f32,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2bsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f64,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2bsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_float_complex,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2bsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_double_complex,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Pads a value to the diagonal of the last block (if the last block is a diagonal block) in the sparse BSR matrix\n  when the matrix expands outside m x m\n\n  \\details When converting from a CSR matrix to a BSR matrix the resulting BSR matrix will be larger when m < mb * block_dim.\n  In these situations, the CSR to BSR conversion will expand the BSR matrix to have zeros when outside m x m. This routine\n  converts the resulting BSR matrix to one that has a value on the last diagonal blocks diagonal if this last block is a diagonal\n  block in the BSR matrix.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse BSR matrix.\n  @param[in]\n  mb          number of block rows of the sparse BSR matrix.\n  @param[in]\n  nnzb        number of non-zero blocks of the sparse BSR matrix.\n  @param[in]\n  block_dim   block dimension of the sparse BSR matrix.\n  @param[in]\n  value       scalar value that is set on the diagonal of the last block when the matrix expands outside of \\p m x \\p m\n  @param[in]\n  bsr_descr   descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[inout]\n  bsr_val     array of \\p nnzb blocks of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of\n              the sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse\n              BSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p mb, \\p nnzb or \\p block_dim is\n              invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_descr, \\p bsr_val,\n              \\p bsr_row_ind, \\p bsr_col_ind, pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sbsrpad_value(
        handle: rocsparse_handle,
        m: rocsparse_int,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        block_dim: rocsparse_int,
        value: f32,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsrpad_value(
        handle: rocsparse_handle,
        m: rocsparse_int,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        block_dim: rocsparse_int,
        value: f64,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsrpad_value(
        handle: rocsparse_handle,
        m: rocsparse_int,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        block_dim: rocsparse_int,
        value: rocsparse_float_complex,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsrpad_value(
        handle: rocsparse_handle,
        m: rocsparse_int,
        mb: rocsparse_int,
        nnzb: rocsparse_int,
        block_dim: rocsparse_int,
        value: rocsparse_double_complex,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  \\details\n  \\p rocsparse_csr2gebsr_buffer_size returns the size of the temporary buffer that\n  is required by \\p rocsparse_csr2gebcsr_nnz, \\p rocsparse_scsr2gebcsr, \\p rocsparse_dcsr2gebsr,\n  \\p rocsparse_ccsr2gebsr and \\p rocsparse_zcsr2gebsr. The temporary storage buffer must be\n  allocated by the user.\n\n  This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse\n  GEneral BSR matrix given a sparse CSR matrix as input.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n\n  @param[in]\n  csr_descr    descriptor of the sparse CSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n\n  @param[in]\n  csr_val      array of \\p nnz elements containing the values of the sparse CSR matrix.\n\n  @param[in]\n  csr_row_ptr  integer array containing \\p m+1 elements that point to the start of each row of the CSR matrix\n\n  @param[in]\n  csr_col_ind  integer array of the column indices for each non-zero element in the CSR matrix\n\n  @param[in]\n  row_block_dim   the row block dimension of the GEneral BSR matrix. Between 1 and \\p m\n\n  @param[in]\n  col_block_dim   the col block dimension of the GEneral BSR matrix. Between 1 and \\p n\n\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer required by \\p rocsparse_csr2gebsr_nnz and \\p rocsparse_Xcsr2gebsr.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p row_block_dim  \\p col_block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_val or \\p csr_row_ptr or \\p csr_col_ind or \\p bsr_row_ptr or \\p buffer_size\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_scsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the number of nonzero block columns per row and the total number of nonzero blocks in a sparse\n  GEneral BSR matrix given a sparse CSR matrix as input.\n\n  \\details\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         direction that specified whether to count nonzero elements by \\ref rocsparse_direction_row or by\n              \\ref rocsparse_direction_row.\n\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n\n  @param[in]\n  n           number of columns of the sparse CSR matrix.\n\n  @param[in]\n  csr_descr    descriptor of the sparse CSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_row_ptr integer array containing \\p m+1 elements that point to the start of each row of the CSR matrix\n\n  @param[in]\n  csr_col_ind integer array of the column indices for each non-zero element in the CSR matrix\n\n  @param[in]\n  bsr_descr    descriptor of the sparse GEneral BSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_row_ptr integer array containing \\p mb+1 elements that point to the start of each block row of the General BSR matrix\n\n  @param[in]\n  row_block_dim   the row block dimension of the GEneral BSR matrix. Between 1 and min(m, n)\n\n  @param[in]\n  col_block_dim   the col block dimension of the GEneral BSR matrix. Between 1 and min(m, n)\n\n  @param[out]\n  bsr_nnz_devhost  total number of nonzero elements in device or host memory.\n\n  @param[in]\n  temp_buffer    buffer allocated by the user whose size is determined by calling \\p rocsparse_xcsr2gebsr_buffer_size.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p row_block_dim \\p col_block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr or \\p csr_col_ind or \\p bsr_row_ptr or \\p bsr_nnz_devhost\n              pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_csr2gebsr_nnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_row_ptr: *mut rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        bsr_nnz_devhost: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a sparse GEneral BSR matrix\n\n  \\details\n  \\p rocsparse_csr2gebsr converts a CSR matrix into a GEneral BSR matrix. It is assumed,\n  that \\p bsr_val, \\p bsr_col_ind and \\p bsr_row_ptr are allocated. Allocation size\n  for \\p bsr_row_ptr is computed as \\p mb+1 where \\p mb is the number of block rows in\n  the GEneral BSR matrix. Allocation size for \\p bsr_val and \\p bsr_col_ind is computed using\n  \\p csr2gebsr_nnz() which also fills in \\p bsr_row_ptr.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  dir          the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n  @param[in]\n  m            number of rows in the sparse CSR matrix.\n  @param[in]\n  n            number of columns in the sparse CSR matrix.\n  @param[in]\n  csr_descr    descriptor of the sparse CSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val      array of \\p nnz elements containing the values of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr  array of \\p m+1 elements that point to the start of every row of the\n               sparse CSR matrix.\n  @param[in]\n  csr_col_ind  array of \\p nnz elements containing the column indices of the sparse CSR matrix.\n  @param[in]\n  bsr_descr    descriptor of the sparse BSR matrix. Currently, only\n               \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  bsr_val      array of \\p nnzb* \\p row_block_dim* \\p col_block_dim containing the values of the sparse BSR matrix.\n  @param[out]\n  bsr_row_ptr  array of \\p mb+1 elements that point to the start of every block row of the\n               sparse BSR matrix.\n  @param[out]\n  bsr_col_ind  array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  row_block_dim    row size of the blocks in the sparse GEneral BSR matrix.\n  @param[in]\n  col_block_dim    col size of the blocks in the sparse GEneral BSR matrix.\n  @param[in]\n  temp_buffer    buffer allocated by the user whose size is determined by calling \\p rocsparse_xcsr2gebsr_buffer_size.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p row_block_dim or \\p col_block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p csr_val, \\p csr_row_ptr or\n              \\p csr_col_ind pointer is invalid.\n\n  \\par Example\n  This example converts a CSR matrix into an BSR matrix.\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      rocsparse_int m   = 4;\n      rocsparse_int n   = 6;\n      rocsparse_int row_block_dim = 2;\n      rocsparse_int col_block_dim = 3;\n      rocsparse_int nnz = 9;\n      rocsparse_int mb = (m + row_block_dim - 1) / row_block_dim;\n      rocsparse_int nb = (n + col_block_dim - 1) / col_block_dim;\n\n      csr_row_ptr[m+1]  = {0, 2, 4, 7, 9};             // device memory\n      csr_col_ind[nnz]  = {0, 1, 1, 2, 0, 3, 4, 2, 4}; // device memory\n      csr_val[nnz]      = {1, 4, 2, 3, 5, 7, 8, 9, 6}; // device memory\n\n      hipMalloc(&bsr_row_ptr, sizeof(rocsparse_int) *(mb + 1));\n      rocsparse_int nnzb;\n      rocsparse_int* nnzTotalHostPtr = &nnzb;\n      csr2gebsr_nnz(handle,\n                  rocsparse_direction_row,\n                  m,\n                  n,\n                  csr_descr,\n                  csr_row_ptr,\n                  csr_col_ind,\n                  row_block_dim,\n                  col_block_dim,\n                  bsr_descr,\n                  bsr_row_ptr,\n                  nnzTotalHostPtr);\n      nnzb = *nnzTotalHostPtr;\n      hipMalloc(&bsr_col_ind, sizeof(int)*nnzb);\n      hipMalloc(&bsr_val, sizeof(float)*(row_block_dim * col_block_dim) * nnzb);\n      scsr2gebsr(handle,\n               rocsparse_direction_row,\n               m,\n               n,\n               csr_descr,\n               csr_val,\n               csr_row_ptr,\n               csr_col_ind,\n               row_block_dim,\n               col_block_dim,\n               bsr_descr,\n               bsr_val,\n               bsr_row_ptr,\n               bsr_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f32,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut f64,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_float_complex,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        m: rocsparse_int,
        n: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *mut rocsparse_double_complex,
        bsr_row_ptr: *mut rocsparse_int,
        bsr_col_ind: *mut rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse CSR matrix into a compressed sparse CSR matrix\n\n  \\details\n  \\p rocsparse_csr2csr_compress converts a CSR matrix into a compressed CSR matrix by\n  removing entries in the input CSR matrix that are below a non-negative threshold \\p tol\n\n  \\note\n  In the case of complex matrices only the magnitude of the real part of \\p tol is used.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows of the sparse CSR matrix.\n  @param[in]\n  n             number of columns of the sparse CSR matrix.\n  @param[in]\n  descr_A       matrix descriptor for the CSR matrix\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                uncompressed sparse CSR matrix.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the uncompressed\n                sparse CSR matrix.\n  @param[in]\n  nnz_A         number of elements in the column indices and values arrays of the uncompressed\n                sparse CSR matrix.\n  @param[in]\n  nnz_per_row   array of length \\p m containing the number of entries that will be kept per row in\n                the final compressed CSR matrix.\n  @param[out]\n  csr_val_C     array of \\p nnz_C elements of the compressed sparse CSC matrix.\n  @param[out]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every column of the compressed\n                sparse CSR matrix.\n  @param[out]\n  csr_col_ind_C array of \\p nnz_C elements containing the row indices of the compressed\n                sparse CSR matrix.\n  @param[in]\n  tol           the non-negative tolerance used for compression. If \\p tol is complex then only the magnitude\n                of the real part is used. Entries in the input uncompressed CSR array that are below the tolerance\n                are removed in output compressed CSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz_A is invalid.\n  \\retval     rocsparse_status_invalid_value \\p tol is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_val_A, \\p csr_row_ptr_A,\n              \\p csr_col_ind_A, \\p csr_val_C, \\p csr_row_ptr_C, \\p csr_col_ind_C or\n              \\p nnz_per_row pointer is invalid.\n\n  \\par Example\n  This example demonstrates how to compress a CSR matrix. Compressing a CSR matrix involves two steps. First we use\n  nnz_compress() to determine how many entries will be in the final compressed CSR matrix. Then we call csr2csr_compress()\n  to finish the compression and fill in the column indices and values arrays of the compressed CSR matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      float tol = 0.0f;\n\n      rocsparse_int m     = 3;\n      rocsparse_int n     = 5;\n      rocsparse_int nnz_A = 8;\n\n      csr_row_ptr_A[m+1]   = {0, 3, 5, 8};             // device memory\n      csr_col_ind_A[nnz_A] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      csr_val_A[nnz_A]     = {1, 0, 3, 4, 0, 6, 7, 0}; // device memory\n\n      // Allocate memory for the row pointer array of the compressed CSR matrix\n      rocsparse_int* csr_row_ptr_C;\n      hipMalloc(csr_row_ptr_C, sizeof(rocsparse_int) * (m + 1));\n\n      // Allocate memory for the nnz_per_row array\n      rocsparse_int* nnz_per_row;\n      hipMalloc(nnz_per_row, sizeof(rocsparse_int) * m);\n\n      // Call nnz_compress() which fills in nnz_per_row array and finds the number\n      // of entries that will be in the compressed CSR matrix\n      rocsparse_int nnz_C;\n      nnz_compress(handle,\n                   m,\n                   descr_A,\n                   csr_val_A,\n                   csr_row_ptr_A,\n                   nnz_per_row,\n                   &nnz_C,\n                   tol);\n\n      // Allocate column indices and values array for the compressed CSR matrix\n      rocsparse_int* csr_col_ind_C;\n      rocsparse_int* csr_val_C;\n      hipMalloc(csr_col_ind_C, sizeof(rocsparse_int) * nnz_C;\n      hipMalloc(csr_val_C, sizeof(rocsparse_int) * nnz_C;\n\n      // Finish compression by calling csr2csr_compress()\n      csr2csr_compress(handle,\n                       m,\n                       n,\n                       descr_A,\n                       csr_val_A,\n                       csr_row_ptr_A,\n                       csr_col_ind_A,\n                       nnz_A,\n                       nnz_per_row,\n                       csr_val_C,\n                       csr_row_ptr_C,\n                       csr_col_ind_C,\n                       tol);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_scsr2csr_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        nnz_A: rocsparse_int,
        nnz_per_row: *const rocsparse_int,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *mut rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        tol: f32,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsr2csr_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        nnz_A: rocsparse_int,
        nnz_per_row: *const rocsparse_int,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *mut rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        tol: f64,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsr2csr_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const rocsparse_float_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        nnz_A: rocsparse_int,
        nnz_per_row: *const rocsparse_int,
        csr_val_C: *mut rocsparse_float_complex,
        csr_row_ptr_C: *mut rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        tol: rocsparse_float_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsr2csr_compress(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        csr_val_A: *const rocsparse_double_complex,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        nnz_A: rocsparse_int,
        nnz_per_row: *const rocsparse_int,
        csr_val_C: *mut rocsparse_double_complex,
        csr_row_ptr_C: *mut rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        tol: rocsparse_double_complex,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_prune_csr2csr_buffer_size returns the size of the temporary buffer that\n  is required by \\p rocsparse_sprune_csr2csr_nnz, \\p rocsparse_dprune_csr2csr_nnz,\n  \\p rocsparse_sprune_csr2csr, and \\p rocsparse_dprune_csr2csr. The temporary storage\n  buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  threshold     pointer to the non-negative pruning threshold which can exist in either host or device memory.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_C     array of \\p nnz_C elements containing the values of the sparse CSR matrix C.\n  @param[in]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[in]\n  csr_col_ind_C array of \\p nnz_C elements containing the column indices of the sparse CSR matrix C.\n  @param[out]\n  buffer_size   number of bytes of the temporary storage buffer required by \\p rocsparse_sprune_csr2csr_nnz,\n                \\p rocsparse_dprune_csr2csr_nnz, \\p rocsparse_sprune_csr2csr, and \\p rocsparse_dprune_csr2csr.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *const f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *const f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_prune_csr2csr_nnz computes the number of nonzero elements per row and the total\n  number of nonzero elements in a sparse CSR matrix once elements less than the threshold are\n  pruned from the matrix.\n\n  \\note The routine does support asynchronous execution if the pointer mode is set to device.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  threshold     pointer to the non-negative pruning threshold which can exist in either host or device memory.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[out]\n  nnz_total_dev_host_ptr total number of nonzero elements in device or host memory.\n  @param[out]\n  temp_buffer   buffer allocated by the user whose size is determined by calling \\p rocsparse_xprune_csr2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p nnz_A is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p threshold or \\p csr_descr_A or \\p csr_descr_C or \\p csr_val_A\n              or \\p csr_row_ptr_A or \\p csr_col_ind_A or \\p csr_row_ptr_C or \\p nnz_total_dev_host_ptr\n              or \\p temp_buffer pointer is invalid.\n\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A\n  that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.\n  The user first calls rocsparse_xprune_csr2csr_buffer_size() to determine the size of the buffer used\n  by rocsparse_xprune_csr2csr_nnz() and rocsparse_xprune_csr2csr() which the user then allocates. The user then\n  allocates \\p csr_row_ptr_C to have \\p m+1 elements and then calls rocsparse_xprune_csr2csr_nnz() which fills\n  in the \\p csr_row_ptr_C array stores then number of elements that are larger than the pruning threshold\n  in \\p nnz_total_dev_host_ptr. The user then calls rocsparse_xprune_csr2csr() to complete the conversion.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  threshold     pointer to the non-negative pruning threshold which can exist in either host or device memory.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val_C     array of \\p nnz_C elements containing the values of the sparse CSR matrix C.\n  @param[in]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[out]\n  csr_col_ind_C array of \\p nnz_C elements containing the column indices of the sparse CSR matrix C.\n  @param[in]\n  temp_buffer   buffer allocated by the user whose size is determined by calling \\p rocsparse_xprune_csr2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p nnz_A is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p threshold or \\p csr_descr_A or \\p csr_descr_C or \\p csr_val_A\n              or \\p csr_row_ptr_A or \\p csr_col_ind_A or \\p csr_val_C or \\p csr_row_ptr_C or \\p csr_col_ind_C\n              or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        threshold: *const f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_prune_csr2csr__by_percentage_buffer_size returns the size of the temporary buffer that\n  is required by \\p rocsparse_sprune_csr2csr_nnz_by_percentage, \\p rocsparse_dprune_csr2csr_nnz_by_percentage,\n  \\p rocsparse_sprune_csr2csr_by_percentage, and \\p rocsparse_dprune_csr2csr_by_percentage. The temporary storage\n  buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  percentage     percentage >= 0 and percentage <= 100.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_C     array of \\p nnz_C elements containing the values of the sparse CSR matrix C.\n  @param[in]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[in]\n  csr_col_ind_C array of \\p nnz_C elements containing the column indices of the sparse CSR matrix C.\n  @param[in]\n  info          prune info structure.\n  @param[out]\n  buffer_size   number of bytes of the temporary storage buffer required by \\p rocsparse_sprune_csr2csr_nnz_by_percentage,\n                \\p rocsparse_dprune_csr2csr_nnz_by_percentage, \\p rocsparse_sprune_csr2csr_by_percentage,\n                and \\p rocsparse_dprune_csr2csr_by_percentage.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr_by_percentage_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *const f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr_by_percentage_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *const f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *const rocsparse_int,
        info: rocsparse_mat_info,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_prune_csr2csr_nnz_by_percentage computes the number of nonzero elements per row and the total\n  number of nonzero elements in a sparse CSR matrix once elements less than the threshold are\n  pruned from the matrix.\n\n  \\note The routine does support asynchronous execution if the pointer mode is set to device.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  percentage    percentage >= 0 and percentage <= 100.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[out]\n  nnz_total_dev_host_ptr total number of nonzero elements in device or host memory.\n  @param[in]\n  info          prune info structure.\n  @param[out]\n  temp_buffer   buffer allocated by the user whose size is determined by calling\n                \\p rocsparse_xprune_csr2csr_by_percentage_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p nnz_A or \\p percentage is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_descr_A or \\p csr_descr_C or \\p info or \\p csr_val_A\n              or \\p csr_row_ptr_A or \\p csr_col_ind_A or \\p csr_row_ptr_C or \\p nnz_total_dev_host_ptr\n              or \\p temp_buffer pointer is invalid.\n\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr_nnz_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr_nnz_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_row_ptr_C: *mut rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert and prune by percentage a sparse CSR matrix into a sparse CSR matrix\n\n  \\details\n  This function converts the sparse CSR matrix A into a sparse CSR matrix C by pruning values in A\n  that are less than the threshold. All the parameters are assumed to have been pre-allocated by the user.\n  The user first calls rocsparse_xprune_csr2csr_buffer_size() to determine the size of the buffer used\n  by rocsparse_xprune_csr2csr_nnz() and rocsparse_xprune_csr2csr() which the user then allocates. The user then\n  allocates \\p csr_row_ptr_C to have \\p m+1 elements and then calls rocsparse_xprune_csr2csr_nnz() which fills\n  in the \\p csr_row_ptr_C array stores then number of elements that are larger than the pruning threshold\n  in \\p nnz_total_dev_host_ptr. The user then calls rocsparse_xprune_csr2csr() to complete the conversion.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle        handle to the rocsparse library context queue.\n  @param[in]\n  m             number of rows in the sparse CSR matrix.\n  @param[in]\n  n             number of columns in the sparse CSR matrix.\n  @param[in]\n  nnz_A         number of non-zeros in the sparse CSR matrix A.\n  @param[in]\n  csr_descr_A   descriptor of the sparse CSR matrix A. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_val_A     array of \\p nnz_A elements containing the values of the sparse CSR matrix A.\n  @param[in]\n  csr_row_ptr_A array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix A.\n  @param[in]\n  csr_col_ind_A array of \\p nnz_A elements containing the column indices of the sparse CSR matrix A.\n  @param[in]\n  percentage    percentage >= 0 and percentage <= 100.\n  @param[in]\n  csr_descr_C   descriptor of the sparse CSR matrix C. Currently, only\n                \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val_C     array of \\p nnz_C elements containing the values of the sparse CSR matrix C.\n  @param[in]\n  csr_row_ptr_C array of \\p m+1 elements that point to the start of every row of the\n                sparse CSR matrix C.\n  @param[out]\n  csr_col_ind_C array of \\p nnz_C elements containing the column indices of the sparse CSR matrix C.\n  @param[in]\n  info          prune info structure.\n  @param[in]\n  temp_buffer   buffer allocated by the user whose size is determined by calling \\p rocsparse_xprune_csr2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p n or \\p nnz_A or \\p percentage is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_descr_A or \\p csr_descr_C or \\p info or \\p csr_val_A\n              or \\p csr_row_ptr_A or \\p csr_col_ind_A or \\p csr_val_C or \\p csr_row_ptr_C or \\p csr_col_ind_C\n              or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sprune_csr2csr_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f32,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f32,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f32,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dprune_csr2csr_by_percentage(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz_A: rocsparse_int,
        csr_descr_A: rocsparse_mat_descr,
        csr_val_A: *const f64,
        csr_row_ptr_A: *const rocsparse_int,
        csr_col_ind_A: *const rocsparse_int,
        percentage: f64,
        csr_descr_C: rocsparse_mat_descr,
        csr_val_C: *mut f64,
        csr_row_ptr_C: *const rocsparse_int,
        csr_col_ind_C: *mut rocsparse_int,
        info: rocsparse_mat_info,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse COO matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_coo2csr converts the COO array containing the row indices into a\n  CSR array of row offsets, that point to the start of every row.\n  It is assumed that the COO row index array is sorted.\n\n  \\note It can also be used, to convert a COO array containing the column indices into\n  a CSC array of column offsets, that point to the start of every column. Then, it is\n  assumed that the COO column index array is sorted, instead.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  coo_row_ind array of \\p nnz elements containing the row indices of the sparse COO\n              matrix.\n  @param[in]\n  nnz         number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  m           number of rows of the sparse CSR matrix.\n  @param[out]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  idx_base    \\ref rocsparse_index_base_zero or \\ref rocsparse_index_base_one.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p coo_row_ind or \\p csr_row_ptr\n              pointer is invalid.\n\n  \\par Example\n  This example converts a COO matrix into a CSR matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 5;\n      rocsparse_int nnz = 8;\n\n      coo_row_ind[nnz] = {0, 0, 0, 1, 1, 2, 2, 2}; // device memory\n      coo_col_ind[nnz] = {0, 1, 3, 1, 2, 0, 3, 4}; // device memory\n      coo_val[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8}; // device memory\n\n      // Allocate CSR matrix arrays\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnz);\n\n      // Convert the coo row indices into csr row offsets\n      rocsparse_coo2csr(handle,\n                        coo_row_ind,\n                        nnz,\n                        m,\n                        csr_row_ptr,\n                        rocsparse_index_base_zero);\n\n      // Copy the column and value arrays\n      hipMemcpy(csr_col_ind,\n                coo_col_ind,\n                sizeof(rocsparse_int) * nnz,\n                hipMemcpyDeviceToDevice);\n\n      hipMemcpy(csr_val,\n                coo_val,\n                sizeof(float) * nnz,\n                hipMemcpyDeviceToDevice);\n  \\endcode"]
    pub fn rocsparse_coo2csr(
        handle: rocsparse_handle,
        coo_row_ind: *const rocsparse_int,
        nnz: rocsparse_int,
        m: rocsparse_int,
        csr_row_ptr: *mut rocsparse_int,
        idx_base: rocsparse_index_base,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse ELL matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_ell2csr_nnz computes the total CSR non-zero elements and the CSR\n  row offsets, that point to the start of every row of the sparse CSR matrix, for\n  a given ELL matrix. It is assumed that \\p csr_row_ptr has been allocated with\n  size \\p m+1.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse ELL matrix.\n  @param[in]\n  n           number of columns of the sparse ELL matrix.\n  @param[in]\n  ell_descr   descriptor of the sparse ELL matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  ell_width   number of non-zero elements per row in ELL storage format.\n  @param[in]\n  ell_col_ind array of \\p m times \\p ell_width elements containing the column indices\n              of the sparse ELL matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[out]\n  csr_nnz     pointer to the total number of non-zero elements in CSR storage\n              format.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ell_width is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p ell_descr, \\p ell_col_ind,\n              \\p csr_descr, \\p csr_row_ptr or \\p csr_nnz pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_ell2csr_nnz(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_col_ind: *const rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_row_ptr: *mut rocsparse_int,
        csr_nnz: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse ELL matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_ell2csr converts an ELL matrix into a CSR matrix. It is assumed\n  that \\p csr_row_ptr has already been filled and that \\p csr_val and \\p csr_col_ind\n  are allocated by the user. \\p csr_row_ptr and allocation size of \\p csr_col_ind and\n  \\p csr_val is defined by the number of CSR non-zero elements. Both can be obtained\n  by rocsparse_ell2csr_nnz().\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of the sparse ELL matrix.\n  @param[in]\n  n           number of columns of the sparse ELL matrix.\n  @param[in]\n  ell_descr   descriptor of the sparse ELL matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  ell_width   number of non-zero elements per row in ELL storage format.\n  @param[in]\n  ell_val     array of \\p m times \\p ell_width elements of the sparse ELL matrix.\n  @param[in]\n  ell_col_ind array of \\p m times \\p ell_width elements containing the column indices\n              of the sparse ELL matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val     array containing the values of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[out]\n  csr_col_ind array containing the column indices of the sparse CSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p ell_width is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_descr, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind, \\p ell_descr, \\p ell_val or\n              \\p ell_col_ind pointer is invalid.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example converts an ELL matrix into a CSR matrix.\n  \\code{.c}\n      //     1 2 0 3 0\n      // A = 0 4 5 0 0\n      //     6 0 0 7 8\n\n      rocsparse_int m         = 3;\n      rocsparse_int n         = 5;\n      rocsparse_int nnz       = 9;\n      rocsparse_int ell_width = 3;\n\n      ell_col_ind[nnz] = {0, 1, 0, 1, 2, 3, 3, -1, 4}; // device memory\n      ell_val[nnz]     = {1, 4, 6, 2, 5, 7, 3, 0, 8};  // device memory\n\n      // Create CSR matrix descriptor\n      rocsparse_mat_descr csr_descr;\n      rocsparse_create_mat_descr(&csr_descr);\n\n      // Allocate csr_row_ptr array for row offsets\n      rocsparse_int* csr_row_ptr;\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n\n      // Obtain the number of CSR non-zero entries\n      // and fill csr_row_ptr array with row offsets\n      rocsparse_int csr_nnz;\n      rocsparse_ell2csr_nnz(handle,\n                            m,\n                            n,\n                            ell_descr,\n                            ell_width,\n                            ell_col_ind,\n                            csr_descr,\n                            csr_row_ptr,\n                            &csr_nnz);\n\n      // Allocate CSR column and value arrays\n      rocsparse_int* csr_col_ind;\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * csr_nnz);\n\n      float* csr_val;\n      hipMalloc((void**)&csr_val, sizeof(float) * csr_nnz);\n\n      // Format conversion\n      rocsparse_sell2csr(handle,\n                         m,\n                         n,\n                         ell_descr,\n                         ell_width,\n                         ell_val,\n                         ell_col_ind,\n                         csr_descr,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sell2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *const f32,
        ell_col_ind: *const rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dell2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *const f64,
        ell_col_ind: *const rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cell2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_float_complex,
        ell_col_ind: *const rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zell2csr(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        ell_descr: rocsparse_mat_descr,
        ell_width: rocsparse_int,
        ell_val: *const rocsparse_double_complex,
        ell_col_ind: *const rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse HYB matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_hyb2csr_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_shyb2csr(), rocsparse_dhyb2csr(), rocsparse_chyb2csr() and\n  rocsparse_dhyb2csr(). The temporary storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  descr           descriptor of the sparse HYB matrix. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  hyb             sparse matrix in HYB format.\n  @param[in]\n  csr_row_ptr     array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_shyb2csr(), rocsparse_dhyb2csr(), rocsparse_chyb2csr() and\n                  rocsparse_zhyb2csr().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p hyb, \\p csr_row_ptr or\n              \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general."]
    pub fn rocsparse_hyb2csr_buffer_size(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        csr_row_ptr: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse HYB matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_hyb2csr converts a HYB matrix into a CSR matrix.\n\n  \\p rocsparse_hyb2csr requires extra temporary storage buffer that has to be allocated\n  by the user. Storage buffer size can be determined by\n  rocsparse_hyb2csr_buffer_size().\n\n  \\note\n  This function is blocking with respect to the host.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  descr           descriptor of the sparse HYB matrix. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  hyb             sparse matrix in HYB format.\n  @param[out]\n  csr_val         array containing the values of the sparse CSR matrix.\n  @param[out]\n  csr_row_ptr     array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix.\n  @param[out]\n  csr_col_ind     array containing the column indices of the sparse CSR matrix.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned by\n                  rocsparse_hyb2csr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p hyb, \\p csr_val,\n              \\p csr_row_ptr, \\p csr_col_ind or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  This example converts a HYB matrix into a CSR matrix.\n  \\code{.c}\n      // Create CSR matrix arrays\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnz);\n\n      // Get required size of temporary buffer\n      size_t size;\n      rocsparse_hyb2csr_buffer_size(handle,\n                                    descr,\n                                    hyb,\n                                    csr_row_ptr,\n                                    &size);\n\n      // Allocate temporary buffer\n      void* buffer;\n      hipMalloc(&buffer, size);\n\n      // Perform the conversion\n      rocsparse_shyb2csr(handle,\n                         descr,\n                         hyb,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind,\n                         buffer);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_shyb2csr(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        csr_val: *mut f32,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dhyb2csr(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        csr_val: *mut f64,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_chyb2csr(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zhyb2csr(
        handle: rocsparse_handle,
        descr: rocsparse_mat_descr,
        hyb: rocsparse_hyb_mat,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Create the identity map\n\n  \\details\n  \\p rocsparse_create_identity_permutation stores the identity map in \\p p, such that\n  \\f$p = 0:1:(n-1)\\f$.\n\n  \\code{.c}\n      for(i = 0; i < n; ++i)\n      {\n          p[i] = i;\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  n           size of the map \\p p.\n  @param[out]\n  p           array of \\p n integers containing the map.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p n is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p p pointer is invalid.\n\n  \\par Example\n  The following example creates an identity permutation.\n  \\code{.c}\n      rocsparse_int size = 200;\n\n      // Allocate memory to hold the identity map\n      rocsparse_int* perm;\n      hipMalloc((void**)&perm, sizeof(rocsparse_int) * size);\n\n      // Fill perm with the identity permutation\n      rocsparse_create_identity_permutation(handle, size, perm);\n  \\endcode"]
    pub fn rocsparse_create_identity_permutation(
        handle: rocsparse_handle,
        n: rocsparse_int,
        p: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_csrsort_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_csrsort(). The temporary storage buffer must be allocated by\n  the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSR matrix.\n  @param[in]\n  n               number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr     array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix.\n  @param[in]\n  csr_col_ind     array of \\p nnz elements containing the column indices of the sparse\n                  CSR matrix.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_csrsort().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csr_row_ptr, \\p csr_col_ind or\n              \\p buffer_size pointer is invalid."]
    pub fn rocsparse_csrsort_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_csrsort sorts a matrix in CSR format. The sorted permutation vector\n  \\p perm can be used to obtain sorted \\p csr_val array. In this case, \\p perm must be\n  initialized as the identity permutation, see rocsparse_create_identity_permutation().\n\n  \\p rocsparse_csrsort requires extra temporary storage buffer that has to be allocated by\n  the user. Storage buffer size can be determined by rocsparse_csrsort_buffer_size().\n\n  \\note\n  \\p perm can be \\p NULL if a sorted permutation vector is not required.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSR matrix.\n  @param[in]\n  n               number of columns of the sparse CSR matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse CSR matrix.\n  @param[in]\n  descr           descriptor of the sparse CSR matrix. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csr_row_ptr     array of \\p m+1 elements that point to the start of every row of the\n                  sparse CSR matrix.\n  @param[inout]\n  csr_col_ind     array of \\p nnz elements containing the column indices of the sparse\n                  CSR matrix.\n  @param[inout]\n  perm            array of \\p nnz integers containing the unsorted map indices, can be\n                  \\p NULL.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned by\n                  rocsparse_csrsort_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csr_row_ptr, \\p csr_col_ind\n              or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  The following example sorts a \\f$3 \\times 3\\f$ CSR matrix.\n  \\code{.c}\n      //     1 2 3\n      // A = 4 5 6\n      //     7 8 9\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 3;\n      rocsparse_int nnz = 9;\n\n      csr_row_ptr[m + 1] = {0, 3, 6, 9};                // device memory\n      csr_col_ind[nnz]   = {2, 0, 1, 0, 1, 2, 0, 2, 1}; // device memory\n      csr_val[nnz]       = {3, 1, 2, 4, 5, 6, 7, 9, 8}; // device memory\n\n      // Create permutation vector perm as the identity map\n      rocsparse_int* perm;\n      hipMalloc((void**)&perm, sizeof(rocsparse_int) * nnz);\n      rocsparse_create_identity_permutation(handle, nnz, perm);\n\n      // Allocate temporary buffer\n      size_t buffer_size;\n      void* temp_buffer;\n      rocsparse_csrsort_buffer_size(handle, m, n, nnz, csr_row_ptr, csr_col_ind, &buffer_size);\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Sort the CSR matrix\n      rocsparse_csrsort(handle, m, n, nnz, descr, csr_row_ptr, csr_col_ind, perm, temp_buffer);\n\n      // Gather sorted csr_val array\n      float* csr_val_sorted;\n      hipMalloc((void**)&csr_val_sorted, sizeof(float) * nnz);\n      rocsparse_sgthr(handle, nnz, csr_val, csr_val_sorted, perm, rocsparse_index_base_zero);\n\n      // Clean up\n      hipFree(temp_buffer);\n      hipFree(perm);\n      hipFree(csr_val);\n  \\endcode"]
    pub fn rocsparse_csrsort(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
        perm: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse CSC matrix\n\n  \\details\n  \\p rocsparse_cscsort_buffer_size returns the size of the temporary storage buffer\n  required by rocsparse_cscsort(). The temporary storage buffer must be allocated by\n  the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSC matrix.\n  @param[in]\n  n               number of columns of the sparse CSC matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse CSC matrix.\n  @param[in]\n  csc_col_ptr     array of \\p n+1 elements that point to the start of every column of\n                  the sparse CSC matrix.\n  @param[in]\n  csc_row_ind     array of \\p nnz elements containing the row indices of the sparse\n                  CSC matrix.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_cscsort().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p csc_col_ptr, \\p csc_row_ind or\n              \\p buffer_size pointer is invalid."]
    pub fn rocsparse_cscsort_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse CSC matrix\n\n  \\details\n  \\p rocsparse_cscsort sorts a matrix in CSC format. The sorted permutation vector\n  \\p perm can be used to obtain sorted \\p csc_val array. In this case, \\p perm must be\n  initialized as the identity permutation, see rocsparse_create_identity_permutation().\n\n  \\p rocsparse_cscsort requires extra temporary storage buffer that has to be allocated by\n  the user. Storage buffer size can be determined by rocsparse_cscsort_buffer_size().\n\n  \\note\n  \\p perm can be \\p NULL if a sorted permutation vector is not required.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse CSC matrix.\n  @param[in]\n  n               number of columns of the sparse CSC matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse CSC matrix.\n  @param[in]\n  descr           descriptor of the sparse CSC matrix. Currently, only\n                  \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  csc_col_ptr     array of \\p n+1 elements that point to the start of every column of\n                  the sparse CSC matrix.\n  @param[inout]\n  csc_row_ind     array of \\p nnz elements containing the row indices of the sparse\n                  CSC matrix.\n  @param[inout]\n  perm            array of \\p nnz integers containing the unsorted map indices, can be\n                  \\p NULL.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned by\n                  rocsparse_cscsort_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p descr, \\p csc_col_ptr, \\p csc_row_ind\n              or \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n  \\retval     rocsparse_status_not_implemented\n              \\ref rocsparse_matrix_type != \\ref rocsparse_matrix_type_general.\n\n  \\par Example\n  The following example sorts a \\f$3 \\times 3\\f$ CSC matrix.\n  \\code{.c}\n      //     1 2 3\n      // A = 4 5 6\n      //     7 8 9\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 3;\n      rocsparse_int nnz = 9;\n\n      csc_col_ptr[m + 1] = {0, 3, 6, 9};                // device memory\n      csc_row_ind[nnz]   = {2, 0, 1, 0, 1, 2, 0, 2, 1}; // device memory\n      csc_val[nnz]       = {7, 1, 4, 2, 5, 8, 3, 9, 6}; // device memory\n\n      // Create permutation vector perm as the identity map\n      rocsparse_int* perm;\n      hipMalloc((void**)&perm, sizeof(rocsparse_int) * nnz);\n      rocsparse_create_identity_permutation(handle, nnz, perm);\n\n      // Allocate temporary buffer\n      size_t buffer_size;\n      void* temp_buffer;\n      rocsparse_cscsort_buffer_size(handle, m, n, nnz, csc_col_ptr, csc_row_ind, &buffer_size);\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Sort the CSC matrix\n      rocsparse_cscsort(handle, m, n, nnz, descr, csc_col_ptr, csc_row_ind, perm, temp_buffer);\n\n      // Gather sorted csc_val array\n      float* csc_val_sorted;\n      hipMalloc((void**)&csc_val_sorted, sizeof(float) * nnz);\n      rocsparse_sgthr(handle, nnz, csc_val, csc_val_sorted, perm, rocsparse_index_base_zero);\n\n      // Clean up\n      hipFree(temp_buffer);\n      hipFree(perm);\n      hipFree(csc_val);\n  \\endcode"]
    pub fn rocsparse_cscsort(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csc_col_ptr: *const rocsparse_int,
        csc_row_ind: *mut rocsparse_int,
        perm: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse COO matrix\n\n  \\details\n  \\p coosort_buffer_size returns the size of the temporary storage buffer that is\n  required by rocsparse_coosort_by_row() and rocsparse_coosort_by_column(). The\n  temporary storage buffer has to be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse COO matrix.\n  @param[in]\n  n               number of columns of the sparse COO matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse COO matrix.\n  @param[in]\n  coo_row_ind     array of \\p nnz elements containing the row indices of the sparse\n                  COO matrix.\n  @param[in]\n  coo_col_ind     array of \\p nnz elements containing the column indices of the sparse\n                  COO matrix.\n  @param[out]\n  buffer_size     number of bytes of the temporary storage buffer required by\n                  rocsparse_coosort_by_row() and rocsparse_coosort_by_column().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p coo_row_ind, \\p coo_col_ind or\n              \\p buffer_size pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred."]
    pub fn rocsparse_coosort_buffer_size(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_row_ind: *const rocsparse_int,
        coo_col_ind: *const rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse COO matrix by row\n\n  \\details\n  \\p rocsparse_coosort_by_row sorts a matrix in COO format by row. The sorted\n  permutation vector \\p perm can be used to obtain sorted \\p coo_val array. In this\n  case, \\p perm must be initialized as the identity permutation, see\n  rocsparse_create_identity_permutation().\n\n  \\p rocsparse_coosort_by_row requires extra temporary storage buffer that has to be\n  allocated by the user. Storage buffer size can be determined by\n  rocsparse_coosort_buffer_size().\n\n  \\note\n  \\p perm can be \\p NULL if a sorted permutation vector is not required.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse COO matrix.\n  @param[in]\n  n               number of columns of the sparse COO matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse COO matrix.\n  @param[inout]\n  coo_row_ind     array of \\p nnz elements containing the row indices of the sparse\n                  COO matrix.\n  @param[inout]\n  coo_col_ind     array of \\p nnz elements containing the column indices of the sparse\n                  COO matrix.\n  @param[inout]\n  perm            array of \\p nnz integers containing the unsorted map indices, can be\n                  \\p NULL.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned by\n                  rocsparse_coosort_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p coo_row_ind, \\p coo_col_ind or\n              \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n  \\par Example\n  The following example sorts a \\f$3 \\times 3\\f$ COO matrix by row indices.\n  \\code{.c}\n      //     1 2 3\n      // A = 4 5 6\n      //     7 8 9\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 3;\n      rocsparse_int nnz = 9;\n\n      coo_row_ind[nnz] = {0, 1, 2, 0, 1, 2, 0, 1, 2}; // device memory\n      coo_col_ind[nnz] = {0, 0, 0, 1, 1, 1, 2, 2, 2}; // device memory\n      coo_val[nnz]     = {1, 4, 7, 2, 5, 8, 3, 6, 9}; // device memory\n\n      // Create permutation vector perm as the identity map\n      rocsparse_int* perm;\n      hipMalloc((void**)&perm, sizeof(rocsparse_int) * nnz);\n      rocsparse_create_identity_permutation(handle, nnz, perm);\n\n      // Allocate temporary buffer\n      size_t buffer_size;\n      void* temp_buffer;\n      rocsparse_coosort_buffer_size(handle,\n                                    m,\n                                    n,\n                                    nnz,\n                                    coo_row_ind,\n                                    coo_col_ind,\n                                    &buffer_size);\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Sort the COO matrix\n      rocsparse_coosort_by_row(handle,\n                               m,\n                               n,\n                               nnz,\n                               coo_row_ind,\n                               coo_col_ind,\n                               perm,\n                               temp_buffer);\n\n      // Gather sorted coo_val array\n      float* coo_val_sorted;\n      hipMalloc((void**)&coo_val_sorted, sizeof(float) * nnz);\n      rocsparse_sgthr(handle, nnz, coo_val, coo_val_sorted, perm, rocsparse_index_base_zero);\n\n      // Clean up\n      hipFree(temp_buffer);\n      hipFree(perm);\n      hipFree(coo_val);\n  \\endcode"]
    pub fn rocsparse_coosort_by_row(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
        perm: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Sort a sparse COO matrix by column\n\n  \\details\n  \\p rocsparse_coosort_by_column sorts a matrix in COO format by column. The sorted\n  permutation vector \\p perm can be used to obtain sorted \\p coo_val array. In this\n  case, \\p perm must be initialized as the identity permutation, see\n  rocsparse_create_identity_permutation().\n\n  \\p rocsparse_coosort_by_column requires extra temporary storage buffer that has to be\n  allocated by the user. Storage buffer size can be determined by\n  rocsparse_coosort_buffer_size().\n\n  \\note\n  \\p perm can be \\p NULL if a sorted permutation vector is not required.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle          handle to the rocsparse library context queue.\n  @param[in]\n  m               number of rows of the sparse COO matrix.\n  @param[in]\n  n               number of columns of the sparse COO matrix.\n  @param[in]\n  nnz             number of non-zero entries of the sparse COO matrix.\n  @param[inout]\n  coo_row_ind     array of \\p nnz elements containing the row indices of the sparse\n                  COO matrix.\n  @param[inout]\n  coo_col_ind     array of \\p nnz elements containing the column indices of the sparse\n                  COO matrix.\n  @param[inout]\n  perm            array of \\p nnz integers containing the unsorted map indices, can be\n                  \\p NULL.\n  @param[in]\n  temp_buffer     temporary storage buffer allocated by the user, size is returned by\n                  rocsparse_coosort_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p m, \\p n or \\p nnz is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p coo_row_ind, \\p coo_col_ind or\n              \\p temp_buffer pointer is invalid.\n  \\retval     rocsparse_status_internal_error an internal error occurred.\n\n  \\par Example\n  The following example sorts a \\f$3 \\times 3\\f$ COO matrix by column indices.\n  \\code{.c}\n      //     1 2 3\n      // A = 4 5 6\n      //     7 8 9\n      rocsparse_int m   = 3;\n      rocsparse_int n   = 3;\n      rocsparse_int nnz = 9;\n\n      coo_row_ind[nnz] = {0, 0, 0, 1, 1, 1, 2, 2, 2}; // device memory\n      coo_col_ind[nnz] = {0, 1, 2, 0, 1, 2, 0, 1, 2}; // device memory\n      coo_val[nnz]     = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // device memory\n\n      // Create permutation vector perm as the identity map\n      rocsparse_int* perm;\n      hipMalloc((void**)&perm, sizeof(rocsparse_int) * nnz);\n      rocsparse_create_identity_permutation(handle, nnz, perm);\n\n      // Allocate temporary buffer\n      size_t buffer_size;\n      void* temp_buffer;\n      rocsparse_coosort_buffer_size(handle,\n                                    m,\n                                    n,\n                                    nnz,\n                                    coo_row_ind,\n                                    coo_col_ind,\n                                    &buffer_size);\n      hipMalloc(&temp_buffer, buffer_size);\n\n      // Sort the COO matrix\n      rocsparse_coosort_by_column(handle,\n                                  m,\n                                  n,\n                                  nnz,\n                                  coo_row_ind,\n                                  coo_col_ind,\n                                  perm,\n                                  temp_buffer);\n\n      // Gather sorted coo_val array\n      float* coo_val_sorted;\n      hipMalloc((void**)&coo_val_sorted, sizeof(float) * nnz);\n      rocsparse_sgthr(handle, nnz, coo_val, coo_val_sorted, perm, rocsparse_index_base_zero);\n\n      // Clean up\n      hipFree(temp_buffer);\n      hipFree(perm);\n      hipFree(coo_val);\n  \\endcode"]
    pub fn rocsparse_coosort_by_column(
        handle: rocsparse_handle,
        m: rocsparse_int,
        n: rocsparse_int,
        nnz: rocsparse_int,
        coo_row_ind: *mut rocsparse_int,
        coo_col_ind: *mut rocsparse_int,
        perm: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse BSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_bsr2csr converts a BSR matrix into a CSR matrix. It is assumed,\n  that \\p csr_val, \\p csr_col_ind and \\p csr_row_ptr are allocated. Allocation size\n  for \\p csr_row_ptr is computed by the number of block rows multiplied by the block\n  dimension plus one. Allocation for \\p csr_val and \\p csr_col_ind is computed by the\n  the number of blocks in the BSR matrix multiplied by the block dimension squared.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n  @param[in]\n  mb          number of block rows in the sparse BSR matrix.\n  @param[in]\n  nb          number of block columns in the sparse BSR matrix.\n  @param[in]\n  bsr_descr   descriptor of the sparse BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb*block_dim*block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  block_dim   size of the blocks in the sparse BSR matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val     array of \\p nnzb*block_dim*block_dim elements containing the values of the sparse CSR matrix.\n  @param[out]\n  csr_row_ptr array of \\p m+1 where \\p m=mb*block_dim elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[out]\n  csr_col_ind array of \\p nnzb*block_dim*block_dim elements containing the column indices of the sparse CSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb or \\p nb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p csr_val, \\p csr_row_ptr or\n              \\p csr_col_ind pointer is invalid.\n\n  \\par Example\n  This example converts a BSR matrix into an CSR matrix.\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      rocsparse_int mb   = 2;\n      rocsparse_int nb   = 3;\n      rocsparse_int block_dim = 2;\n      rocsparse_int m = Mb * block_dim;\n      rocsparse_int n = Nb * block_dim;\n\n      bsr_row_ptr[mb+1]                 = {0, 2, 5};                                                    // device memory\n      bsr_col_ind[nnzb]                 = {0, 1, 0, 1, 2};                                              // device memory\n      bsr_val[nnzb*block_dim*block_dim] = {1, 0, 4, 2, 0, 3, 0, 0, 5, 0, 0, 0, 0, 9, 7, 0, 8, 6, 0, 0}; // device memory\n\n      rocsparse_int nnzb = bsr_row_ptr[mb] - bsr_row_ptr[0];\n\n      // Create CSR arrays on device\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnzb * block_dim * block_dim);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnzb * block_dim * block_dim);\n\n      // Create rocsparse handle\n      rocsparse_local_handle handle;\n\n      rocsparse_mat_descr bsr_descr = nullptr;\n      rocsparse_create_mat_descr(&bsr_descr);\n\n      rocsparse_mat_descr csr_descr = nullptr;\n      rocsparse_create_mat_descr(&csr_descr);\n\n      rocsparse_set_mat_index_base(bsr_descr, rocsparse_index_base_zero);\n      rocsparse_set_mat_index_base(csr_descr, rocsparse_index_base_zero);\n\n      // Format conversion\n      rocsparse_sbsr2csr(handle,\n                         rocsparse_direction_column,\n                         mb,\n                         nb,\n                         bsr_descr,\n                         bsr_val,\n                         bsr_row_ptr,\n                         bsr_col_ind,\n                         block_dim,\n                         csr_descr,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sbsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dbsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cbsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zbsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief Convert a sparse general BSR matrix into a sparse CSR matrix\n\n  \\details\n  \\p rocsparse_gebsr2csr converts a BSR matrix into a CSR matrix. It is assumed,\n  that \\p csr_val, \\p csr_col_ind and \\p csr_row_ptr are allocated. Allocation size\n  for \\p csr_row_ptr is computed by the number of block rows multiplied by the block\n  dimension plus one. Allocation for \\p csr_val and \\p csr_col_ind is computed by the\n  the number of blocks in the BSR matrix multiplied by the product of the block dimensions.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  dir         the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n  @param[in]\n  mb          number of block rows in the sparse general BSR matrix.\n  @param[in]\n  nb          number of block columns in the sparse general BSR matrix.\n  @param[in]\n  bsr_descr   descriptor of the sparse general BSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[in]\n  bsr_val     array of \\p nnzb*row_block_dim*col_block_dim containing the values of the sparse BSR matrix.\n  @param[in]\n  bsr_row_ptr array of \\p mb+1 elements that point to the start of every block row of the\n              sparse BSR matrix.\n  @param[in]\n  bsr_col_ind array of \\p nnzb elements containing the block column indices of the sparse BSR matrix.\n  @param[in]\n  row_block_dim   row size of the blocks in the sparse general BSR matrix.\n  @param[in]\n  col_block_dim   column size of the blocks in the sparse general BSR matrix.\n  @param[in]\n  csr_descr   descriptor of the sparse CSR matrix. Currently, only\n              \\ref rocsparse_matrix_type_general is supported.\n  @param[out]\n  csr_val     array of \\p nnzb*row_block_dim*col_block_dim elements containing the values of the sparse CSR matrix.\n  @param[out]\n  csr_row_ptr array of \\p m+1 where \\p m=mb*row_block_dim elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[out]\n  csr_col_ind array of \\p nnzb*block_dim*block_dim elements containing the column indices of the sparse CSR matrix.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb or \\p nb or \\p block_dim is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_val,\n              \\p bsr_row_ptr, \\p bsr_col_ind, \\p csr_val, \\p csr_row_ptr or\n              \\p csr_col_ind pointer is invalid.\n\n  \\par Example\n  This example converts a general BSR matrix into an CSR matrix.\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      rocsparse_int mb   = 2;\n      rocsparse_int nb   = 2;\n      rocsparse_int row_block_dim = 2;\n      rocsparse_int col_block_dim = 3;\n      rocsparse_int m = Mb * row_block_dim;\n      rocsparse_int n = Nb * col_block_dim;\n\n      bsr_row_ptr[mb+1]                 = {0, 1, 3};                                              // device memory\n      bsr_col_ind[nnzb]                 = {0, 0, 1};                                              // device memory\n      bsr_val[nnzb*block_dim*block_dim] = {1, 0, 4, 2, 0, 3, 5, 0, 0, 0, 0, 9, 7, 0, 8, 6, 0, 0}; // device memory\n\n      rocsparse_int nnzb = bsr_row_ptr[mb] - bsr_row_ptr[0];\n\n      // Create CSR arrays on device\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnzb * row_block_dim * col_block_dim);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnzb * row_block_dim * col_block_dim);\n\n      // Create rocsparse handle\n      rocsparse_local_handle handle;\n\n      rocsparse_mat_descr bsr_descr = nullptr;\n      rocsparse_create_mat_descr(&bsr_descr);\n\n      rocsparse_mat_descr csr_descr = nullptr;\n      rocsparse_create_mat_descr(&csr_descr);\n\n      rocsparse_set_mat_index_base(bsr_descr, rocsparse_index_base_zero);\n      rocsparse_set_mat_index_base(csr_descr, rocsparse_index_base_zero);\n\n      // Format conversion\n      rocsparse_sgebsr2csr(handle,\n                         rocsparse_direction_column,\n                         mb,\n                         nb,\n                         bsr_descr,\n                         bsr_val,\n                         bsr_row_ptr,\n                         bsr_col_ind,\n                         row_block_dim,\n                         col_block_dim,\n                         csr_descr,\n                         csr_val,\n                         csr_row_ptr,\n                         csr_col_ind);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_sgebsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const f32,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f32,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const f64,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut f64,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_float_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_float_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsr2csr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        bsr_descr: rocsparse_mat_descr,
        bsr_val: *const rocsparse_double_complex,
        bsr_row_ptr: *const rocsparse_int,
        bsr_col_ind: *const rocsparse_int,
        row_block_dim: rocsparse_int,
        col_block_dim: rocsparse_int,
        csr_descr: rocsparse_mat_descr,
        csr_val: *mut rocsparse_double_complex,
        csr_row_ptr: *mut rocsparse_int,
        csr_col_ind: *mut rocsparse_int,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function computes the the size of the user allocated temporary storage buffer used when converting a sparse\n  general BSR matrix to another sparse general BSR matrix.\n\n  \\details\n  \\p rocsparse_gebsr2gebsr_buffer_size returns the size of the temporary storage buffer\n  that is required by rocsparse_gebsr2gebsr_nnz(), rocsparse_sgebsr2gebsr(), rocsparse_dgebsr2gebsr(),\n  rocsparse_cgebsr2gebsr(), and rocsparse_zgebsr2gebsr(). The temporary\n  storage buffer must be allocated by the user.\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  \\note\n  This routine supports execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n\n  @param[in]\n  mb           number of block rows of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nb           number of block columns of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nnzb         number of blocks in the general BSR sparse matrix \\p A.\n\n  @param[in]\n  descr_A      the descriptor of the general BSR sparse matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  bsr_val_A    array of \\p nnzb*row_block_dim_A*col_block_dim_A containing the values of the sparse general BSR matrix \\p A.\n\n  @param[in]\n  bsr_row_ptr_A array of \\p mb+1 elements that point to the start of every block row of the\n              sparse general BSR matrix \\p A.\n  @param[in]\n  bsr_col_ind_A array of \\p nnzb elements containing the block column indices of the sparse general BSR matrix \\p A.\n\n  @param[in]\n  row_block_dim_A   row size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  col_block_dim_A   column size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  row_block_dim_C   row size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[in]\n  col_block_dim_C   column size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[out]\n  buffer_size number of bytes of the temporary storage buffer required by rocsparse_gebsr2gebsr_nnz(),\n              rocsparse_sgebsr2gebsr(), rocsparse_dgebsr2gebsr(), rocsparse_cgebsr2gebsr(), and rocsparse_zgebsr2gebsr().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb or \\p nb or \\p nnzb or \\p row_block_dim_A or\n              \\p col_block_dim_A or \\p row_block_dim_C or \\p col_block_dim_C is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_row_ptr_A or \\p bsr_col_ind_A\n              or \\p descr_A or \\p buffer_size pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sgebsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const f32,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const f64,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const rocsparse_float_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsr2gebsr_buffer_size(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const rocsparse_double_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief This function is used when converting a general BSR sparse matrix \\p A to another general BSR sparse matrix \\p C.\n  Specifically, this function determines the number of non-zero blocks that will exist in \\p C (stored using either a host\n  or device pointer), and computes the row pointer array for \\p C.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n\n  @param[in]\n  mb           number of block rows of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nb           number of block columns of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nnzb         number of blocks in the general BSR sparse matrix \\p A.\n\n  @param[in]\n  descr_A      the descriptor of the general BSR sparse matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  bsr_row_ptr_A array of \\p mb+1 elements that point to the start of every block row of the\n              sparse general BSR matrix \\p A.\n  @param[in]\n  bsr_col_ind_A array of \\p nnzb elements containing the block column indices of the sparse general BSR matrix \\p A.\n\n  @param[in]\n  row_block_dim_A   row size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  col_block_dim_A   column size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  descr_C      the descriptor of the general BSR sparse matrix \\p C, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  bsr_row_ptr_C array of \\p mb_C+1 elements that point to the start of every block row of the\n              sparse general BSR matrix \\p C where \\p mb_C=(m+row_block_dim_C-1)/row_block_dim_C.\n  @param[in]\n  row_block_dim_C   row size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[in]\n  col_block_dim_C   column size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[out]\n  nnz_total_dev_host_ptr\n              total number of nonzero blocks in general BSR sparse matrix \\p C stored using device or host memory.\n\n  @param[out]\n  temp_buffer\n              buffer allocated by the user whose size is determined by calling rocsparse_xgebsr2gebsr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb or \\p nb or \\p nnzb or \\p row_block_dim_A or\n              \\p col_block_dim_A or \\p row_block_dim_C or \\p col_block_dim_C is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_row_ptr_A or \\p bsr_col_ind_A\n              or \\p bsr_row_ptr_C or \\p descr_A or \\p descr_C or \\p temp_buffer pointer is invalid."]
    pub fn rocsparse_gebsr2gebsr_nnz(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_row_ptr_C: *mut rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        nnz_total_dev_host_ptr: *mut rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup conv_module\n  \\brief\n  This function converts the general BSR sparse matrix \\p A to another general BSR sparse matrix \\p C.\n\n  \\details\n  The conversion uses three steps. First, the user calls rocsparse_xgebsr2gebsr_buffer_size() to determine the size of\n  the required temporary storage buffer. The user then allocates this buffer. Secondly, the user then allocates \\p mb_C+1\n  integers for the row pointer array for \\p C where \\p mb_C=(m+row_block_dim_C-1)/row_block_dim_C. The user then calls\n  rocsparse_xgebsr2gebsr_nnz() to fill in the row pointer array for \\p C ( \\p bsr_row_ptr_C ) and determine the number of\n  non-zero blocks that will exist in \\p C. Finally, the user allocates space for the colimn indices array of \\p C to have\n  \\p nnzb_C elements and space for the values array of \\p C to have \\p nnzb_C*roc_block_dim_C*col_block_dim_C and then calls\n  rocsparse_xgebsr2gebsr() to complete the conversion.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n\n  @param[in]\n  dir         the storage format of the blocks, \\ref rocsparse_direction_row or \\ref rocsparse_direction_column\n\n  @param[in]\n  mb           number of block rows of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nb           number of block columns of the general BSR sparse matrix \\p A.\n\n  @param[in]\n  nnzb         number of blocks in the general BSR sparse matrix \\p A.\n\n  @param[in]\n  descr_A      the descriptor of the general BSR sparse matrix \\p A, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  bsr_val_A    array of \\p nnzb*row_block_dim_A*col_block_dim_A containing the values of the sparse general BSR matrix \\p A.\n\n  @param[in]\n  bsr_row_ptr_A array of \\p mb+1 elements that point to the start of every block row of the\n              sparse general BSR matrix \\p A.\n  @param[in]\n  bsr_col_ind_A array of \\p nnzb elements containing the block column indices of the sparse general BSR matrix \\p A.\n\n  @param[in]\n  row_block_dim_A   row size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  col_block_dim_A   column size of the blocks in the sparse general BSR matrix \\p A.\n\n  @param[in]\n  descr_C      the descriptor of the general BSR sparse matrix \\p C, the supported matrix type is rocsparse_matrix_type_general and also any valid value of the \\ref rocsparse_index_base.\n\n  @param[in]\n  bsr_val_C    array of \\p nnzb_C*row_block_dim_C*col_block_dim_C containing the values of the sparse general BSR matrix \\p C.\n\n  @param[in]\n  bsr_row_ptr_C array of \\p mb_C+1 elements that point to the start of every block row of the\n              sparse general BSR matrix \\p C.\n  @param[in]\n  bsr_col_ind_C array of \\p nnzb_C elements containing the block column indices of the sparse general BSR matrix \\p C.\n\n  @param[in]\n  row_block_dim_C   row size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[in]\n  col_block_dim_C   column size of the blocks in the sparse general BSR matrix \\p C.\n\n  @param[out]\n  temp_buffer\n              buffer allocated by the user whose size is determined by calling rocsparse_xgebsr2gebsr_buffer_size().\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_size \\p mb or \\p nb or \\p nnzb or \\p row_block_dim_A or\n              \\p col_block_dim_A or \\p row_block_dim_C or \\p col_block_dim_C is invalid.\n  \\retval     rocsparse_status_invalid_pointer \\p bsr_row_ptr_A or \\p bsr_col_ind_A or \\p bsr_val_A\n              or \\p bsr_row_ptr_C or \\p bsr_col_ind_C or \\p bsr_val_C or \\p descr_A or \\p descr_C\n              or \\p temp_buffer pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_sgebsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const f32,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f32,
        bsr_row_ptr_C: *mut rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dgebsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const f64,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut f64,
        bsr_row_ptr_C: *mut rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_cgebsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const rocsparse_float_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_float_complex,
        bsr_row_ptr_C: *mut rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zgebsr2gebsr(
        handle: rocsparse_handle,
        dir: rocsparse_direction,
        mb: rocsparse_int,
        nb: rocsparse_int,
        nnzb: rocsparse_int,
        descr_A: rocsparse_mat_descr,
        bsr_val_A: *const rocsparse_double_complex,
        bsr_row_ptr_A: *const rocsparse_int,
        bsr_col_ind_A: *const rocsparse_int,
        row_block_dim_A: rocsparse_int,
        col_block_dim_A: rocsparse_int,
        descr_C: rocsparse_mat_descr,
        bsr_val_C: *mut rocsparse_double_complex,
        bsr_row_ptr_C: *mut rocsparse_int,
        bsr_col_ind_C: *mut rocsparse_int,
        row_block_dim_C: rocsparse_int,
        col_block_dim_C: rocsparse_int,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Scale a sparse vector and add it to a scaled dense vector.\n\n  \\details\n  \\ref rocsparse_axpby multiplies the sparse vector \\f$x\\f$ with scalar \\f$\\alpha\\f$ and\n  adds the result to the dense vector \\f$y\\f$ that is multiplied with scalar\n  \\f$\\beta\\f$, such that\n\n  \\f[\n      y := \\alpha \\cdot x + \\beta \\cdot y\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          y[x_ind[i]] = alpha * x_val[i] + beta * y[x_ind[i]]\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  alpha       scalar \\f$\\alpha\\f$.\n  @param[in]\n  x           sparse matrix descriptor.\n  @param[in]\n  beta        scalar \\f$\\beta\\f$.\n  @param[inout]\n  y           dense matrix descriptor.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_pointer \\p alpha, \\p x, \\p beta or \\p y pointer is\n          invalid."]
    pub fn rocsparse_axpby(
        handle: rocsparse_handle,
        alpha: *const ::std::os::raw::c_void,
        x: rocsparse_spvec_descr,
        beta: *const ::std::os::raw::c_void,
        y: rocsparse_dnvec_descr,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Gather elements from a dense vector and store them into a sparse vector.\n\n  \\details\n  \\ref rocsparse_gather gathers the elements from the dense vector \\f$y\\f$ and stores\n  them in the sparse vector \\f$x\\f$.\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          x_val[i] = y[x_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  y            dense vector \\f$y\\f$.\n  @param[out]\n  x            sparse vector \\f$x\\f$.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p x or \\p y pointer is invalid."]
    pub fn rocsparse_gather(
        handle: rocsparse_handle,
        y: rocsparse_dnvec_descr,
        x: rocsparse_spvec_descr,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Scatter elements from a sparse vector into a dense vector.\n\n  \\details\n  \\ref rocsparse_scatter scatters the elements from the sparse vector \\f$x\\f$ in the dense\n  vector \\f$y\\f$.\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          y[x_ind[i]] = x_val[i];\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  x            sparse vector \\f$x\\f$.\n  @param[out]\n  y            dense vector \\f$y\\f$.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p x or \\p y pointer is invalid."]
    pub fn rocsparse_scatter(
        handle: rocsparse_handle,
        x: rocsparse_spvec_descr,
        y: rocsparse_dnvec_descr,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Apply Givens rotation to a dense and a sparse vector.\n\n  \\details\n  \\ref rocsparse_rot applies the Givens rotation matrix \\f$G\\f$ to the sparse vector\n  \\f$x\\f$ and the dense vector \\f$y\\f$, where\n  \\f[\n    G = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix}\n  \\f]\n\n  \\code{.c}\n      for(i = 0; i < nnz; ++i)\n      {\n          x_tmp = x_val[i];\n          y_tmp = y[x_ind[i]];\n\n          x_val[i]    = c * x_tmp + s * y_tmp;\n          y[x_ind[i]] = c * y_tmp - s * x_tmp;\n      }\n  \\endcode\n\n  \\note\n  This function is non blocking and executed asynchronously with respect to the host.\n  It may return before the actual computation has finished.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  c           pointer to the cosine element of \\f$G\\f$, can be on host or device.\n  @param[in]\n  s           pointer to the sine element of \\f$G\\f$, can be on host or device.\n  @param[inout]\n  x           sparse vector \\f$x\\f$.\n  @param[inout]\n  y           dense vector \\f$y\\f$.\n\n  \\retval     rocsparse_status_success the operation completed successfully.\n  \\retval     rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval     rocsparse_status_invalid_pointer \\p c, \\p s, \\p x or \\p y pointer is\n              invalid."]
    pub fn rocsparse_rot(
        handle: rocsparse_handle,
        c: *const ::std::os::raw::c_void,
        s: *const ::std::os::raw::c_void,
        x: rocsparse_spvec_descr,
        y: rocsparse_dnvec_descr,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse matrix to dense matrix conversion\n\n  \\details\n  \\p rocsparse_sparse_to_dense\n  \\p rocsparse_sparse_to_dense performs the conversion of a sparse matrix in CSR, CSC, or COO format to\n     a dense matrix\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the sparse to dense operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  mat_A        sparse matrix descriptor.\n  @param[in]\n  mat_B        dense matrix descriptor.\n  @param[in]\n  alg          algorithm for the sparse to dense computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the sparse to dense operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p mat_A, \\p mat_B, or \\p buffer_size\n               pointer is invalid."]
    pub fn rocsparse_sparse_to_dense(
        handle: rocsparse_handle,
        mat_A: rocsparse_spmat_descr,
        mat_B: rocsparse_dnmat_descr,
        alg: rocsparse_sparse_to_dense_alg,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Dense matrix to sparse matrix conversion\n\n  \\details\n  \\p rocsparse_dense_to_sparse\n  \\p rocsparse_dense_to_sparse performs the conversion of a dense matrix to a sparse matrix in CSR, CSC, or COO format.\n\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the dense to sparse operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  mat_A        dense matrix descriptor.\n  @param[in]\n  mat_B        sparse matrix descriptor.\n  @param[in]\n  alg          algorithm for the sparse to dense computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the dense to sparse operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p mat_A, \\p mat_B, or \\p buffer_size\n               pointer is invalid."]
    pub fn rocsparse_dense_to_sparse(
        handle: rocsparse_handle,
        mat_A: rocsparse_dnmat_descr,
        mat_B: rocsparse_spmat_descr,
        alg: rocsparse_dense_to_sparse_alg,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse vector inner dot product\n\n  \\details\n  \\ref rocsparse_spvv computes the inner dot product of the sparse vecotr \\f$x\\f$ with the\n  dense vector \\f$y\\f$, such that\n  \\f[\n    \\text{result} := x^{'} \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(x) = \\left\\{\n    \\begin{array}{ll}\n        x,   & \\text{if trans == rocsparse_operation_none} \\\\\n        \\bar{x}, & \\text{if trans == rocsparse_operation_conjugate_transpose} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\code{.c}\n      result = 0;\n      for(i = 0; i < nnz; ++i)\n      {\n          result += x_val[i] * y[x_ind[i]];\n      }\n  \\endcode\n\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the SpVV operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans        sparse vector operation type.\n  @param[in]\n  x            sparse vector descriptor.\n  @param[in]\n  y            dense vector descriptor.\n  @param[out]\n  result       pointer to the result, can be host or device memory\n  @param[in]\n  compute_type floating point precision for the SpVV computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpVV operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p x, \\p y, \\p result or \\p buffer_size\n               pointer is invalid.\n  \\retval      rocsparse_status_not_implemented \\p compute_type is currently not\n               supported.\n\n  \\par Example\n  \\code{.c}\n   // Number of non-zeros of the sparse vector\n   int nnz = 3;\n\n   // Size of sparse and dense vector\n   int size = 9;\n\n   // Sparse index vector\n   std::vector<int> hx_ind = {0, 3, 5};\n\n   // Sparse value vector\n   std::vector<float> hx_val = {1.0f, 2.0f, 3.0f};\n\n   // Dense vector\n   std::vector<float> hy = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f};\n\n   // Offload data to device\n   int* dx_ind;\n   float* dx_val;\n   float* dy;\n   hipMalloc((void**)&dx_ind, sizeof(int) * nnz);\n   hipMalloc((void**)&dx_val, sizeof(float) * nnz);\n   hipMalloc((void**)&dy, sizeof(float) * size);\n\n   hipMemcpy(dx_ind, hx_ind.data(), sizeof(int) * nnz, hipMemcpyHostToDevice);\n   hipMemcpy(dx_val, hx_val.data(), sizeof(float) * nnz, hipMemcpyHostToDevice);\n   hipMemcpy(dy, hy.data(), sizeof(float) * size, hipMemcpyHostToDevice);\n\n   rocsparse_handle     handle;\n   rocsparse_spvec_descr vecX;\n   rocsparse_dnvec_descr vecY;\n\n   rocsparse_indextype idx_type = rocsparse_indextype_i32;\n   rocsparse_datatype  data_type = rocsparse_datatype_f32_r;\n   rocsparse_datatype  compute_type = rocsparse_datatype_f32_r;\n   rocsparse_operation trans = rocsparse_operation_none;\n   rocsparse_index_base idx_base = rocsparse_index_base_zero;\n\n   rocsparse_create_handle(&handle);\n\n   // Create sparse vector X\n   rocsparse_create_spvec_descr(&vecX,\n                                size,\n                                nnz,\n                                dx_ind,\n                                dx_val,\n                                idx_type,\n                                idx_base,\n                                data_type);\n\n   // Create dense vector Y\n   rocsparse_create_dnvec_descr(&vecY,\n                                size,\n                                dy,\n                                data_type);\n\n   // Obtain buffer size\n   float hresult = 0.0f;\n   size_t buffer_size;\n   rocsparse_spvv(handle,\n                  trans,\n                  vecX,\n                  vecY,\n                  &hresult,\n                  compute_type,\n                  &buffer_size,\n                  nullptr);\n\n   void* temp_buffer;\n   hipMalloc(&temp_buffer, buffer_size);\n\n   // SpVV\n   rocsparse_spvv(handle,\n                  trans,\n                  vecX,\n                  vecY,\n                  &hresult,\n                  compute_type,\n                  &buffer_size,\n                  temp_buffer);\n\n   hipDeviceSynchronize();\n\n   std::cout << \"hresult: \" << hresult << std::endl;\n\n   // Clear rocSPARSE\n   rocsparse_destroy_spvec_descr(vecX);\n   rocsparse_destroy_dnvec_descr(vecY);\n   rocsparse_destroy_handle(handle);\n\n   // Clear device memory\n   hipFree(dx_ind);\n   hipFree(dx_val);\n   hipFree(dy);\n   hipFree(temp_buffer);\n  \\endcode"]
    pub fn rocsparse_spvv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        x: rocsparse_spvec_descr,
        y: rocsparse_dnvec_descr,
        result: *mut ::std::os::raw::c_void,
        compute_type: rocsparse_datatype,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse matrix vector multiplication\n\n  \\details\n  \\ref rocsparse_spmv multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix and the dense vector \\f$x\\f$ and adds the result to the dense vector \\f$y\\f$\n  that is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\details\n  \\ref rocsparse_spmv supports multiple combinations of data types and compute types. The tables below indicate the currently\n  supported different data types that can be used for for the sparse matrix A and the dense vectors X and Y and the compute\n  type for \\f$\\alpha\\f$ and \\f$\\beta\\f$. The advantage of using different data types is to save on memory bandwidth and storage\n  when a user application allows while performing the actual computation in a higher precision.\n\n  Uniform Precisions:\n  \\verbatim\n  |----------------------------------------------------|\n  |             A / X / Y / compute_type               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f32_r               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f64_r               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f32_c               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f64_c               |\n  |----------------------------------------------------|\n  \\endverbatim\n\n  Mixed precisions:\n  \\verbatim\n  |-------------------------|--------------------------|--------------------------|\n  |         A / X           |             Y            |       compute_type       |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_i32_r | rocsparse_datatype_i32_r |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_f32_r | rocsparse_datatype_f32_r |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_i32_r | rocsparse_datatype_i32_r |\n  |-------------------------|--------------------------|--------------------------|\n  \\endverbatim\n\n  Mixed-regular Complex precisions\n  \\verbatim\n  |----------------------------|----------------------------|\n  |              A             |    X / Y / compute_type    |\n  |----------------------------|----------------------------|\n  |  rocsparse_datatype_f32_r  |  rocsparse_datatype_f32_c  |\n  |----------------------------|----------------------------|\n  |  rocsparse_datatype_f64_r  |  rocsparse_datatype_f64_c  |\n  |----------------------------|----------------------------|\n  \\endverbatim\n\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the SpMV operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note\n  Only the \\ref rocsparse_spmv_stage_buffer_size stage and the \\ref rocsparse_spmv_stage_compute stage are non blocking\n  and executed asynchronously with respect to the host. They may return before the actual computation has finished.\n  The \\ref rocsparse_spmv_stage_preprocess stage is blocking with respect to the host.\n\n  \\note\n  Only the \\ref rocsparse_spmv_stage_buffer_size stage and the \\ref rocsparse_spmv_stage_compute stage\n  support execution in a hipGraph context. The \\ref rocsparse_spmv_stage_preprocess stage does not support hipGraph.\n\n  \\note\n  The sparse matrix formats currently supported are: rocsparse_format_bsr, rocsparse_format_coo,\n  rocsparse_format_coo_aos, rocsparse_format_csr, rocsparse_format_csc and rocsparse_format_ell.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans        matrix operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  mat          matrix descriptor.\n  @param[in]\n  x            vector descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[inout]\n  y            vector descriptor.\n  @param[in]\n  compute_type floating point precision for the SpMV computation.\n  @param[in]\n  alg          SpMV algorithm for the SpMV computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpMV operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p mat, \\p x, \\p beta, \\p y or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_invalid_value the value of \\p trans, \\p trans\\_B, \\p compute\\_type, \\p alg is incorrect.\n  \\retval      rocsparse_status_not_implemented \\p compute_type or \\p alg is\n               currently not supported."]
    pub fn rocsparse_spmv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat: rocsparse_spmat_descr,
        x: rocsparse_dnvec_descr,
        beta: *const ::std::os::raw::c_void,
        y: rocsparse_dnvec_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spmv_alg,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse matrix vector multiplication\n\n  \\details\n  \\ref rocsparse_spmv_ex multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times n\\f$\n  matrix and the dense vector \\f$x\\f$ and adds the result to the dense vector \\f$y\\f$\n  that is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    y := \\alpha \\cdot op(A) \\cdot x + \\beta \\cdot y,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\details\n  \\ref rocsparse_spmv supports multiple combinations of data types and compute types. The tables below indicate the currently\n  supported different data types that can be used for for the sparse matrix A and the dense vectors X and Y and the compute\n  type for \\f$\\alpha\\f$ and \\f$\\beta\\f$. The advantage of using different data types is to save on memory bandwidth and storage\n  when a user application allows while performing the actual computation in a higher precision.\n\n  Uniform Precisions:\n  \\verbatim\n  |----------------------------------------------------|\n  |             A / X / Y / compute_type               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f32_r               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f64_r               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f32_c               |\n  |----------------------------------------------------|\n  |             rocsparse_datatype_f64_c               |\n  |----------------------------------------------------|\n  \\endverbatim\n\n  Mixed precisions:\n  \\verbatim\n  |-------------------------|--------------------------|--------------------------|\n  |         A / X           |             Y            |       compute_type       |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_i32_r | rocsparse_datatype_i32_r |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_f32_r | rocsparse_datatype_f32_r |\n  |-------------------------|--------------------------|--------------------------|\n  | rocsparse_datatype_i8_r | rocsparse_datatype_i32_r | rocsparse_datatype_i32_r |\n  |-------------------------|--------------------------|--------------------------|\n  \\endverbatim\n\n  Mixed-regular Complex precisions\n  \\verbatim\n  |----------------------------|----------------------------|\n  |              A             |    X / Y / compute_type    |\n  |----------------------------|----------------------------|\n  |  rocsparse_datatype_f32_r  |  rocsparse_datatype_f32_c  |\n  |----------------------------|----------------------------|\n  |  rocsparse_datatype_f64_r  |  rocsparse_datatype_f64_c  |\n  |----------------------------|----------------------------|\n  \\endverbatim\n\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the SpMV operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note\n  The sparse matrix formats currently supported are: rocsparse_format_bsr, rocsparse_format_coo,\n  rocsparse_format_coo_aos, rocsparse_format_csr, rocsparse_format_csc and rocsparse_format_ell.\n\n  \\note SpMV_ex requires three stages to complete. The first stage\n  \\ref rocsparse_spmv_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls to \\ref rocsparse_spmv_ex. The second stage\n  \\ref rocsparse_spmv_stage_preprocess will preprocess data that would be saved in the temporary storage buffer.\n  In the final stage \\ref rocsparse_spmv_stage_compute, the actual computation is performed.\n  \\note If \\ref rocsparse_spmv_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  Else, the SpMV_ex preprocess and the SpMV algorithm will be executed.\n\n  \\note\n  Only the \\ref rocsparse_spmv_stage_buffer_size stage and the \\ref rocsparse_spmv_stage_compute stage are non blocking\n  and executed asynchronously with respect to the host. They may return before the actual computation has finished.\n  The \\ref rocsparse_spmv_stage_preprocess stage is blocking with respect to the host.\n\n  \\note\n  Only the \\ref rocsparse_spmv_stage_buffer_size stage and the \\ref rocsparse_spmv_stage_compute stage\n  support execution in a hipGraph context. The \\ref rocsparse_spmv_stage_preprocess stage does not support hipGraph.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans        matrix operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  mat          matrix descriptor.\n  @param[in]\n  x            vector descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[inout]\n  y            vector descriptor.\n  @param[in]\n  compute_type floating point precision for the SpMV computation.\n  @param[in]\n  alg          SpMV algorithm for the SpMV computation.\n  @param[in]\n  stage        SpMV stage for the SpMV computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpMV operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p mat, \\p x, \\p beta, \\p y or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_invalid_value the value of \\p trans, \\p trans\\_B, \\p compute\\_type, \\p alg or \\p stage is incorrect.\n  \\retval      rocsparse_status_not_implemented \\p compute_type or \\p alg is\n               currently not supported."]
    pub fn rocsparse_spmv_ex(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat: rocsparse_spmat_descr,
        x: rocsparse_dnvec_descr,
        beta: *const ::std::os::raw::c_void,
        y: rocsparse_dnvec_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spmv_alg,
        stage: rocsparse_spmv_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse triangular solve\n\n  \\details\n  \\p rocsparse_spsv_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR or COO storage format, a dense solution vector\n  \\f$y\\f$ and the right-hand side \\f$x\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot y = \\alpha \\cdot x,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note SpSV requires three stages to complete. The first stage\n  \\ref rocsparse_spsv_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls. The second stage\n  \\ref rocsparse_spsv_stage_preprocess will preprocess data that would be saved in the temporary storage buffer.\n  In the final stage \\ref rocsparse_spsv_stage_compute, the actual computation is performed.\n  \\note If \\ref rocsparse_spsv_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  If \\p buffer_size is equal to \\p nullptr, analysis will be performed.\n  Otherwise, the SpSV preprocess and the SpSV algorithm will be executed.\n\n  \\note\n  Only the \\ref rocsparse_spsv_stage_buffer_size stage and the \\ref rocsparse_spsv_stage_compute stage are non blocking\n  and executed asynchronously with respect to the host. They may return before the actual computation has finished.\n  The \\ref rocsparse_spsv_stage_preprocess stage is blocking with respect to the host.\n\n  \\note\n  Currently, only \\p trans == \\ref rocsparse_operation_none and \\p trans == \\ref rocsparse_operation_transpose is supported.\n\n  \\note\n  Only the \\ref rocsparse_spsv_stage_buffer_size stage and the \\ref rocsparse_spsv_stage_compute stage\n  support execution in a hipGraph context. The \\ref rocsparse_spsv_stage_preprocess stage does not support hipGraph.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans        matrix operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  mat          matrix descriptor.\n  @param[in]\n  x            vector descriptor.\n  @param[inout]\n  y            vector descriptor.\n  @param[in]\n  compute_type floating point precision for the SpSV computation.\n  @param[in]\n  alg          SpSV algorithm for the SpSV computation.\n  @param[in]\n  stage        SpSV stage for the SpSV computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpSV operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p mat, \\p x, \\p y, \\p descr or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_not_implemented \\p trans, \\p compute_type, \\p stage or \\p alg is\n               currently not supported."]
    pub fn rocsparse_spsv(
        handle: rocsparse_handle,
        trans: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat: rocsparse_spmat_descr,
        x: rocsparse_dnvec_descr,
        y: rocsparse_dnvec_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spsv_alg,
        stage: rocsparse_spsv_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse iterative triangular solve\n\n  \\details\n  \\p rocsparse_spitsv solves, using the Jacobi iterative method, a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR format, a dense solution vector\n  \\f$y\\f$ and the right-hand side \\f$x\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot y = \\alpha \\cdot x,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note SpITSV requires three stages to complete. The first stage\n  \\ref rocsparse_spitsv_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls. The second stage\n  \\ref rocsparse_spitsv_stage_preprocess will preprocess data that would be saved in the temporary storage buffer.\n  In the final stage \\ref rocsparse_spitsv_stage_compute, the actual computation is performed.\n  \\note If \\ref rocsparse_spitsv_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  If \\p buffer_size is equal to \\p nullptr, analysis will be performed.\n  Otherwise, the SpITSV preprocess and the SpITSV iterative algorithm will be executed.\n\n  \\note\n  Currently, only non-mixed numerical precision is supported.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[inout]\n  host_nmaxiter     maximum number of iteration on input and maximum number of iteration on output.\n  @param[in]\n  host_tol          if the pointer is null then loop will execute \\p nmaxiter[0] iterations. The precision is float for f32 based calculation (including the complex case) and double for f64 based calculation (including the complex case).\n  @param[out]\n  host_history      Optional array to record the history. The precision is float for f32 based calculation (including the complex case) and double for f64 based calculation (including the complex case).\n  @param[in]\n  trans        matrix operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  mat          matrix descriptor.\n  @param[in]\n  x            vector descriptor.\n  @param[inout]\n  y            vector descriptor.\n  @param[in]\n  compute_type floating point precision for the SpITSV computation.\n  @param[in]\n  alg          SpITSV algorithm for the SpITSV computation.\n  @param[in]\n  stage        SpITSV stage for the SpITSV computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpITSV operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p mat, \\p x, \\p y, \\p descr or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_not_implemented \\p trans, \\p compute_type, \\p stage or \\p alg is\n               currently not supported."]
    pub fn rocsparse_spitsv(
        handle: rocsparse_handle,
        host_nmaxiter: *mut rocsparse_int,
        host_tol: *const ::std::os::raw::c_void,
        host_history: *mut ::std::os::raw::c_void,
        trans: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat: rocsparse_spmat_descr,
        x: rocsparse_dnvec_descr,
        y: rocsparse_dnvec_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spitsv_alg,
        stage: rocsparse_spitsv_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse triangular system solve\n\n  \\details\n  \\p rocsparse_spsm_solve solves a sparse triangular linear system of a sparse\n  \\f$m \\times m\\f$ matrix, defined in CSR or COO storage format, a dense solution matrix\n  \\f$C\\f$ and the right-hand side \\f$B\\f$ that is multiplied by \\f$\\alpha\\f$, such that\n  \\f[\n    op(A) \\cdot C = \\alpha \\cdot op(B),\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note SpSM requires three stages to complete. The first stage\n  \\ref rocsparse_spsm_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls. The second stage\n  \\ref rocsparse_spsm_stage_preprocess will preprocess data that would be saved in the temporary storage buffer.\n  In the final stage \\ref rocsparse_spsm_stage_compute, the actual computation is performed.\n  \\note If \\ref rocsparse_spsm_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  If \\p buffer_size is equal to \\p nullptr, analysis will be performed.\n  Otherwise, the SpSM preprocess and the SpSM algorithm will be executed.\n\n  \\note\n  Only the \\ref rocsparse_spsm_stage_buffer_size stage and the \\ref rocsparse_spsm_stage_compute stage are non blocking\n  and executed asynchronously with respect to the host. They may return before the actual computation has finished.\n  The \\ref rocsparse_spsm_stage_preprocess stage is blocking with respect to the host.\n\n  \\note\n  Currently, only \\p trans_A == \\ref rocsparse_operation_none and \\p trans_A == \\ref rocsparse_operation_transpose is supported.\n  Currently, only \\p trans_B == \\ref rocsparse_operation_none and \\p trans_B == \\ref rocsparse_operation_transpose is supported.\n\n  \\note\n  Only the \\ref rocsparse_spsm_stage_buffer_size stage and the \\ref rocsparse_spsm_stage_compute stage\n  support execution in a hipGraph context. The \\ref rocsparse_spsm_stage_preprocess stage does not support hipGraph.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans_A      matrix operation type for the sparse matrix A.\n  @param[in]\n  trans_B      matrix operation type for the dense matrix B.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  matA          sparse matrix descriptor.\n  @param[in]\n  matB          dense matrix descriptor.\n  @param[inout]\n  matC          dense matrix descriptor.\n  @param[in]\n  compute_type floating point precision for the SpSM computation.\n  @param[in]\n  alg          SpSM algorithm for the SpSM computation.\n  @param[in]\n  stage        SpSM stage for the SpSM computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpSM operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p matA, \\p matB, \\p matC, \\p descr or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_not_implemented \\p trans_A, \\p trans_B, \\p compute_type, \\p stage or \\p alg is\n               currently not supported."]
    pub fn rocsparse_spsm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        matA: rocsparse_spmat_descr,
        matB: rocsparse_dnmat_descr,
        matC: rocsparse_dnmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spsm_alg,
        stage: rocsparse_spsm_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse matrix dense matrix multiplication, extension routine.\n\n  \\details\n  \\p rocsparse_spmm (or \\p rocsparse_spmm_ex ) multiplies the scalar \\f$\\alpha\\f$ with a sparse \\f$m \\times k\\f$\n  matrix \\f$A\\f$, defined in CSR or COO or Blocked ELL storage format, and the dense \\f$k \\times n\\f$\n  matrix \\f$B\\f$ and adds the result to the dense \\f$m \\times n\\f$ matrix \\f$C\\f$ that\n  is multiplied by the scalar \\f$\\beta\\f$, such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot C,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note\n  Only the \\ref rocsparse_spmm_stage_buffer_size stage and the \\ref rocsparse_spmm_stage_compute stage are non blocking\n  and executed asynchronously with respect to the host. They may return before the actual computation has finished.\n  The \\ref rocsparse_spmm_stage_preprocess stage is blocking with respect to the host.\n\n  \\note\n  Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported for COO and Blocked ELL formats.\n\n  \\note\n  Only the \\ref rocsparse_spmm_stage_buffer_size stage and the \\ref rocsparse_spmm_stage_compute stage\n  support execution in a hipGraph context. The \\ref rocsparse_spmm_stage_preprocess stage does not support hipGraph.\n\n  \\note\n  Currently, only CSR, COO and Blocked ELL sparse formats are supported.\n\n  \\note\n  Different algorithms are available which can provide better performance for different matrices.\n  Currently, the available algorithms are rocsparse_spmm_alg_csr, rocsparse_spmm_alg_csr_row_split\n  or rocsparse_spmm_alg_csr_merge for CSR matrices, rocsparse_spmm_alg_bell for Blocked ELL matrices and\n  rocsparse_spmm_alg_coo_segmented or rocsparse_spmm_alg_coo_atomic for COO matrices. Additionally,\n  one can specify the algorithm to be rocsparse_spmm_alg_default. In the case of CSR matrices this will\n  set the algorithm to be rocsparse_spmm_alg_csr, in the case of Blocked ELL matrices this will set the\n  algorithm to be rocsparse_spmm_alg_bell and for COO matrices it will set the algorithm to be\n  rocsparse_spmm_alg_coo_atomic. When A is transposed, rocsparse_spmm will revert to using\n  rocsparse_spmm_alg_csr for CSR format and rocsparse_spmm_alg_coo_atomic for COO format regardless\n  of algorithm selected.\n\n  \\note\n  This function writes the required allocation size (in bytes) to \\p buffer_size and\n  returns without performing the SpMM operation, when a nullptr is passed for\n  \\p temp_buffer.\n\n  \\note SpMM requires three stages to complete. The first stage\n  \\ref rocsparse_spmm_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls to \\ref rocsparse_spmm (or \\ref rocsparse_spmm_ex). The second stage\n  \\ref rocsparse_spmm_stage_preprocess will preprocess data that would be saved in the temporary storage buffer.\n  In the final stage \\ref rocsparse_spmm_stage_compute, the actual computation is performed.\n  \\note If \\ref rocsparse_spmm_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  Else, the SpMM preprocess and the SpMM algorithm will be executed.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans_A      matrix operation type.\n  @param[in]\n  trans_B      matrix operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  mat_A        matrix descriptor.\n  @param[in]\n  mat_B        matrix descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[in]\n  mat_C        matrix descriptor.\n  @param[in]\n  compute_type floating point precision for the SpMM computation.\n  @param[in]\n  alg          SpMM algorithm for the SpMM computation.\n  @param[in]\n  stage        SpMM stage for the SpMM computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpMM operation.\n\n  \\retval      rocsparse_status_success the operation completed successfully.\n  \\retval      rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval      rocsparse_status_invalid_pointer \\p alpha, \\p mat_A, \\p mat_B, \\p mat_C, \\p beta, or\n               \\p buffer_size pointer is invalid.\n  \\retval      rocsparse_status_not_implemented \\p trans_A, \\p trans_B, \\p compute_type or \\p alg is\n               currently not supported.\n  \\par Example\n  This example performs sparse matrix-dense matrix multiplication, C = alpha * A * B + beta * C\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      //     1 4 2\n      //     1 2 3\n      // B = 5 4 0\n      //     3 1 9\n      //     1 2 2\n      //     0 3 0\n\n      //     1 1 5\n      // C = 1 2 1\n      //     1 3 1\n      //     6 2 4\n\n      rocsparse_int m   = 4;\n      rocsparse_int k   = 6;\n      rocsparse_int n   = 3;\n\n      csr_row_ptr[m + 1] = {0, 1, 3};                                              // device memory\n      csr_col_ind[nnz]   = {0, 0, 1};                                              // device memory\n      csr_val[nnz]       = {1, 0, 4, 2, 0, 3, 5, 0, 0, 0, 0, 9, 7, 0, 8, 6, 0, 0}; // device memory\n\n      B[k * n]       = {1, 1, 5, 3, 1, 0, 4, 2, 4, 1, 2, 3, 2, 3, 0, 9, 2, 0};     // device memory\n      C[m * n]       = {1, 1, 1, 6, 1, 2, 3, 2, 5, 1, 1, 4};                       // device memory\n\n      rocsparse_int nnz = csr_row_ptr[m] - csr_row_ptr[0];\n\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Create CSR arrays on device\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n      float* B;\n      float* C;\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnz);\n      hipMalloc((void**)&B, sizeof(float) * k * n);\n      hipMalloc((void**)&C, sizeof(float) * m * n);\n\n      // Create rocsparse handle\n      rocsparse_local_handle handle;\n\n      // Types\n      rocsparse_indextype itype = rocsparse_indextype_i32;\n      rocsparse_indextype jtype = rocsparse_indextype_i32;\n      rocsparse_datatype  ttype = rocsparse_datatype_f32_r;\n\n      // Create descriptors\n      rocsparse_spmat_descr mat_A;\n      rocsparse_dnmat_descr mat_B;\n      rocsparse_dnmat_descr mat_C;\n\n      rocsparse_create_csr_descr(&mat_A, m, k, nnz, csr_row_ptr, csr_col_ind, csr_val, itype, jtype, rocsparse_index_base_zero, ttype);\n      rocsparse_create_dnmat_descr(&mat_B, k, n, k, B, ttype, rocsparse_order_column);\n      rocsparse_create_dnmat_descr(&mat_C, m, n, m, C, ttype, rocsparse_order_column);\n\n      // Query SpMM buffer\n      size_t buffer_size;\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_buffer_size,\n                     &buffer_size,\n                     nullptr));\n\n      // Allocate buffer\n      void* buffer;\n      hipMalloc(&buffer, buffer_size);\n\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_preprocess,\n                     &buffer_size,\n                     buffer));\n\n      // Pointer mode host\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_compute,\n                     &buffer_size,\n                     buffer));\n\n      // Clear up on device\n      hipFree(csr_row_ptr);\n      hipFree(csr_col_ind);\n      hipFree(csr_val);\n      hipFree(B);\n      hipFree(C);\n      hipFree(temp_buffer);\n\n      rocsparse_destroy_spmat_descr(mat_A);\n      rocsparse_destroy_dnmat_descr(mat_B);\n      rocsparse_destroy_dnmat_descr(mat_C);\n  \\endcode\n\n  \\par Example\n  SpMM also supports batched computation for CSR and COO matrices. There are three supported batch modes:\n      C_i = A * B_i\n      C_i = A_i * B\n      C_i = A_i * B_i\n  The batch mode is determined by the batch count and stride passed for each matrix. For example\n  to use the first batch mode (C_i = A * B_i) with 100 batches for non-transposed A, B, and C, one passes:\n      batch_count_A = 1\n      batch_count_B = 100\n      batch_count_C = 100\n      offsets_batch_stride_A        = 0\n      columns_values_batch_stride_A = 0\n      batch_stride_B                = k * n\n      batch_stride_C                = m * n\n  To use the second batch mode (C_i = A_i * B) one could use:\n      batch_count_A = 100\n      batch_count_B = 1\n      batch_count_C = 100\n      offsets_batch_stride_A        = m + 1\n      columns_values_batch_stride_A = nnz\n      batch_stride_B                = 0\n      batch_stride_C                = m * n\n  And to use the third batch mode (C_i = A_i * B_i) one could use:\n      batch_count_A = 100\n      batch_count_B = 100\n      batch_count_C = 100\n      offsets_batch_stride_A        = m + 1\n      columns_values_batch_stride_A = nnz\n      batch_stride_B                = k * n\n      batch_stride_C                = m * n\n  An example of the first batch mode (C_i = A * B_i) is provided below.\n  \\code{.c}\n      //     1 4 0 0 0 0\n      // A = 0 2 3 0 0 0\n      //     5 0 0 7 8 0\n      //     0 0 9 0 6 0\n\n      rocsparse_int m   = 4;\n      rocsparse_int k   = 6;\n      rocsparse_int n   = 3;\n\n      csr_row_ptr[m + 1] = {0, 1, 3};                                              // device memory\n      csr_col_ind[nnz]   = {0, 0, 1};                                              // device memory\n      csr_val[nnz]       = {1, 0, 4, 2, 0, 3, 5, 0, 0, 0, 0, 9, 7, 0, 8, 6, 0, 0}; // device memory\n\n      B[batch_count_B * k * n]       = {...};     // device memory\n      C[batch_count_C * m * n]       = {...};     // device memory\n\n      rocsparse_int nnz = csr_row_ptr[m] - csr_row_ptr[0];\n\n      rocsparse_int batch_count_A = 1;\n      rocsparse_int batch_count_B = 100;\n      rocsparse_int batch_count_C = 100;\n\n      rocsparse_int offsets_batch_stride_A        = 0;\n      rocsparse_int columns_values_batch_stride_A = 0;\n      rocsparse_int batch_stride_B                = k * n;\n      rocsparse_int batch_stride_C                = m * n;\n\n      float alpha = 1.0f;\n      float beta  = 0.0f;\n\n      // Create CSR arrays on device\n      rocsparse_int* csr_row_ptr;\n      rocsparse_int* csr_col_ind;\n      float* csr_val;\n      float* B;\n      float* C;\n      hipMalloc((void**)&csr_row_ptr, sizeof(rocsparse_int) * (m + 1));\n      hipMalloc((void**)&csr_col_ind, sizeof(rocsparse_int) * nnz);\n      hipMalloc((void**)&csr_val, sizeof(float) * nnz);\n      hipMalloc((void**)&B, sizeof(float) * batch_count_B * k * n);\n      hipMalloc((void**)&C, sizeof(float) * batch_count_C * m * n);\n\n      // Create rocsparse handle\n      rocsparse_local_handle handle;\n\n      // Types\n      rocsparse_indextype itype = rocsparse_indextype_i32;\n      rocsparse_indextype jtype = rocsparse_indextype_i32;\n      rocsparse_datatype  ttype = rocsparse_datatype_f32_r;\n\n      // Create descriptors\n      rocsparse_spmat_descr mat_A;\n      rocsparse_dnmat_descr mat_B;\n      rocsparse_dnmat_descr mat_C;\n\n      rocsparse_create_csr_descr(&mat_A, m, k, nnz, csr_row_ptr, csr_col_ind, csr_val, itype, jtype, rocsparse_index_base_zero, ttype);\n      rocsparse_create_dnmat_descr(&mat_B, k, n, k, B, ttype, rocsparse_order_column);\n      rocsparse_create_dnmat_descr(&mat_C, m, n, m, C, ttype, rocsparse_order_column);\n\n      rocsparse_csr_set_strided_batch(mat_A, batch_count_A, offsets_batch_stride_A, columns_values_batch_stride_A);\n      rocsparse_dnmat_set_strided_batch(B, batch_count_B, batch_stride_B);\n      rocsparse_dnmat_set_strided_batch(C, batch_count_C, batch_stride_C);\n\n      // Query SpMM buffer\n      size_t buffer_size;\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_buffer_size,\n                     &buffer_size,\n                     nullptr));\n\n      // Allocate buffer\n      void* buffer;\n      hipMalloc(&buffer, buffer_size);\n\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_preprocess,\n                     &buffer_size,\n                     buffer));\n\n      // Pointer mode host\n      rocsparse_spmm(handle,\n                     rocsparse_operation_none,\n                     rocsparse_operation_none,\n                     &alpha,\n                     mat_A,\n                     mat_B,\n                     &beta,\n                     mat_C,\n                     ttype,\n                     rocsparse_spmm_alg_default,\n                     rocsparse_spmm_stage_compute,\n                     &buffer_size,\n                     buffer));\n\n      // Clear up on device\n      hipFree(csr_row_ptr);\n      hipFree(csr_col_ind);\n      hipFree(csr_val);\n      hipFree(B);\n      hipFree(C);\n      hipFree(temp_buffer);\n\n      rocsparse_destroy_spmat_descr(mat_A);\n      rocsparse_destroy_dnmat_descr(mat_B);\n      rocsparse_destroy_dnmat_descr(mat_C);\n  \\endcode\n/\n/**@{"]
    pub fn rocsparse_spmm_ex(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat_A: rocsparse_spmat_descr,
        mat_B: rocsparse_dnmat_descr,
        beta: *const ::std::os::raw::c_void,
        mat_C: rocsparse_dnmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spmm_alg,
        stage: rocsparse_spmm_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_spmm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        mat_A: rocsparse_spmat_descr,
        mat_B: rocsparse_dnmat_descr,
        beta: *const ::std::os::raw::c_void,
        mat_C: rocsparse_dnmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spmm_alg,
        stage: rocsparse_spmm_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Sparse matrix sparse matrix multiplication\n\n  \\details\n  \\ref rocsparse_spgemm multiplies the scalar \\f$\\alpha\\f$ with the sparse\n  \\f$m \\times k\\f$ matrix \\f$A\\f$ and the sparse \\f$k \\times n\\f$ matrix \\f$B\\f$ and\n  adds the result to the sparse \\f$m \\times n\\f$ matrix \\f$D\\f$ that is multiplied by\n  \\f$\\beta\\f$. The final result is stored in the sparse \\f$m \\times n\\f$ matrix \\f$C\\f$,\n  such that\n  \\f[\n    C := \\alpha \\cdot op(A) \\cdot op(B) + \\beta \\cdot D,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if trans_A == rocsparse_operation_none} \\\\\n        A^T, & \\text{if trans_A == rocsparse_operation_transpose} \\\\\n        A^H, & \\text{if trans_A == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n  and\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if trans_B == rocsparse_operation_none} \\\\\n        B^T, & \\text{if trans_B == rocsparse_operation_transpose} \\\\\n        B^H, & \\text{if trans_B == rocsparse_operation_conjugate_transpose}\n    \\end{array}\n    \\right.\n  \\f]\n\n  \\note SpGEMM requires three stages to complete. The first stage\n  \\ref rocsparse_spgemm_stage_buffer_size will return the size of the temporary storage buffer\n  that is required for subsequent calls to \\ref rocsparse_spgemm. The second stage\n  \\ref rocsparse_spgemm_stage_nnz will determine the number of non-zero elements of the\n  resulting \\f$C\\f$ matrix. If the sparsity pattern of \\f$C\\f$ is already known, this\n  stage can be skipped. In the final stage \\ref rocsparse_spgemm_stage_compute, the actual\n  computation is performed.\n  \\note If \\ref rocsparse_spgemm_stage_auto is selected, rocSPARSE will automatically detect\n  which stage is required based on the following indicators:\n  If \\p temp_buffer is equal to \\p nullptr, the required buffer size will be returned.\n  Else, if the number of non-zeros of \\f$C\\f$ is zero, the number of non-zero entries will be\n  computed.\n  Else, the SpGEMM algorithm will be executed.\n  \\note If \\f$\\alpha == 0\\f$, then \\f$C = \\beta \\cdot D\\f$ will be computed.\n  \\note If \\f$\\beta == 0\\f$, then \\f$C = \\alpha \\cdot op(A) \\cdot op(B)\\f$ will be\n  computed.\n  \\note Currently only CSR and BSR formats are supported.\n  \\note If \\ref rocsparse_spgemm_stage_symbolic is selected then the symbolic computation is performed only.\n  \\note If \\ref rocsparse_spgemm_stage_numeric is selected then the numeric computation is performed only.\n  \\note For the \\ref rocsparse_spgemm_stage_symbolic and \\ref rocsparse_spgemm_stage_numeric stages, only\n  CSR matrix format is currently supported.\n  \\note \\f$\\alpha == beta == 0\\f$ is invalid.\n  \\note It is allowed to pass the same sparse matrix for \\f$C\\f$ and \\f$D\\f$, if both\n  matrices have the same sparsity pattern.\n  \\note Currently, only \\p trans_A == \\ref rocsparse_operation_none is supported.\n  \\note Currently, only \\p trans_B == \\ref rocsparse_operation_none is supported.\n  \\note This function is non blocking and executed asynchronously with respect to the\n        host. It may return before the actual computation has finished.\n  \\note Please note, that for rare matrix products with more than 4096 non-zero entries\n  per row, additional temporary storage buffer is allocated by the algorithm.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  trans_A      sparse matrix \\f$A\\f$ operation type.\n  @param[in]\n  trans_B      sparse matrix \\f$B\\f$ operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  A            sparse matrix \\f$A\\f$ descriptor.\n  @param[in]\n  B            sparse matrix \\f$B\\f$ descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[in]\n  D            sparse matrix \\f$D\\f$ descriptor.\n  @param[out]\n  C            sparse matrix \\f$C\\f$ descriptor.\n  @param[in]\n  compute_type floating point precision for the SpGEMM computation.\n  @param[in]\n  alg          SpGEMM algorithm for the SpGEMM computation.\n  @param[in]\n  stage        SpGEMM stage for the SpGEMM computation.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer. buffer_size is set when\n               \\p temp_buffer is nullptr.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user. When a nullptr is passed,\n               the required allocation size (in bytes) is written to \\p buffer_size and\n               function returns without performing the SpGEMM operation.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p A, \\p B, \\p D, \\p C or \\p buffer_size pointer is invalid.\n  \\retval rocsparse_status_memory_error additional buffer for long rows could not be\n          allocated.\n  \\retval rocsparse_status_not_implemented\n          \\p trans_A != \\ref rocsparse_operation_none or\n          \\p trans_B != \\ref rocsparse_operation_none."]
    pub fn rocsparse_spgemm(
        handle: rocsparse_handle,
        trans_A: rocsparse_operation,
        trans_B: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        A: rocsparse_spmat_descr,
        B: rocsparse_spmat_descr,
        beta: *const ::std::os::raw::c_void,
        D: rocsparse_spmat_descr,
        C: rocsparse_spmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_spgemm_alg,
        stage: rocsparse_spgemm_stage,
        buffer_size: *mut usize,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief  Sampled Dense-Dense Matrix Multiplication.\n\n  \\details\n  \\ref rocsparse_sddmm multiplies the scalar \\f$\\alpha\\f$ with the dense\n  \\f$m \\times k\\f$ matrix \\f$A\\f$, the dense \\f$k \\times n\\f$ matrix \\f$B\\f$, filtered by the sparsity pattern of the \\f$m \\times n\\f$ sparse matrix \\f$C\\f$ and\n  adds the result to \\f$C\\f$ scaled by\n  \\f$\\beta\\f$. The final result is stored in the sparse \\f$m \\times n\\f$ matrix \\f$C\\f$,\n  such that\n  \\f[\n    C := \\alpha ( opA(A) \\cdot opB(B) ) \\cdot spy(C) + \\beta C,\n  \\f]\n  with\n  \\f[\n    op(A) = \\left\\{\n    \\begin{array}{ll}\n        A,   & \\text{if opA == rocsparse_operation_none} \\\\\n        A^T,   & \\text{if opA == rocsparse_operation_transpose} \\\\\n    \\end{array}\n    \\right.\n  \\f],\n  \\f[\n    op(B) = \\left\\{\n    \\begin{array}{ll}\n        B,   & \\text{if opB == rocsparse_operation_none} \\\\\n        B^T,   & \\text{if opB == rocsparse_operation_transpose} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n   and\n  \\f[\n    spy(C)_ij = \\left\\{\n    \\begin{array}{ll}\n        1 \\text{if i == j},   & 0 \\text{if i != j} \\\\\n    \\end{array}\n    \\right.\n  \\f]\n  \\note \\p opA == \\ref rocsparse_operation_conjugate_transpose is not supported.\n  \\note \\p opB == \\ref rocsparse_operation_conjugate_transpose is not supported.\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  opA      dense matrix \\f$A\\f$ operation type.\n  @param[in]\n  opB      dense matrix \\f$B\\f$ operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  A            dense matrix \\f$A\\f$ descriptor.\n  @param[in]\n  B            dense matrix \\f$B\\f$ descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[inout]\n  C            sparse matrix \\f$C\\f$ descriptor.\n  @param[in]\n  compute_type floating point precision for the SDDMM computation.\n  @param[in]\n  alg specification of the algorithm to use.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user.\n  The size must be greater or equal to the size obtained with \\ref rocsparse_sddmm_buffer_size.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_value the value of \\p trans\\_A, \\p trans\\_B, \\p compute\\_type or alg is incorrect.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p A, \\p B, \\p D, \\p C or \\p temp_buffer pointer is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p opA == \\ref rocsparse_operation_conjugate_transpose or\n          \\p opB == \\ref rocsparse_operation_conjugate_transpose."]
    pub fn rocsparse_sddmm(
        handle: rocsparse_handle,
        opA: rocsparse_operation,
        opB: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        A: rocsparse_dnmat_descr,
        B: rocsparse_dnmat_descr,
        beta: *const ::std::os::raw::c_void,
        C: rocsparse_spmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_sddmm_alg,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Calculate the size in bytes of the required buffer for the use of \\ref rocsparse_sddmm and \\ref rocsparse_sddmm_preprocess\n\n  \\details\n  \\ref rocsparse_sddmm_buffer_size returns the size of the required buffer to execute the SDDMM operation from a given configuration.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  opA      dense matrix \\f$A\\f$ operation type.\n  @param[in]\n  opB      dense matrix \\f$B\\f$ operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  A            dense matrix \\f$A\\f$ descriptor.\n  @param[in]\n  B            dense matrix \\f$B\\f$ descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[inout]\n  C            sparse matrix \\f$C\\f$ descriptor.\n  @param[in]\n  compute_type floating point precision for the SDDMM computation.\n  @param[in]\n  alg specification of the algorithm to use.\n  @param[out]\n  buffer_size  number of bytes of the temporary storage buffer.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_value the value of \\p trans\\_A or \\p trans\\_B is incorrect.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p A, \\p B, \\p D, \\p C or \\p buffer_size pointer is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p opA == \\ref rocsparse_operation_conjugate_transpose or\n          \\p opB == \\ref rocsparse_operation_conjugate_transpose."]
    pub fn rocsparse_sddmm_buffer_size(
        handle: rocsparse_handle,
        opA: rocsparse_operation,
        opB: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        A: rocsparse_dnmat_descr,
        B: rocsparse_dnmat_descr,
        beta: *const ::std::os::raw::c_void,
        C: rocsparse_spmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_sddmm_alg,
        buffer_size: *mut usize,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup generic_module\n  \\brief Preprocess data before the use of \\ref rocsparse_sddmm.\n\n  \\details\n  \\ref rocsparse_sddmm_preprocess executes a part of the algorithm that can be calculated once in the context of multiple calls of the \\ref rocsparse_sddmm\n  with the same sparsity pattern.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n  @param[in]\n  handle       handle to the rocsparse library context queue.\n  @param[in]\n  opA      dense matrix \\f$A\\f$ operation type.\n  @param[in]\n  opB      dense matrix \\f$B\\f$ operation type.\n  @param[in]\n  alpha        scalar \\f$\\alpha\\f$.\n  @param[in]\n  A            dense matrix \\f$A\\f$ descriptor.\n  @param[in]\n  B            dense matrix \\f$B\\f$ descriptor.\n  @param[in]\n  beta         scalar \\f$\\beta\\f$.\n  @param[inout]\n  C            sparse matrix \\f$C\\f$ descriptor.\n  @param[in]\n  compute_type floating point precision for the SDDMM computation.\n  @param[in]\n  alg specification of the algorithm to use.\n  @param[in]\n  temp_buffer  temporary storage buffer allocated by the user.\n  The size must be greater or equal to the size obtained with \\ref rocsparse_sddmm_buffer_size.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_value the value of \\p trans\\_A or \\p trans\\_B is incorrect.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_pointer \\p alpha and \\p beta are invalid,\n          \\p A, \\p B, \\p D, \\p C or \\p temp_buffer pointer is invalid.\n  \\retval rocsparse_status_not_implemented\n          \\p opA == \\ref rocsparse_operation_conjugate_transpose or\n          \\p opB == \\ref rocsparse_operation_conjugate_transpose."]
    pub fn rocsparse_sddmm_preprocess(
        handle: rocsparse_handle,
        opA: rocsparse_operation,
        opB: rocsparse_operation,
        alpha: *const ::std::os::raw::c_void,
        A: rocsparse_dnmat_descr,
        B: rocsparse_dnmat_descr,
        beta: *const ::std::os::raw::c_void,
        C: rocsparse_spmat_descr,
        compute_type: rocsparse_datatype,
        alg: rocsparse_sddmm_alg,
        temp_buffer: *mut ::std::os::raw::c_void,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    #[doc = " \\ingroup reordering_module\n  \\brief Coloring of the adjacency graph of the matrix \\f$A\\f$ stored in the CSR format.\n\n  \\details\n  \\p rocsparse_csrcolor performs the coloring of the undirected graph represented by the (symmetric) sparsity pattern of the\n  matrix \\f$A\\f$ stored in CSR format. Graph coloring is a way of coloring the nodes of a graph such that no two adjacent nodes\n  are of the same color. The \\p fraction_to_color is a parameter to only color a given percentage of the graph nodes, the\n  remaining uncolored nodes receive distinct new colors. The optional \\p reordering array is a permutation array such that\n  unknowns of the same color are grouped. The matrix \\f$A\\f$ must be stored as a general matrix with a symmetric sparsity pattern,\n  and if the matrix \\f$A\\f$ is non-symmetric then the user is responsible to provide the symmetric part \\f$\\frac{A+A^T}{2}\\f$.\n\n  \\note\n  This function is blocking with respect to the host.\n\n  \\note\n  This routine does not support execution in a hipGraph context.\n\n  @param[in]\n  handle      handle to the rocsparse library context queue.\n  @param[in]\n  m           number of rows of sparse matrix \\f$A\\f$.\n  @param[in]\n  nnz         number of non-zero entries of sparse matrix \\f$A\\f$.\n  @param[in]\n  descr      sparse matrix descriptor.\n  @param[in]\n  csr_val     array of \\p nnz elements of the sparse CSR matrix.\n  @param[in]\n  csr_row_ptr array of \\p m+1 elements that point to the start of every row of the\n              sparse CSR matrix.\n  @param[in]\n  csr_col_ind array of \\p nnz elements containing the column indices of the sparse\n              CSR matrix.\n  @param[in]\n  fraction_to_color  fraction of nodes to be colored, which should be in the interval [0.0,1.0], for example 0.8 implies that 80 percent of nodes will be colored.\n  @param[out]\n  ncolors      resulting number of distinct colors.\n  @param[out]\n  coloring     resulting mapping of colors.\n  @param[out]\n  reordering   optional resulting reordering permutation if \\p reordering is a non-null pointer.\n  @param[inout]\n  info    structure that holds the information collected during the coloring algorithm.\n\n  \\retval rocsparse_status_success the operation completed successfully.\n  \\retval rocsparse_status_invalid_handle the library context was not initialized.\n  \\retval rocsparse_status_invalid_size \\p m or \\p nnz is invalid.\n  \\retval rocsparse_status_invalid_pointer \\p descr, \\p csr_val, \\p csr_row_ptr, \\p csr_col_ind, \\p fraction_to_color, \\p ncolors, \\p coloring or \\p info pointer is invalid.\n/\n/**@{"]
    pub fn rocsparse_scsrcolor(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f32,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        fraction_to_color: *const f32,
        ncolors: *mut rocsparse_int,
        coloring: *mut rocsparse_int,
        reordering: *mut rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_dcsrcolor(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const f64,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        fraction_to_color: *const f64,
        ncolors: *mut rocsparse_int,
        coloring: *mut rocsparse_int,
        reordering: *mut rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_ccsrcolor(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_float_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        fraction_to_color: *const f32,
        ncolors: *mut rocsparse_int,
        coloring: *mut rocsparse_int,
        reordering: *mut rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
extern "C" {
    #[must_use]
    pub fn rocsparse_zcsrcolor(
        handle: rocsparse_handle,
        m: rocsparse_int,
        nnz: rocsparse_int,
        descr: rocsparse_mat_descr,
        csr_val: *const rocsparse_double_complex,
        csr_row_ptr: *const rocsparse_int,
        csr_col_ind: *const rocsparse_int,
        fraction_to_color: *const f64,
        ncolors: *mut rocsparse_int,
        coloring: *mut rocsparse_int,
        reordering: *mut rocsparse_int,
        info: rocsparse_mat_info,
    ) -> rocsparse_status;
}
